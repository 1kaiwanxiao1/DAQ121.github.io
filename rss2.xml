<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>代澳旗&#39;s Blog</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>用来存储学习笔记！</description>
    <pubDate>Sun, 15 Mar 2020 06:10:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TCP三次握手和四次挥手</title>
      <link>http://yoursite.com/2020/03/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <guid>http://yoursite.com/2020/03/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <pubDate>Sun, 15 Mar 2020 05:01:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略来建立连接。通过四次挥手来释放连接。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略来建立连接。通过四次挥手来释放连接。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200315135901175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>序列号seq：</strong> 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li></ul><ul><li><strong>确认号ack：</strong> 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li></ul><ul><li><strong>确认ACK：</strong> 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li></ul><ul><li><strong>同步SYN：</strong> 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li></ul><ul><li><strong>终止FIN：</strong> 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li></ul><ul><li><strong>补充：</strong> ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</li></ul><h2 id="三次握手过程与作用"><a href="#三次握手过程与作用" class="headerlink" title="三次握手过程与作用"></a>三次握手过程与作用</h2><p>刚开始客户端处于<code>CLOSE</code>的状态，服务端处于<code>LISTEN</code>状态。<br><strong>第一次握手：</strong></p><ul><li>建立连接时，客户端发送SYN包（同时随机生成初始序列号seq=x，并进入<code>SYN_SENT</code>状态，等待服务器确认。</li><li>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</li></ul><p> <strong>第二次握手：</strong></p><ul><li>服务器收到SYN包，发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要<strong>为自己</strong>随机初始化一个序列号 seq=y，此时服务器进入<code>SYN_RECV</code>状态。</li><li>这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</li></ul><p><strong>第三次握手：</strong></p><ul><li>客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。</li></ul><ul><li>第三次的ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315113736297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>三次握手的作用</strong></p><ol><li>确认双方的接受能力，发送能力是否正常。</li><li>指定自己的初始化序列号，为后面的可靠传送做准备。</li><li>如果是Https协议的话，三次握手这个过程，还会进行数字证书的验证，以及加密秘钥的生成。</li></ol><h2 id="面试常见问题："><a href="#面试常见问题：" class="headerlink" title="面试常见问题："></a>面试常见问题：</h2><h3 id="①（ISN）是固定的吗？"><a href="#①（ISN）是固定的吗？" class="headerlink" title="①（ISN）是固定的吗？"></a>①（ISN）是固定的吗？</h3><ul><li>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</li><li>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</li></ul><h3 id="②什么是半连接队列？"><a href="#②什么是半连接队列？" class="headerlink" title="②什么是半连接队列？"></a>②什么是半连接队列？</h3><ul><li>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</li><li>补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</li></ul><h3 id="③三次握手过程中可以携带数据吗？"><a href="#③三次握手过程中可以携带数据吗？" class="headerlink" title="③三次握手过程中可以携带数据吗？"></a>③三次握手过程中可以携带数据吗？</h3><ul><li><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，<strong>而第三次握手是可以携带数据的</strong>。</p></li><li><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p></li><li><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p></li></ul><h3 id="④为什么要三次握手呢？有人说两次握手就好了"><a href="#④为什么要三次握手呢？有人说两次握手就好了" class="headerlink" title="④为什么要三次握手呢？有人说两次握手就好了"></a>④为什么要三次握手呢？有人说两次握手就好了</h3><ul><li><p>举例：已失效的连接请求报文段。</p></li><li><p>客户端发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。</p></li></ul><h2 id="四次挥手过程详解"><a href="#四次挥手过程详解" class="headerlink" title="四次挥手过程详解"></a>四次挥手过程详解</h2><p><strong>第一次挥手：</strong></p><ul><li>TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态。</li><li>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ul><p><strong>第二次挥手</strong></p><ul><li>​ 服务端收到这个FIN，他发回一个<strong>ACK报文</strong> 确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。​ 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态。</li><li>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ul><p><strong>第三次挥手：</strong></p><ul><li>​ 服务端发送一个<strong>FIN(结束)</strong>到客户端，服务端关闭客户端的连接。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</li></ul><p><strong>第四次挥手：</strong></p><ul><li>​ 客户端发送<strong>ACK</strong> 报文确认，并将确认的序号+1，这样关闭完成。​ 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。此时TCP连接还没有释放，必须经过<code>2∗∗MSL</code>（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315131718947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h2><h3 id="①为什么是4次挥手呢？"><a href="#①为什么是4次挥手呢？" class="headerlink" title="①为什么是4次挥手呢？"></a>①为什么是4次挥手呢？</h3><ul><li>为了确保数据能够完成传输。关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><h3 id="②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？"><a href="#②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？" class="headerlink" title="②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？"></a>②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？</h3><ul><li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，<strong>“你发的FIN报文我收到了”</strong>。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul><h3 id="③客户端突然挂掉了怎么办？"><a href="#③客户端突然挂掉了怎么办？" class="headerlink" title="③客户端突然挂掉了怎么办？"></a>③客户端突然挂掉了怎么办？</h3><ul><li>正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现长时期的空闲。解决办法是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。</li></ul><h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><p><strong>背景：</strong></p><ul><li>初始化连接的 SYN 超时问题Client发送SYN包给Server后挂了，Server回给Client的SYN-ACK一直没收到Client的ACK确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让Server将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的SYN连接队列耗尽。</li></ul><p><strong>让正常的连接无法得到处理。</strong></p><ul><li>​ 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。</li></ul><p><strong>什么是 SYN 攻击？</strong></p><ul><li>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。</li></ul><p><strong>如何检测 SYN 攻击？</strong></p><ul><li>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的netstats 命令来检测 SYN 攻击。</li></ul><p><strong>如何防御 SYN 攻击？</strong></p><ul><li>​ SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：<br>①缩短超时（SYN Timeout）<br>②时间增加最大半连接数<br>③过滤网关防护SYN<br>④cookies技术</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/03/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一、HashMap的底层实现原理</title>
      <link>http://yoursite.com/2020/03/14/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <guid>http://yoursite.com/2020/03/14/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Sat, 14 Mar 2020 12:05:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;HeshMap是基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。在面试中也经常出现这道考题，记录一下！&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>HeshMap是基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。在面试中也经常出现这道考题，记录一下！</p><a id="more"></a><h1 id="HsahMap的实现原理"><a href="#HsahMap的实现原理" class="headerlink" title="HsahMap的实现原理"></a>HsahMap的实现原理</h1><h2 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h2><ul><li>HashMap 基于 Hash 算法实现的，底层是由数组+链表/红黑树构成的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表，否则使用红黑树。</li></ul><h2 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h2><ul><li>HashMap通过<strong>键值对</strong>实现存取。</li><li><code>put（）</code>方法：对key做null检查。如果key是null，会被存储到table[0]，因为null的hash值总是0。 key的hashcode()方法会被调用，然后计算hash值。hash值用来找到存储Entry对象的数组的索引。有时候hash函数可能写的很不好，所以JDK的设计者添加了另一个叫做hash()的方法，它接收刚才计算的hash值作为参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; p; </span><br><span class="line">   <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>Get（）</code>：对key进行null检查。如果key是null，table[0]这个位置的元素将被返回。<br>key的hashcode()方法被调用，然后计算hash值。indexFor(hash,table.length)用来计算要获取的Entry对象在table数组中的精确的位置，使用刚才计算的hash值。在获取了table数组的索引之后，会迭代链表，调用equals()方法检查key的相等性，如果equals()方法返回true，get方法返回Entry对象的value，否则，返回null。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="built_in">return</span> (e = getNode(<span class="built_in">hash</span>(key), key)) == null ? null : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Implements Map.get and related methods.</span><br><span class="line">    *</span><br><span class="line">    * @param <span class="built_in">hash</span> <span class="built_in">hash</span> <span class="keyword">for</span> key</span><br><span class="line">    * @param key the key</span><br><span class="line">    * @<span class="built_in">return</span> the node, or null <span class="keyword">if</span> none</span><br><span class="line">    */</span><br><span class="line">   final Node&lt;K,V&gt; getNode(int <span class="built_in">hash</span>, Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">           (first = tab[(n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == <span class="built_in">hash</span> &amp;&amp; // always check first node</span><br><span class="line">               ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="built_in">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != null) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                   <span class="built_in">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(<span class="built_in">hash</span>, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="built_in">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>补充：</p><ol><li>HashMap有一个叫做Entry的内部类，它用来存储key-value对。</li><li>上面的Entry对象是存储在一个叫做table的Entry数组中。</li><li>table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。</li><li>key的hashcode()方法用来找到Entry对象所在的桶。</li><li>如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。</li><li>key的equals()方法用来确保key的唯一性。</li></ol><h1 id="有关知识的具体解析"><a href="#有关知识的具体解析" class="headerlink" title="有关知识的具体解析"></a>有关知识的具体解析</h1><h2 id="一、Map的几种类型"><a href="#一、Map的几种类型" class="headerlink" title="一、Map的几种类型"></a>一、Map的几种类型</h2><p><img src="https://img-blog.csdnimg.cn/20200314144530842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Map就是一个值key对应一个value。</li><li>Hashtable（线程安全）和HashMap（非线程安全）在代码实现上，基本上是一样的。现在Hashtable已经过时了(小写的t，因为sun当时的一个失误，因为是JDK1.0的产物，所以不方便改)。</li><li>ConcurrentHashMap也是线程安全的，但性能比HashTable好很多，Hashtable是锁整个Map对象，而ConcurrentHashMap是锁Map的部分结构。</li></ul><h2 id="二、什么是哈希表？"><a href="#二、什么是哈希表？" class="headerlink" title="二、什么是哈希表？"></a>二、什么是哈希表？</h2><ul><li>利用<strong>数组</strong>寻址容易，但插入和删除困难。而<strong>链表</strong>是：寻址困难，插入和删除容易。而<strong>哈希表</strong>便综合两者的特性，是一种寻址容易，插入删除也容易的数据结构。</li><li>哈希表有多种不同的实现方法，最常用的方法—— 拉链法，可以理解为“链表的数组”<br><img src="https://img-blog.csdnimg.cn/20200314161134205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>一个长度为16的数组中，每个元素存储的是一个链表的头结点。这些元素是按照什么样的规则存储到数组中呢？一般情况是通过<code>hash(key)%len</code>获得，也就是元素的key的哈希值对数组长度取模得到。</li><li>比如上述哈希表中12%16=12 , 28%16=12 , 108%16=12 , 140%16=12。所以12、28、108，140都存储在数组下标为12的位置。</li><li><strong>HashMap其实也是一个线性数组（<code>Entry[]</code>）实现的,所以可以理解为其存储数据的容器就是一个线性数组。但是一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap是做了一些处理的。</strong></li></ul><h2 id="三、什么是哈希算法？"><a href="#三、什么是哈希算法？" class="headerlink" title="三、什么是哈希算法？"></a>三、什么是哈希算法？</h2><ul><li>Hash算法虽然被称为算法，但实际上它更像是一种思想。Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法。</li><li>哈希（hash）算法又称为散列算法，通过hash算法，可以将任意长度的信息转换成一个固定长度的二进制数据，我们经常会使用十六进制值来表示转换后的信息。</li><li>比如，数字123，使用md5的hash算法后，得到十六进制的值：202cb962ac59075b964b07152d234b70</li><li>哈希算法的特点：<br>（1）不同的信息，理论上得到的hash值不同，我们称之为“无碰撞”，或者发生“碰撞”的概率非常小。<br>（2）不可逆，hash算法是单向的，从hash值反向推导出原始信息是很困难的。所以，有些系统中，我们可以使用hash算法对密码进行处理后保存。</li><li>哈希算法的应用<br>①</li></ul><h2 id="四、什么是红黑树？"><a href="#四、什么是红黑树？" class="headerlink" title="四、什么是红黑树？"></a>四、什么是红黑树？</h2><ul><li><strong>二叉树（BST）</strong>：<br>①左子树结点的值小于等于根节点的值。<br>②右子树结点的值大于等于根节点的值。<br>③左右子树分开来也是单独的二叉树。<br><img src="https://img-blog.csdnimg.cn/20200314174010980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul><li><strong>红黑树（RBT）</strong>：红黑树是一种自平衡的二叉树，除了符合二叉树的基本特征之外还引入了一些附加的条件。<br>①节点是红色或黑色。<br>②根节点是黑色。<br>③每个叶子节点都是黑色的空节点（NIL节点）。<br>④每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。<br>⑥从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br><img src="https://img-blog.csdnimg.cn/20200314174041551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="五、HashMap-和-Hashtable-有什么区别？"><a href="#五、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="五、HashMap 和 Hashtable 有什么区别？"></a>五、HashMap 和 Hashtable 有什么区别？</h2><ul><li>HashMap是非线程安全的，HashMap是Map的一个实现类，是将键映射到值的对象，不允许键值重复。允许空键和空值；由于非线程安全，HashMap的效率要较 Hashtable 的效率高一些。</li><li>Hashtable 是线程安全的一个集合，不允许 null 值作为一个 key 值或者value 值。             </li><li>Hashtable是sychronized，多个线程访问时不需要自己为它的方法实现同步，而HashMap 在被多个线程访问的时候需要自己为它的方法实现同步。</li><li>一般现在不建议用Hashtable：<br>①注意是小写的t，这是sun公司的一个失误，但是由于是JDK1.0的产物，所以没有改<br>②是Hashtable是遗留类，内部实现很多没优化和冗余。<br>③即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li></ul><h1 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h1><h2 id="产生hash冲突的原因"><a href="#产生hash冲突的原因" class="headerlink" title="产生hash冲突的原因"></a>产生hash冲突的原因</h2><ul><li>当我们通过put(key, value)向hashmap中添加元素时，需要通过hash函数确定元素究竟应该放置在数组中的哪个位置，因为不同的元素可能通过hashcode（）计算得到的哈希值相同，那么不同的元素被放置在了数据的同一个位置时，后放入的元素会以链表的形式，插在前一个元素的尾部，这个时候我们称发生了hash冲突。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>事实上，想让hash冲突完全不发生，是不太可能的，我们能做的只是尽可能的降低hash冲突发生的概率。<br>①开放定址法<br>②链地址法（拉链法）<br>Java 中 HashMap 解决 Hash 冲突就是利用了这个方法，具体实现这里暂时不做详解，可以参考 Jdk HashMap 源码进行理解。<br>③再哈希法<br>④建立公共溢出区</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/03/14/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JSP&amp;EL&amp;JSTL</title>
      <link>http://yoursite.com/2020/02/11/JSP-EL-JSTL/</link>
      <guid>http://yoursite.com/2020/02/11/JSP-EL-JSTL/</guid>
      <pubDate>Tue, 11 Feb 2020 05:01:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;JSP，EL表达式，JSTL介绍&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>JSP，EL表达式，JSTL介绍</p><a id="more"></a><h1 id="一、JSP"><a href="#一、JSP" class="headerlink" title="一、JSP"></a>一、JSP</h1><h2 id="什么是jsp？"><a href="#什么是jsp？" class="headerlink" title="什么是jsp？"></a>什么是jsp？</h2><p><strong>Java Server Page</strong>  从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p><h2 id="为什么会有jsp"><a href="#为什么会有jsp" class="headerlink" title="为什么会有jsp?"></a>为什么会有jsp?</h2><p>为了有更好的用户体检，更好的交互效果。因为html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， <strong>jsp里面可以写java代码。</strong> </p><h2 id="jsp怎么用？"><a href="#jsp怎么用？" class="headerlink" title="jsp怎么用？"></a>jsp怎么用？</h2><h3 id="一、jsp指令"><a href="#一、jsp指令" class="headerlink" title="一、jsp指令"></a>一、jsp指令</h3><p><strong>一、page指令</strong></p><p><img src="https://img-blog.csdnimg.cn/20200229121757727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">指令写法：</span><br><span class="line">&lt;%@ 指令名字 %&gt;</span><br><span class="line"></span><br><span class="line">page指令：</span><br><span class="line">1. language：表明jsp页面中可以写java代码</span><br><span class="line"></span><br><span class="line">2. contentType：其实就是说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</span><br><span class="line">contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">text/html  MIMEType 这是一个文本，html网页</span><br><span class="line"></span><br><span class="line">3. pageEncoding：jsp内容编码</span><br><span class="line"></span><br><span class="line">4. extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</span><br><span class="line"></span><br><span class="line">5. import 导包使用的，一般不用手写。</span><br><span class="line"></span><br><span class="line">6. session </span><br><span class="line"> - 值可选的有<span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line"> - 用于控制在这个jsp页面里面，能够直接使用session对象。</span><br><span class="line"> - 具体的区别是，请看翻译后的java文件：</span><br><span class="line">如果该值是<span class="literal">true</span> , 那么在代码里面会有getSession（）的调用，</span><br><span class="line">如果是<span class="literal">false</span> :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</span><br><span class="line"></span><br><span class="line">7. errorPage： 指的是错误的页面， 值需要给错误的页面路径</span><br><span class="line"></span><br><span class="line">8. isErrorPage：上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</span><br></pre></td></tr></table></figure><p><strong>二、include指令</strong></p><ul><li>包含另外一个jsp的内容进来。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"other02.jsp"</span>%&gt;</span><br></pre></td></tr></table></figure><ul><li>背后细节:<br>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</li></ul><p><strong>三、taglib</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">""</span>  uri=<span class="string">""</span>%&gt;  </span><br><span class="line">uri: 标签库路径</span><br><span class="line">prefix : 标签库的别名</span><br></pre></td></tr></table></figure><h3 id="二、jsp动作标签（写在body里面）"><a href="#二、jsp动作标签（写在body里面）" class="headerlink" title="二、jsp动作标签（写在body里面）"></a>二、jsp动作标签（写在body里面）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">""</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">""</span> name=<span class="string">""</span>/&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- jsp:include</span><br><span class="line">&lt;jsp:include page=<span class="string">"other02.jsp"</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 </span><br><span class="line"></span><br><span class="line">- jsp:forward</span><br><span class="line">前往哪一个页面。</span><br><span class="line"> &lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br><span class="line">等同于：请求转发</span><br><span class="line">&lt;% request.getRequestDispatcher(<span class="string">"other02.jsp"</span>).forward(request,response);%&gt;</span><br><span class="line"></span><br><span class="line">- jsp:param</span><br><span class="line">第一步：在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</span><br><span class="line">&lt;jsp:forward page=<span class="string">"other02.jsp"</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">"beijing"</span> name=<span class="string">"address"</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line"></span><br><span class="line">第二步：在other02.jsp中获取这个参数</span><br><span class="line">&lt;br&gt;收到的参数是：&lt;br&gt;</span><br><span class="line">&lt;%= request.getParameter(<span class="string">"address"</span>)%&gt;</span><br></pre></td></tr></table></figure><h2 id="jsp内置对象（重点！）"><a href="#jsp内置对象（重点！）" class="headerlink" title="jsp内置对象（重点！）"></a>jsp内置对象（重点！）</h2><p> 所谓内置对象（有九个），就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p><h3 id="作用域对象"><a href="#作用域对象" class="headerlink" title="作用域对象"></a>作用域对象</h3><ul><li><strong>作用域对象有四个：</strong><ol><li><strong>pageContext</strong></li><li><strong>request</strong></li><li><strong>session</strong></li><li><strong>application</strong></li></ol></li></ul><ul><li><strong>作用域 ：</strong> 表示这些对象可以存值，他们的取值范围有限定。<br>用setAttribute   和  getAttribute来进行存取。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用作用域来存储数据&lt;br&gt;</span><br><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">取出四个作用域中的值&lt;br&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br></pre></td></tr></table></figure><ul><li>作用域范围大小：（由小到大）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageContext -- request --- session -- application</span><br></pre></td></tr></table></figure><ul><li>四个作用域的区别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11. pageContext 【PageContext】</span><br><span class="line">作用域仅限于当前的页面，还可以获取到其他八个内置对象。</span><br><span class="line"></span><br><span class="line">12. request 【HttpServletRequest】</span><br><span class="line">作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</span><br><span class="line"></span><br><span class="line">13. session 【HttpSession】</span><br><span class="line">作用域限于一次会话（多次请求与响应） 当中。 </span><br><span class="line"></span><br><span class="line">14. application 【ServletContext】</span><br><span class="line"> 整个工程都可以访问， 服务器关闭后就不能访问了。</span><br></pre></td></tr></table></figure><h3 id="其他内置对象"><a href="#其他内置对象" class="headerlink" title="其他内置对象"></a>其他内置对象</h3><ul><li>out                 【JspWriter】</li><li>response      【HttpServletResponse】<br><img src="https://img-blog.csdnimg.cn/20200229140948897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>exception  【Throwable】</li><li>page             【Object】 —就是这个jsp翻译成的java类的实例对象</li><li>config         【ServletConfig】</li></ul><h1 id="二、EL表达式"><a href="#二、EL表达式" class="headerlink" title="二、EL表达式"></a>二、EL表达式</h1><ul><li>是为了简化jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写法格式：</span><br><span class="line"><span class="variable">$&#123;表达式 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</li></ul><h3 id="EL取值方式"><a href="#EL取值方式" class="headerlink" title="EL取值方式"></a>EL取值方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. 取出4个作用域中存放的值</span><br><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">按普通手段取值：</span><br><span class="line">&lt;%= pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line"></span><br><span class="line">使用EL表达式取出作用域中的值：</span><br><span class="line"><span class="variable">$&#123; pageScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; requestScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; sessionScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; applicationScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. 如果域中所存的是数组</span><br><span class="line">   &lt;%String [] a = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>&#125;;</span><br><span class="line">   pageContext.setAttribute(<span class="string">"array"</span>, a); %&gt;</span><br><span class="line">   </span><br><span class="line">   使用EL表达式取出作用域中数组的值：</span><br><span class="line">   <span class="variable">$&#123;array[0] &#125;</span> , <span class="variable">$&#123;array[1] &#125;</span>,<span class="variable">$&#123;array[2] &#125;</span>,<span class="variable">$&#123;array[3] &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 如果域中存的是集合</span><br><span class="line">使用EL表达式取出作用域中集合的值：</span><br><span class="line"><span class="variable">$&#123;li[0] &#125;</span> , <span class="variable">$&#123;li[1] &#125;</span>,<span class="variable">$&#123;li[2] &#125;</span>,<span class="variable">$&#123;li[3] &#125;</span></span><br><span class="line"></span><br><span class="line">4. 取出Map集合的值</span><br><span class="line">&lt;br&gt;-------------Map数据----------------&lt;br&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">   Map map = new HashMap();</span><br><span class="line">   map.put(<span class="string">"name"</span>, <span class="string">"zhangsna"</span>);</span><br><span class="line">   map.put(<span class="string">"age"</span>,18);</span><br><span class="line">   map.put(<span class="string">"address"</span>,<span class="string">"北京.."</span>);</span><br><span class="line">   map.put(<span class="string">"address.aa"</span>,<span class="string">"深圳.."</span>);</span><br><span class="line">   pageContext.setAttribute(<span class="string">"map"</span>, map);</span><br><span class="line">   %&gt;</span><br><span class="line">   </span><br><span class="line">   使用EL表达式取出作用域中Map的值：</span><br><span class="line">   <span class="variable">$&#123;map.name &#125;</span> , <span class="variable">$&#123;map.age &#125;</span> , <span class="variable">$&#123;map.address &#125;</span>  , <span class="variable">$&#123;map["address.aa"] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="取值细节"><a href="#取值细节" class="headerlink" title="取值细节"></a>取值细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  从域中取值。  得先存值。</span><br><span class="line"></span><br><span class="line">  &lt;%  //pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">      session.setAttribute(<span class="string">"name"</span>, <span class="string">"lisi..."</span>);  %&gt;</span><br><span class="line">  </span><br><span class="line">   直接指定说了，到这个作用域里面去找这个name</span><br><span class="line">   <span class="variable">$&#123; pageScope.name &#125;</span> </span><br><span class="line"></span><br><span class="line">   //先从page里面找，没有去request找，去session，去application </span><br><span class="line">   <span class="variable">$&#123; name &#125;</span></span><br><span class="line"></span><br><span class="line">   指定从session中取值</span><br><span class="line">   <span class="variable">$&#123; sessionScope.name &#125;</span>  </span><br><span class="line"></span><br><span class="line">2. 取值方式</span><br><span class="line"></span><br><span class="line">- 如果这份值是有下标的，那么直接使用[]</span><br><span class="line">&lt;%String [] array = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;</span><br><span class="line">session.setAttribute(<span class="string">"array"</span>,array);  %&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123; array[1] &#125;</span> --&gt; 这里array说的是attribute的name </span><br><span class="line"></span><br><span class="line">- 如果没有下标， 直接使用 .的方式去取</span><br><span class="line">&lt;%User user = new User(<span class="string">"zhangsan"</span>,18);</span><br><span class="line">session.setAttribute(<span class="string">"u"</span>, user);  %&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123; u.name &#125;</span>  , <span class="variable">$&#123; u.age &#125;</span> </span><br><span class="line"></span><br><span class="line">3. 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。</span><br></pre></td></tr></table></figure><h3 id="EL表达式-的11个内置（隐式）对象"><a href="#EL表达式-的11个内置（隐式）对象" class="headerlink" title="EL表达式 的11个内置（隐式）对象"></a>EL表达式 的11个内置（隐式）对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">内置对象：已经存在，不用创建，可以直接获取成员变量或者属性</span><br><span class="line">用法：<span class="variable">$&#123; 对象名.成员 &#125;</span></span><br><span class="line"></span><br><span class="line">JSP相关对象</span><br><span class="line">- pageContext </span><br><span class="line"></span><br><span class="line">作用域相关对象（用的比较多）</span><br><span class="line">- pageScope</span><br><span class="line">- requestScope</span><br><span class="line">- sessionScope</span><br><span class="line">- applicationScope</span><br><span class="line"></span><br><span class="line">请求头信息相关对象</span><br><span class="line">- header</span><br><span class="line">- headerValues</span><br><span class="line"></span><br><span class="line">请求参数信息相关对象</span><br><span class="line">- param</span><br><span class="line">- paramValues</span><br><span class="line"></span><br><span class="line">Cookie</span><br><span class="line">- cookie</span><br><span class="line"></span><br><span class="line">全局初始化参数</span><br><span class="line">- initParam</span><br></pre></td></tr></table></figure><h1 id="三、-JSTL（标准标签库）"><a href="#三、-JSTL（标准标签库）" class="headerlink" title="三、 JSTL（标准标签库）"></a>三、 JSTL（标准标签库）</h1><ul><li>全称 ： JSP Standard Tag Library  ： jsp标准标签库</li><li>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</li></ul><h2 id="JSTL使用"><a href="#JSTL使用" class="headerlink" title="JSTL使用"></a>JSTL使用</h2><ol><li>导入jar文件到工程的WebContent/Web-Inf/lib    jstl.jar和standard.jar</li><li>在jsp页面上，使用taglib 指令，来引入标签库</li><li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br></pre></td></tr></table></figure><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="built_in">set</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">""</span>&gt;&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:forEach&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. c:<span class="built_in">set</span></span><br><span class="line">&lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt;</span><br><span class="line">&lt;c:<span class="built_in">set</span> var=<span class="string">"name"</span> value=<span class="string">"zhangsan"</span> scope=<span class="string">"session"</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;sessionScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. c:<span class="keyword">if</span></span><br><span class="line"> 判断<span class="built_in">test</span>里面的表达式是否满足，如果满足，就执行c:<span class="keyword">if</span>标签中的输出 ， c:<span class="keyword">if</span> 是没有<span class="keyword">else</span>的。 </span><br><span class="line">&lt;c:<span class="built_in">set</span> var=<span class="string">"age"</span> value=<span class="string">"18"</span> &gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span>&gt;</span><br><span class="line">年龄大于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &lt;= 26 &#125;</span>"</span>&gt;</span><br><span class="line">年龄小于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">定义一个变量名 flag  去接收前面表达式的值，然后存在session域中</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span> var=<span class="string">"flag"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">年龄大于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. c:forEach</span><br><span class="line">从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， </span><br><span class="line">&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"10"</span> var=<span class="string">"i"</span> step=<span class="string">"2"</span>&gt;</span><br><span class="line"><span class="variable">$&#123;i &#125;</span></span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 </span><br><span class="line">var: 遍历出来的每一个元素用user 去接收。 --&gt;</span><br><span class="line">&lt;c:forEach var=<span class="string">"user"</span> items=<span class="string">"<span class="variable">$&#123;list &#125;</span>"</span>&gt;</span><br><span class="line"><span class="variable">$&#123;user.name &#125;</span> ----<span class="variable">$&#123;user.age &#125;</span></span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/JSP-EL-JSTL/#disqus_thread</comments>
    </item>
    
    <item>
      <title>区块链的架构模型以及核心技术</title>
      <link>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link>
      <guid>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;-&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>-</p><a id="more"></a><h2 id="一-架构模型"><a href="#一-架构模型" class="headerlink" title="一.架构模型"></a>一.架构模型</h2><p>一般说来，区块链系统由数据层、网络层、共识层、激励层、合约层，应用层组成。</p><ol><li><strong>数据层：</strong> 封装了底层数据区块以及相关的数据加密和时间戳等基础数据和基本算法。</li><li><strong>网络层：</strong> 则包括分布式组网机制、数据传播机制和数据验证机制等。</li><li><strong>共识层：</strong> 主要封装网络节点的各类共识算法。</li><li><strong>激励层：</strong> 将经济因素集成到区块链技术体系中来，主要包括经济激励的发行机制和分配机制等。</li><li><strong>合约层：</strong> 主要封装各类脚本、算法和智能合约，是区块链可编程特性的基础。</li><li><strong>应用层：</strong> 则封装了区块链的各种应用场景和案例。</li></ol><p><strong>区块链技术最具代表性的创新点：</strong></p><ol><li>基于时间戳的链式区块结构、分布式节点的共识机制。</li><li>基于共识算力的经济激励和灵活可编程的智能合约。</li></ol><h2 id="二-核心技术"><a href="#二-核心技术" class="headerlink" title="二.核心技术"></a>二.核心技术</h2><p> 1.<strong>分布式账本：</strong>分布式账本指的是交易记账由分布在不同地方的多个节点共同完成，而且每一个节点记录的是完整的账目，因此它们都可以参与监督交易合法性，同时也可以共同为其作证 。跟传统的分布式存储有所不同，区块链的分布式存储的独特性主要体现在两个方面：一是区块链每个节点都按照块链式结构存储完整的数据，传统分布式存储一般是将数据按照一定的规则分成多份进行存储。二是区块链每个节点存储都是独立的、地位等同的，依靠共识机制保证存储的一致性，而传统分布式存储一般是通过中心节点往其他备份节点同步数据。没有任何一个节点可以单独记录账本数据，从而避免了单一记账人被控制或者被贿赂而记假账的可能性。也由记账节点足够多，理论上讲除非所有的节点被破坏，否则账目就不会丢失，从而保证了账目数据的安全性。</p><p>2.<strong>非对称加密：</strong>存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的，只有在数据拥有者授权的情况下才能访问到，从而保证了数据的安全和个人的隐私。<br>3.<strong>共识机制</strong>就是所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡 。<br>区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。“人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。<br>4.<strong>智能合约：</strong>基于这些可信的不可篡改的数据，可以自动化的执行一些预先定义好的规则和条款。以保险为例，如果说每个人的信息（包括医疗信息和风险发生的信息）都是真实可信的，那就很容易的在一些标准化的保险产品中，去进行自动化的理赔。在保险公司的日常业务中，虽然交易不像银行和证券行业那样频繁，但是对可信数据的依赖是有增无减。因此，笔者认为利用区块链技术，从数据管理的角度切入，能够有效地帮助保险公司提高风险管理能力。具体来讲主要分投保人风险管理和保险公司的风险监督。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>区块链技术的应用领域</title>
      <link>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/</link>
      <guid>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;-&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>-</p><a id="more"></a><h2 id="金融领域"><a href="#金融领域" class="headerlink" title="金融领域"></a>金融领域</h2><p>区块链在<strong>国际汇兑</strong>、<strong>信用证</strong>、<strong>股权登记</strong>和<strong>证券交易所</strong>等金融领域有着潜在的巨大应用价值。将区块链技术应用在金融行业中，能够省去第三方中介环节，实现<strong>点对点</strong>的直接对接，从而在大大降低成本的同时，快速完成交易支付。<br>比如Visa推出基于区块链技术的 Visa B2B Connect，它能为机构提供一种费用更低、更快速和安全的跨境支付方式来处理全球范围的企业对企业的交易。要知道传统的跨境支付需要等3-5天，并为此支付1-3%的交易费用。Visa 还联合 Coinbase 推出了首张比特币借记卡，<strong>花旗银行</strong>则在区块链上测试运行加密货币“<strong>花旗币</strong>”。</p><h2 id="物联网和物流领域"><a href="#物联网和物流领域" class="headerlink" title="物联网和物流领域"></a>物联网和物流领域</h2><p>区块链在物联网和物流领域也可以天然结合。通过区块链可以降低物流成本，追溯物品的生产和运送过程，并且提高供应链管理的效率。该领域被认为是区块链一个很有前景的应用方向。<br>区块链通过结点连接的散状网络分层结构，能够在整个网络中实现信息的全面传递，并能够检验信息的准确程度。这种特性一 定程度上提高了物联网交易的便利性和智能化。<strong>区块链</strong>+<strong>大数据</strong>的解决方案就利用了大数据的自动筛选过滤模式，在区块链中建立信用资源，可双重提高交易的安全性，并提高物联网交易便利程度。为智能物流模式应用节约时间成本。区块链结点具有十分自由的进出能力，可独立的参与或离开区块链体系，不对整个区块链体系有任何干扰。区块链 +大数据解决方案就利用了大数据的整合能力，促使物联网基础用户拓展更具有方向性，便于在智能物流的分散用户之间实现用户拓展。</p><h2 id="公共服务领域"><a href="#公共服务领域" class="headerlink" title="公共服务领域"></a>公共服务领域</h2><p>区块链在公共管理、能源、交通等领域都与民众的生产生活息息相关，但是这些领域的中心化特质也带来了一些问题，可以用区块链来改造。区块链提供的去中心化的完全分布式DNS服务通过网络中各个节点之间的点对点数据传输服务就能实现域名的查询和解析，可用于确保某个重要的基础设施的操作系统和固件没有被篡改，可以监控软件的状态和完整性，发现不良的篡改，并确保使用了物联网技术的系统所传输的数据没用经过篡改。</p><h2 id="数字版权领域"><a href="#数字版权领域" class="headerlink" title="数字版权领域"></a>数字版权领域</h2><p>通过区块链技术，可以对作品进行鉴权，证明文字、视频、音频等作品的存在，保证权属的真实、唯一性。作品在区块链上被确权后，后续交易都会进行实时记录，实现数字版权全生命周期管理，也可作为司法取证中的技术性保障。例如，美国纽约一家创业公司Mine Labs开发了一个基于区块链的元数据协议，这个名为Mediachain的系统利用IPFS文件系统，实现数字作品版权保护，主要是面向数字图片的版权保护应用。</p><h2 id="保险领域"><a href="#保险领域" class="headerlink" title="保险领域"></a>保险领域</h2><p>在保险理赔方面，保险机构负责资金归集、投资、理赔，往往管理和运营成本较高。通过智能合约的应用，既无需投保人申请，也无需保险公司批准，只要触发理赔条件，实现保单自动理赔。一个典型的应用案例就是LenderBot, 是 2016 年由区块链企业 Stratumn、德勤与支付服务商 Lemonway 合作推出，它允许人们通过 Facebook Messenger 的聊天功能，注册定制化的微保险产品， 为个人之间交换的高价值物品进行投保，而区块链在贷款合同中代替了第三方角色 。</p><h2 id="公益领域"><a href="#公益领域" class="headerlink" title="公益领域"></a>公益领域</h2><p>区块链上存储的数据，高可靠且不可篡改，天然适合用在社会公益场景。公益流程中的相关信息，如捐赠项目、募集明细、资金流向、受助人反馈等，均可以存放于区块链上，并且有条件地进行透明公开公示，方便社会监督。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>数字货币的种类</title>
      <link>http://yoursite.com/2020/02/11/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E7%9A%84%E7%A7%8D%E7%B1%BB/</link>
      <guid>http://yoursite.com/2020/02/11/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E7%9A%84%E7%A7%8D%E7%B1%BB/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;当前的数字货币大致有以下几种。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>当前的数字货币大致有以下几种。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200204160645330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>BTC：</strong> 比特币</li><li><strong>ETH：</strong> 以太币</li><li><strong>USDT：</strong> 泰达币（与同数量的美元是等值的）</li><li><strong>EOS：</strong> 为商用分布式应用设计的一款区块链操作系统。EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0 。</li><li><strong>XRP：</strong> 瑞波币。它是基于Ripple协议的虚拟货币，主要功能有二：1.防止恶意攻击；2.桥梁货币。</li><li><strong>LTC：</strong> 莱特币。<img src="https://img-blog.csdnimg.cn/20200204161448813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>HT：</strong> 火币<br><img src="https://img-blog.csdnimg.cn/20200204161631662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>HUSD：</strong> 稳定币<img src="https://img-blog.csdnimg.cn/20200204162140418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>BCH：</strong><img src="https://img-blog.csdnimg.cn/20200204162243770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E7%9A%84%E7%A7%8D%E7%B1%BB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>比特币的两种交易方式</title>
      <link>http://yoursite.com/2020/02/11/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BA%A4%E6%98%93%E6%96%B9%E5%BC%8F/</link>
      <guid>http://yoursite.com/2020/02/11/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BA%A4%E6%98%93%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;比特币的交易有很多种，本文了解一下&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>比特币的交易有很多种，本文了解一下</p><a id="more"></a><h2 id="比特币交易的几种种方式："><a href="#比特币交易的几种种方式：" class="headerlink" title="比特币交易的几种种方式："></a>比特币交易的几种种方式：</h2><p><img src="https://img-blog.csdnimg.cn/20200204170527575.png" alt="在这里插入图片描述"></p><ol><li><strong>场外交易：</strong> 也称为<strong>法币交易</strong>，法币就是<strong>法定货币</strong>，人民币就是我们国家的法定货币，顾名思义，法币交易就是由法币（人民币）直接与比特币（数字货币）进行交易的行为（购买/出售),可以简单理解为网购。</li><li><strong>场内交易：</strong> 也称之为<strong>币币交易</strong>，就是用一种币交易兑换另一种币。</li><li><strong>杠杆交易：</strong> 利用小额的资金来进行数倍于原始金额的投资。以期望获取相对投资标的物波动的数倍收益率，抑或亏损。由于保证金（该笔小额资金）的增减不以标的资产的波动比例来运动，<strong>风险很高</strong>。不推荐。</li><li><strong>合约交易：</strong> 合约交易是指交易双方，在交易所通过买卖合约，并根据约定在未来某一特定时间和地点，以特定价格买卖规定数量商品的行为。合约交易是在现货远期合约交易基础上发展起来的，在交易所内买卖标准化合约的一种新型交易方式。</li></ol><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ol><li>法币交易很耗时间，即使交易双方操作熟练，但是还是不排除人为因素造成交易时间拖长，不利于双方观察局势，很有可能在分分钟内错过行情。</li><li>币币交易可以在极短时间内成交（按下买入键的瞬间与对手成交）且支持购买的币种更多。</li></ol><p>，</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BA%A4%E6%98%93%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>火币网--币币交易图解</title>
      <link>http://yoursite.com/2020/02/11/%E7%81%AB%E5%B8%81%E7%BD%91-%E5%B8%81%E5%B8%81%E4%BA%A4%E6%98%93%E5%9B%BE%E8%A7%A3/</link>
      <guid>http://yoursite.com/2020/02/11/%E7%81%AB%E5%B8%81%E7%BD%91-%E5%B8%81%E5%B8%81%E4%BA%A4%E6%98%93%E5%9B%BE%E8%A7%A3/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;如何在火币网上执行币币交易&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>如何在火币网上执行币币交易</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200205111557755.png" alt="在这里插入图片描述"></p><ul><li><p>BTC/USDT：BTC对USDT的交易对，相当于平均1个BTC当前需要9211.76个USDT来购买，后面的64574.43CNY是说9211.76个USDT约等于64574.43人民币。</p></li><li><p>涨幅+0.01%是今天此时此刻比特币的价格相对于昨天的这个时候价格涨了0.01%，如果是红色的-0.01%就代表跌了0.01%。</p></li><li><p>高9320.00 低9100.00是<strong>过去24小时</strong>最高9320.00USDT最低9100.00USDT。</p></li><li><p>24H量：是过去24小时火币网交易了28878个比特币。这只是在火币网交易的数量。<br><img src="https://img-blog.csdnimg.cn/2020020511252911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>上面一排时间是，选择显示这个时间段的数据，比如我选择的是1min，那么k线图中每一个红色或者绿色的柱就代表这一分钟内的走势。</p></li><li><p>时间下面的一排：11：24这个时间点的开盘价，最高价，最低价，收盘价，成交量。</p></li><li><p>MA均线：<strong>（MA）理论是股市最常见的一种技术分析方法，它对股市操作具有神奇的指导作用。</strong></p></li><li><p>绿色柱状：柱底代表开盘价，柱顶代表收盘价，红色则相反。</p></li><li><p>柱上下的细线：上影线，下影线，分别代表在这一分钟内的最高价和最低价。</p></li><li><p>图中标有今日最高，和今日最低。严谨理解为：从今日凌晨到目前为止的最高价与最低价。</p><h2 id="均线分析方法："><a href="#均线分析方法：" class="headerlink" title="均线分析方法："></a>均线分析方法：</h2></li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E7%81%AB%E5%B8%81%E7%BD%91-%E5%B8%81%E5%B8%81%E4%BA%A4%E6%98%93%E5%9B%BE%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>区块链简单理解</title>
      <link>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <guid>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;对近年来很火的区块链的简单了解&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>对近年来很火的区块链的简单了解</p><a id="more"></a><h2 id="区块链是什么："><a href="#区块链是什么：" class="headerlink" title="区块链是什么："></a>区块链是什么：</h2><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。区块链（Blockchain），是比特币的一个重要概念，它本质上是一个<strong>去中心化的数据库</strong>，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。</p><h2 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h2><p>区块链起源于比特币，2008年11月1日，一位自称<strong>中本聪</strong>(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》，阐述了<strong>基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念</strong>，这标志着比特币的诞生。两个月后理论步入实践，2009年1月3日第一个序号为0的创世区块诞生。几天后2009年1月9日出现序号为1的区块，并与序号为0的创世区块相连接形成了链，标志着区块链的诞生。<br>近年来，世界对比特币的态度起起落落，但作为比特币底层技术之一的区块链技术日益受到重视。在比特币形成过程中，区块是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过<strong>随机散列(也称哈希算法)</strong> 实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链 。</p><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul><li><strong>从科技层面来看：</strong> 区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。</li><li><strong>从应用视角来看：</strong> 区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。这些特点保证了区块链的 <strong>“诚实”</strong> 与 <strong>“透明”</strong> ，为区块链创造信任奠定基础。而区块链丰富的应用场景，基本上都基于区块链能够解决信息不对称问题，实现多个主体之间的协作信任与一致行动。</li></ul><h2 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h2><ol><li><strong><em>公有区块链</em></strong>（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上<strong>有且仅有一条</strong>该币种对应的区块链。</li><li><strong><em>行业区块链</em></strong>（Consortium Block Chains)：由某个群体<strong>内部指定</strong>多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易，但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。</li><li><strong><em>私有区块链</em></strong>（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。</li></ol><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ol><li>去中心化。区块链技术不依赖额外的第三方管理机构或硬件设施，没有中心管制，除了自成一体的区块链本身，通过分布式核算和存储，各个节点实现了信息自我验证、传递和管理。去中心化是区块链最突出最本质的特征。</li><li>开放性。区块链技术基础是<strong>开源的</strong>，除了交易各方的私有信息被加密外，区块链的数据对所有人开放，任何人都可以通过公开的接口查询区块链数据和开发相关应用，因此整个系统信息高度透明。</li><li>独立性。基于协商一致的规范和协议(类似比特币采用的哈希算法等各种数学算法)，整个区块链系统不依赖其他第三方，所有节点能够在系统内自动安全地验证、交换数据，不需要任何人为的干预。</li><li>安全性。只要不能掌控全部数据节点的51%，就无法肆意操控修改网络数据，这使区块链本身变得相对安全，避免了主观人为的数据变更。</li><li>匿名性。除非有法律规范要求，单从技术上来讲，各区块节点的身份信息不需要公开或验证，信息传递可以<strong>匿名进行</strong>。</li></ol>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>股票基本术语</title>
      <link>http://yoursite.com/2020/02/11/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/</link>
      <guid>http://yoursite.com/2020/02/11/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/</guid>
      <pubDate>Tue, 11 Feb 2020 02:19:20 GMT</pubDate>
      <description>
      
        &lt;p&gt;股票基本术语了解。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>股票基本术语了解。</p><a id="more"></a><h1 id="A-B-H-蓝筹股-amp-债券-amp-基金"><a href="#A-B-H-蓝筹股-amp-债券-amp-基金" class="headerlink" title="A/B/H/蓝筹股&amp;债券&amp;基金"></a>A/B/H/蓝筹股&amp;债券&amp;基金</h1><ul><li><strong>A股：</strong> 人民币普通股票，由我国境内的公司发行，供境内机构、组织、或个人(不含台、港、澳投资者)以人民币认购和交易的普通股票。</li><li><strong>B股：</strong> 人民币特种股票，以人民币标明面值，<strong>以外币认购和买卖</strong>，在境内(上海、深圳)证券交易所上市交易的。B股公司的注册地和上市地都在境内。</li><li><strong>H股：</strong> 港股：即注册地在内地、上市地在香港的<strong>外资股。</strong> 在香港上市外资股就叫做H股，纽约和新加坡上市的股票分别叫做N股和S股。</li><li><strong>蓝筹股：</strong> 多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码（蓝，红，白）、其中蓝色筹码最为值钱。</li><li><strong>债券：</strong> 政府、企业、银行等债务人为筹集资金,按照法定程序发行并向债权人承诺于指定日期还本付息的有价证券。</li><li><strong>开放式基金：</strong>（Open-end Funds）又称共同基金,是指基金发起人在设立基金时，基金单位或者股份总规模不固定，可视投资者的需求，随时向投资者出售基金单位或者股份，并可以应投资者的要求赎回发行在外的基金单位或者股份的一种基金运作方式。投资者既可以通过基金销售机构买基金使得基金资产和规模由此相应的增加，也可以将所持有的基金份额卖给基金并收回现金使得基金资产和规模相应的减少。</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><p><strong>原始股：</strong> 是公司在上市之前发行的股票。在中国股市初期，在股票一级市场上以发行价向社会公开发行的企业股票。</p></li><li><p><strong>概念股：</strong> 是指具有某种特别内涵的股票，与业绩股相对而言的。业绩股需要有良好的业绩支撑。而概念股是依靠某一种题材比如资产重组概念，三通概念等支撑价格。而这一内涵通常会被当作一种选股和炒作题材，成为股市的热点。概念股是股市术语，作为一种选股的方式。相较于绩优股必须有良好的营运业绩所支撑，概念股只是以依靠相同话题，将同类型的股票列入选股标的的一种组合。由于概念股的广告效应，因此不具有任何获利的保证。</p></li><li><p><strong>权重股：</strong>（weighted stock）就是总股本巨大的上市公司股票，它的股票总数占股票市场股票总数的比重很大，权重就很大，权重股的涨跌对股票指数的影响很大。</p></li><li><p><strong>借壳上市：</strong> 是指一家私人公司（Private Company）通过把资产注入一家市值较低的已上市公司（壳，Shell），得到该公司一定程度的控股权，利用其上市公司地位，使母公司的资产得以上市。通常该壳公司会被改名。</p></li><li><p><strong>交易时间：</strong> 大多数股票的交易时间是四小时，分两个时段：周一至周五上午9：30-11：30和下午13：00至15：00</p></li><li><p><strong>交易费用：</strong> 股票的交易费用通常包括印花税，佣金，过户费，其他费用等。</p></li><li><p><strong>总市值:</strong> 是指在某特定时间内总股本数乘以当时股价得出的股票总价值。</p></li><li><p><strong>流通市值:</strong> 在某特定时间内当时可交易的流通股股数乘以当时股价得出的流通股票总价值。</p></li><li><p><strong>总股本：</strong> 包括新股发行前的股份和新发行的股份的数量的总和。</p></li><li><p><strong>市盈率：</strong> 由股价除以年度每股盈余(EPS)得出(以公司市值除以年度股东应占溢利亦可得出相同结果)。用来<strong>评估股价水平是否合理</strong>的指标之一。</p></li><li><p><strong>市净率：</strong> 每股股价与每股净资产的比率。市净率可用于<strong>投资分析</strong>，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低。</p></li><li><p><strong>基准日：</strong> 就是因股票分红或配股，而进行股价调整的那天。相应的，在这天，红利和红股会配到投资者帐号里。而在基准日前，还有股权登记日。在股权登记日前买入该股票的投资者，享有分红或配股的权利。红利和红股会在基准日打到帐号里。</p></li><li><p><strong>大盘：</strong> 指沪市的“上证综合指数”和深市的“深证成份股指数”的股票。大盘指数是运用统计学中的指数方法编制而成的，反映股市<strong>总体价格</strong>或<strong>某类股价</strong>变动和走势的指标。</p></li><li><p><strong>个股：</strong> 是一种无偿还期限的有价证券，按股票持有者可分为国家股、法人股、个人股三种。个人股（individual stock）投资资金来自个人，可以自由上市流通。</p></li><li><p><strong>涨跌幅</strong>=(现价-上一个交易日收盘价）/上一个交易日收盘价*100%</p></li><li><p><strong>委差</strong> = 委买手数－委卖手数。</p></li><li><p><strong>委比</strong> = (委买手数-委卖手数)/(委买手数+委卖手数)×100%</p></li><li><p><strong>换手率：</strong> 也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。成交量/股票总流通量×100%</p></li><li><p><strong>成交额：</strong> 某只股票在一定时间内成交的股票总金额。</p></li><li><p><strong>平均成交量：</strong> 每笔交易的平均成交量，成交量/成交笔数。</p></li><li><p><strong>成交量：</strong> 包括某只股票 当天的成交股数、成交金额、换手率；狭义的也是最常用的是仅指成交股数/手数(1手=100股)；通常人们说的大盘成交量指的是成交金额。</p></li><li><p><strong>仓位：</strong> 是指投资者买入股票所耗资金占资金总量的比例。当一个投资者的所有资金都已买入股票时就称为<strong>满仓</strong>，若不持有任何股票就称为<strong>空仓</strong>。</p></li></ul><h1 id="股票操作术语"><a href="#股票操作术语" class="headerlink" title="股票操作术语"></a>股票操作术语</h1><h2 id="内盘-amp-外盘"><a href="#内盘-amp-外盘" class="headerlink" title="内盘&amp;外盘"></a>内盘&amp;外盘</h2><ul><li>内盘（S）：以买入价成交的交易，成交数量统计后加入内盘。</li><li>外盘（B）：以卖出价成交的交易。成交数量统计后加入外盘。</li><li>内盘，外盘这两个数据大体可以<strong>用来判断买卖力量的强弱</strong>。若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。</li></ul><h2 id="洗盘-amp-盯盘"><a href="#洗盘-amp-盯盘" class="headerlink" title="洗盘&amp;盯盘"></a>洗盘&amp;盯盘</h2><ul><li>洗盘：投机者先把股价大幅度杀低，使大批小额股票投资者(<strong>散户</strong>)产生恐慌而抛售股票，然后再把股价抬高，以便乘机渔利。</li><li>盯盘：俗称看盘，是股票投资者主要的日常工作。股票市场每时每刻都在变化，股票投资者尤其是短期投资者要掌握股票市场的动向，就要观察分析股市行情的变化，即要学会盯盘。</li></ul><h2 id="做多-amp-做空"><a href="#做多-amp-做空" class="headerlink" title="做多&amp;做空"></a>做多&amp;做空</h2><ul><li><strong>做多：</strong> 指的是多仓，也可以叫利多，买入某种货币，看涨。</li><li><strong>做空：</strong> 指的是卖仓，也可以叫利空，卖出某种货币，看跌。</li></ul><h2 id="多头-amp-空头"><a href="#多头-amp-空头" class="headerlink" title="多头&amp;空头"></a>多头&amp;空头</h2><ul><li><strong>多头：</strong> 指投资者对股市看好，预计股价将会看涨，于是趁低价时买进股票，待股票上涨至某一价位时再卖出，以获取差额收益。</li><li><strong>空头：</strong> 空头是投资者和股票商认为现时股价虽然较高，但对股市前景看坏，预计股价将会下跌，于是把借来的股票或者是原有持仓及时卖出（<strong>补空</strong>），待股价跌至某一价位时再买进，以获取差额收益。</li></ul><h2 id="涨停-amp-跌停"><a href="#涨停-amp-跌停" class="headerlink" title="涨停&amp;跌停"></a>涨停&amp;跌停</h2><ul><li>涨跌停板：是证券管理部门为了<strong>防止过度的投机</strong>而采取的一种措施，是指一只个股每天的最大涨跌幅度不能超过前一交易日的百分比。普通的股票最大涨跌幅为前一交易日的10%。<strong>新股上市首日不设涨跌幅限制</strong>。</li></ul><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p> 熔断机制（Circuit Breaker），也叫自动停盘机制，是指当股指波幅达到某设定条件（熔断点）时，交易所为控制风险采取的暂停交易措施，<strong>不同于涨跌停板</strong>；例如，新股上市首日的规定：</p><ul><li>深交所：新股首日盘中成交价较开盘价首次上涨或下跌达到或超过10%即暂停交易，新股首日换手率超50%触发暂停交易。</li><li>上交所：新股首日盘中成交价较开盘价首次上涨或下跌达到10%暂停交易30分钟。达到20%，停牌到14时55分，首日换手率超80%触发暂停交易。</li></ul><h2 id="回档-amp-反弹"><a href="#回档-amp-反弹" class="headerlink" title="回档&amp;反弹"></a>回档&amp;反弹</h2><ul><li>回档：股价呈不断上涨趋势，终因股价上涨速度过快而反转回跌到某一价位，这一调整现象称为回档。一般来说，股票的回档幅度要比上涨幅度小，通常是反转回跌到前一次上涨幅度的三分之一左右时又恢复原来上涨趋势。</li><li>反弹：股价呈不断下跌趋势，终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。一般来说，股票的反弹幅度要比下跌幅度小，通常是反弹到前一次下跌幅度的三分之一左右时，又恢复原来的下跌趋势。</li></ul><h2 id="跳空-amp-补空"><a href="#跳空-amp-补空" class="headerlink" title="跳空&amp;补空"></a>跳空&amp;补空</h2><ul><li>跳空：指受强烈利多或利空消息刺激，股价开始大幅度跳动。跳空通常在股价大变动的开始或结束前出现。</li><li>补空：是空头买回以前卖出的股票的行为。</li></ul><h2 id="阻力线-amp-支撑线"><a href="#阻力线-amp-支撑线" class="headerlink" title="阻力线&amp;支撑线"></a>阻力线&amp;支撑线</h2><ul><li>阻力线：股市受利多信息的影响，股价上涨至某一价格时，做多头的认为有利可图，但实际却有大量卖出，使股价至此停止上升，甚至出现回跌。股市上一般将这种遇到阻力时的价位称为关卡，股价上升时的关卡称为阻力线。<strong>（大量卖出抑制了价格继续攀升）</strong></li><li>支撑线：股市受利空信息的影响，股价跌至某一价位时，做空头的认为有利可图，大量买进股票，使股价不再下跌，甚至出现回升趋势。股价下跌时的关卡称为支撑线。<strong>（大量买入支撑起股价，由跌转升）</strong></li></ul><h2 id="金叉-amp-死叉"><a href="#金叉-amp-死叉" class="headerlink" title="金叉&amp;死叉"></a>金叉&amp;死叉</h2><ul><li>黄金交叉：指短期移动平均线向上穿过中期移动平均线或短期、中期移动平均线同时向上穿过长期移动平均线的走势图形，表示股价将继续上升。</li><li>死亡交叉(死叉)：指下降中的短期移动平均线由上而下穿过下降的长期移动平均线，这个时候支撑线被向下跌破，表示股价将继续下落。<br><img src="https://img-blog.csdnimg.cn/20200206150617607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ul><li>在股票名称前冠以“ST”的股票表示该上市公司最近两年连续亏损，或亏损一年，但净资产跌破面值、公司经营过程中出现重大违法行为等情况之一，交易所对该公司股票交易进行特别处理。股票交易日涨跌幅限制5%。</li><li><strong>F10：</strong> 股票非行情类的基本面资料统称为股票F10。在各种金融行情终端软件中，用户通过键盘上的F10快捷键，可迅速查看上市公司的非行情信息，诸如：公司概况、财务数据、公司公告、公司新闻、经营分析等等信息数据。</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/11/%E8%82%A1%E7%A5%A8%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
