<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DBUtils学习笔记</title>
    <url>/2524199830/</url>
    <content><![CDATA[<p>DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。并且简化了增删改查的操作。</p>
<a id="more"></a>
<h1 id="使用开源的DBUtils"><a href="#使用开源的DBUtils" class="headerlink" title="使用开源的DBUtils"></a>使用开源的DBUtils</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。</li>
<li>简化了增删改查的操作。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>增删改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.导入jar包  commons-dbutils-1.4.jar</span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void testInsert() throws SQLException &#123;</span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		// dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围</span><br><span class="line">		QueryRunner queryRunner = new QueryRunner(dataSource);</span><br><span class="line">		// 增加</span><br><span class="line">		queryRunner.update(<span class="string">"insert into category values (null , ? , ? )"</span>, <span class="string">"a"</span>, 1000);</span><br><span class="line">		// 删除</span><br><span class="line">		queryRunner.update(<span class="string">"delete from account where id = ?"</span>, 5);</span><br><span class="line">		// 更新</span><br><span class="line">		queryRunner.update(<span class="string">"update account set money = ? where id = ?"</span>, 10000000, 6);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.直接new接口的匿名实现类</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">	Account  account =  queryRunner.query(<span class="string">"select * from account where id = ?"</span>, new ResultSetHandler&lt;Account&gt;()&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public Account handle(ResultSet rs) throws SQLException &#123;</span><br><span class="line">			Account account  =  new Account();</span><br><span class="line">			<span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">				String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">				int money = rs.getInt(<span class="string">"money"</span>);</span><br><span class="line">					</span><br><span class="line">				account.setName(name);</span><br><span class="line">				account.setMoney(money);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">return</span> account;</span><br><span class="line">		&#125; </span><br><span class="line">	 &#125;, 6);</span><br><span class="line">	System.out.println(account.toString());</span><br><span class="line"></span><br><span class="line">2. 直接使用框架已经写好的实现类。（最常用）</span><br><span class="line">	QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">	//查询单个对象</span><br><span class="line">Account account = queryRunner.query(<span class="string">"select * from account where id = ?"</span>, </span><br><span class="line">			new BeanHandler&lt;Account&gt;(Account.class), 8);</span><br><span class="line">	System.out.println(category.toString());</span><br><span class="line">	</span><br><span class="line">	* 查询多个对象</span><br><span class="line">List&lt;Category&gt; list = queryRunner.query(<span class="string">"select * from category"</span>, new BeanListHandler&lt;Category&gt;(Category.class));</span><br><span class="line">	<span class="keyword">for</span> (Category category : list) &#123;</span><br><span class="line">		System.out.println(category.toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ResultSetHandler-常用的实现类"><a href="#ResultSetHandler-常用的实现类" class="headerlink" title="ResultSetHandler 常用的实现类"></a>ResultSetHandler 常用的实现类</h1><ul>
<li>以下两个是使用频率最高的</li>
</ul>
<ol>
<li><p>BeanHandler          查询到的<strong>单个</strong>数据封装成一个对象</p>
</li>
<li><p>BeanListHandler    查询到的<strong>多个</strong>数据封装 成一个List&lt;对象&gt;</p>
</li>
<li><p>ArrayHandler,  查询到的单个数据封装成一个数组。</p>
</li>
<li><p>ArrayListHandler,  查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 </p>
</li>
<li><p>MapHandler,  查询到的单个数据封装成一个map</p>
</li>
<li><p>MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 </p>
</li>
<li><p>ColumnListHandler</p>
</li>
<li><p>KeyedHandler</p>
</li>
<li><p>ScalarHandler</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql,DBUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用学习</title>
    <url>/1657072496/</url>
    <content><![CDATA[<p>刚开始上手使用github的时候，真是一头雾水，不仅看不懂英文，而且也不懂如何使用，一番研究之后，基本了解了如何使用github的功能。</p>
<h1 id="一、使用Github"><a href="#一、使用Github" class="headerlink" title="一、使用Github"></a>一、使用Github</h1><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1  目的"></a>1.1  目的</h2><p> 借助Github托管项目代码</p>
<h2 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2  基本概念"></a>1.2  基本概念</h2><ul>
<li>仓库（Respository）</li>
<li>收藏（Star） </li>
<li>复制克隆项目（Fork）</li>
<li>发起请求（Pull Request）：等待作者查看，如果他觉得不错，他会合并到自己的仓库。</li>
<li>关注（Watch）：你关注的人或者项目有新动态，你会收到消息。</li>
<li>事物卡片（Issue）：向作者发送问题，并且可以一起讨论这个问题。</li>
</ul>
<h2 id="1-3-创建仓库"><a href="#1-3-创建仓库" class="headerlink" title="1.3  创建仓库"></a>1.3  创建仓库</h2><ul>
<li>创建账号，验证邮箱</li>
<li>创建一个test仓库</li>
<li>readMe：详细描述</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200222123314231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-4-仓库管理"><a href="#1-4-仓库管理" class="headerlink" title="1.4  仓库管理"></a>1.4  仓库管理</h2><ul>
<li><strong>创建新文件</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200222124459789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200222124645965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>修改文件</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200222125407532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>删除文件</strong></li>
</ul>
<p>删除之后可以进入commits查看被删除的文件。</p>
<ul>
<li><strong>上传文件</strong></li>
</ul>
<p>点击 upload选择要上传的文件，或者将文件拖动到该区域，一次可以选择上传多个文件。<br>填写标题和描述之后，点击提交，就上传完成</p>
<ul>
<li><strong>搜索文件</strong></li>
</ul>
<p>点击find file，或者按住键盘T。</p>
<ul>
<li><strong>下载 / 检出项目</strong></li>
</ul>
<p>点击克隆或者下载。</p>
<p><img src="https://img-blog.csdnimg.cn/20200222131226364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-5-提出问题-Issues"><a href="#1-5-提出问题-Issues" class="headerlink" title="1.5  提出问题 Issues"></a>1.5  提出问题 Issues</h2><p><strong>作用：</strong> 发现代码BUG，但是目前没有成型代码，需要讨论时用，或者使用开源项目，出现问题时用。<br><strong>使用：</strong> 发现别人的项目有bug，提交issue，填写相应的标题和描述，然后提交过去。当作者登录github的时候，可以查看问题并讨论回复，问题解决后，点击close Issue 关闭问题。两方都有关闭Issue的权限。</p>
<h2 id="1-6-拉取请求（Pull-Request）"><a href="#1-6-拉取请求（Pull-Request）" class="headerlink" title="1.6  拉取请求（Pull Request）"></a>1.6  拉取请求（Pull Request）</h2><p><img src="https://img-blog.csdnimg.cn/2020022213452533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>git+github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议&amp;C/S通讯抓包</title>
    <url>/678909362/</url>
    <content><![CDATA[<p>http协议：针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 规定了客户端在访问服务器端的时候,服务器端返回数据的时候，要带上什么东西。</p>
<a id="more"></a>
<h1 id="一、Http协议"><a href="#一、Http协议" class="headerlink" title="一、Http协议"></a>一、Http协议</h1><ul>
<li>什么是协议？<br>双方在交互、通讯的时候， 遵守的一种规范、规则。</li>
<li>http协议概述<br>针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 </li>
<li>版本<br> 1.0：请求数据，服务器返回后， 将会断开连接。<br> 1.1：请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。</li>
</ul>
<h1 id="二、演示客户端-如何-与服务器端通讯。"><a href="#二、演示客户端-如何-与服务器端通讯。" class="headerlink" title="二、演示客户端 如何 与服务器端通讯。"></a>二、演示客户端 如何 与服务器端通讯。</h1><p>问题： 在地址栏中键入网络地址 回车  或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据？</p>
<ul>
<li><p>安装抓包工具 HttpWatch (IE插件)</p>
</li>
<li><p>打开tomcat. 输入localhost:8080 打开首页</p>
</li>
<li><p>在首页上找到Example—&gt;选择 Servlet Examples—&gt; Request Parameter</p>
</li>
<li><p>接着点击Request  Parameters 的 Execute超链接，会出现请求参数示例</p>
</li>
<li><p>执行tomcat的例子，然后查看浏览器和 tomcat服务器的对接细节</p>
</li>
</ul>
<h1 id="三、Http请求数据解释"><a href="#三、Http请求数据解释" class="headerlink" title="三、Http请求数据解释"></a>三、Http请求数据解释</h1><ul>
<li><strong>请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体</strong></li>
<li>请求行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 </span><br><span class="line"></span><br><span class="line">		POST ： 请求方式 ，以post去提交数据</span><br><span class="line">			</span><br><span class="line">		/examples/servlets/servlet/RequestParamExample</span><br><span class="line">		请求的地址路径 ， 就是要访问哪个地方。</span><br><span class="line">	</span><br><span class="line">		HTTP/1.1 协议版本</span><br></pre></td></tr></table></figure>

<ul>
<li>请求头：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*</span><br><span class="line">		Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample</span><br><span class="line">		Accept-Language: zh-CN</span><br><span class="line">		User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">		Content-Type: application/x-www-form-urlencoded</span><br><span class="line">		Accept-Encoding: gzip, deflate</span><br><span class="line">		Host: localhost:8080</span><br><span class="line">		Content-Length: 31</span><br><span class="line">		Connection: Keep-Alive</span><br><span class="line">		Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">		Accept: 客户端向服务器端表示，我能支持什么类型的数据。 </span><br><span class="line">		Referer ： 真正请求的地址路径，全路径</span><br><span class="line">		Accept-Language: 支持语言格式</span><br><span class="line">		User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 </span><br><span class="line">		Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据</span><br><span class="line">		Accept-Encoding： gzip, deflate ： 压缩算法 。 </span><br><span class="line">		Host ： 主机地址</span><br><span class="line">		Content-Length： 数据长度</span><br><span class="line">		Connection : Keep-Alive 保持连接</span><br><span class="line">		Cache-Control ： 对缓存的操作</span><br></pre></td></tr></table></figure>
<ul>
<li>请求体：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">浏览器真正发送给服务器的数据 </span><br><span class="line">	</span><br><span class="line">	发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp;</span><br><span class="line"></span><br><span class="line">	firstname=zhang&amp;lastname=sansan</span><br></pre></td></tr></table></figure>
<h1 id="四、Http响应数据解析"><a href="#四、Http响应数据解析" class="headerlink" title="四、Http响应数据解析"></a>四、Http响应数据解析</h1><ul>
<li><strong>请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 673</span><br><span class="line">Date: Fri, 17 Feb 2017 02:53:02 GMT</span><br><span class="line"></span><br><span class="line">...这里还有很多数据...</span><br></pre></td></tr></table></figure>

<ul>
<li>响应行：第一行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">		协议版本  </span><br><span class="line">		状态码 </span><br><span class="line">			咱们这次交互到底是什么样结果的一个code. </span><br><span class="line">			200 : 成功，正常处理，得到数据。</span><br><span class="line">			403  : <span class="keyword">for</span> bidden  拒绝</span><br><span class="line">			404 ： Not Found</span><br><span class="line">			500 ： 服务器异常</span><br><span class="line">		OK</span><br><span class="line">			对应前面的状态码</span><br></pre></td></tr></table></figure>

<ul>
<li>响应头</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Server:  服务器是哪一种类型。  Tomcat</span><br><span class="line">		Content-Type ： 服务器返回给客户端你的内容类型</span><br><span class="line">		Content-Length ： 返回的数据长度</span><br><span class="line">		Date ： 通讯的日期，响应的时间</span><br></pre></td></tr></table></figure>

<h1 id="五、Get-和-Post请求区别"><a href="#五、Get-和-Post请求区别" class="headerlink" title="五、Get 和  Post请求区别"></a>五、Get 和  Post请求区别</h1><ul>
<li>post</li>
</ul>
<ol>
<li>数据是以流的方式写过去，不会在地址栏上面显示。  现在一般提交数据到服务器使用的都是POST。</li>
<li>以流的方式写数据，所以数据没有大小限制。</li>
</ol>
<ul>
<li>get</li>
</ul>
<ol>
<li>会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET。</li>
<li>能够带的数据有限， 1kb大小。</li>
</ol>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用学习</title>
    <url>/339957974/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。也是程序员最常用工具之一，连接本地仓库与github仓库，提高了开发效率，github也是开源项目宝库。</p>
<a id="more"></a>
<h2 id="一、概述原理"><a href="#一、概述原理" class="headerlink" title="一、概述原理"></a>一、概述原理</h2><p>Git是目前世界上最先进的分布式版本控制工具。</p>
<ul>
<li>工作原理：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200325163944876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>概念：</li>
</ul>
<ol>
<li>Workspace：工作区</li>
<li>Index/Stage：暂存区</li>
<li>Respository：仓库区（本地仓库）</li>
<li>Remote：远程仓库</li>
</ol>
<ul>
<li>SVN与Git的区别</li>
</ul>
<ol>
<li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，有时就得等很久了。</p>
</li>
<li><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
</li>
</ol>
<p>##二、使用目的</p>
<p>通过git管理github托管项目代码。<br>##三、下载安装</p>
<p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>##四、Git工作区域</p>
<ul>
<li>工作区（Working Directory）： 添加、编辑、修改文件。</li>
<li>暂存区 ： 暂存已经修改的文件最后统一提交到git仓库中。 留一个回旋的余地，没改好接着改，改好了再提交到仓库。</li>
<li>Git Repository （Git 仓库）：最终确定的文件保留到仓库，成为一个新的版本，并且对他人可见。</li>
</ul>
<p>##五、初始化配置 Git</p>
<ul>
<li>设置用户名：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">'DAQ121'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置用户名邮箱：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">'2829025551@qq.com'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 该设置在github仓库主页显示谁提交了该文件。</p>
<ul>
<li>创建相对应的仓库并初始化：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span>;//创建仓库</span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span>;</span><br><span class="line">git init;//初始化仓库</span><br><span class="line">操作完之后会在<span class="built_in">test</span>目录下出现一个.git的隐藏文件。</span><br></pre></td></tr></table></figure>

<p> ##六、向仓库中添加文件</p>
<ul>
<li>在test仓库里新建文件a1.java</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch a1.java//创建</span><br><span class="line">git status //查看</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200222170530502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>添加到暂存区</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add a1.java</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200222170537166.png" alt="在这里插入图片描述"></p>
<ul>
<li>将文件从暂存区提交到仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'add a1.java'</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200222170859545.png" alt="在这里插入图片描述"><br>##七、修改仓库文件</p>
<ul>
<li>修改后，a1.java 还要add到暂存区中。</li>
<li>然后再从暂存区提交到仓库。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200222172151350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>##八、删除仓库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.删除文件</span><br><span class="line">rm a1.java</span><br><span class="line">2.从Git中删除文件</span><br><span class="line">git rm a1.java</span><br><span class="line">3.提交操作</span><br><span class="line">git commit -m <span class="string">'描述'</span></span><br></pre></td></tr></table></figure>

<p> ##九、Git管理远程仓库</p>
<ul>
<li>使用远程仓库的目的：<br>作用：备份，实现代码共享集中化管理。</li>
<li><strong>Git克隆操作</strong><br>目的：将远程仓库（github对应的项目）复制到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200222174133376.png" alt="在这里插入图片描述"></p>
<ul>
<li>将仓库里的内容克隆到本地，在本地修改之后，添加到暂存区，然后在提交到仓库。</li>
<li><strong>将本地仓库同步到git远程仓库</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<ul>
<li>无法同步，没有权限怎么办？或者想要设置权限，防止乱入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi .git/config</span><br><span class="line">将[remote <span class="string">"origin"</span>]</span><br><span class="line">	url = https://github.com/用户名/仓库名.git</span><br><span class="line">修改为：</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">	url = https://用户名：密码@github.com/用户名/仓库名.git</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git+github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/HashMap/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。</p>
<a id="more"></a>
<ul>
<li><strong>全文概要</strong></li>
</ul>
<table>
<thead>
<tr>
<th>版本</th>
<th>1.7</th>
<th>1.8</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>数组+链表</td>
<td>数组+链表/红黑树</td>
</tr>
<tr>
<td>存值</td>
<td>Entry&lt;key，value&gt;对象</td>
<td>Node（key，value）节点</td>
</tr>
<tr>
<td>初始容量</td>
<td>小于传入数的2的幂次方数（移位运算）</td>
<td>大于传入数的2的幂次方数</td>
</tr>
<tr>
<td>哈希值</td>
<td>高低位混合运算（异或和移位）</td>
<td>高低位混合运算</td>
</tr>
<tr>
<td>扩容机制</td>
<td>头插法</td>
<td>尾插法/链表长度大于8时转化为红黑树</td>
</tr>
<tr>
<td>缺点</td>
<td>链表反转，形成循环链表，线程不安全</td>
<td>高度依赖hash算法，如果key是自定义类害得重写hashcode（），线程不安全</td>
</tr>
</tbody></table>
<h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h3><ul>
<li><code>JDK1.7</code>：数组+链表</li>
<li><code>key</code>和<code>value</code>组合成一个<code>entry</code>对象，将这个对象的引用地址存放在数组中。</li>
<li><code>table</code>数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.根据key先算出来一个hash值</span><br><span class="line"><span class="keyword">int</span> hash = key.hashcode();</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.用这个hash值去跟数组长度(table.length)做与操作</span><br><span class="line"><span class="keyword">int</span> i = hash &amp; (length-<span class="number">1</span>); <span class="comment">//得到的这个i就是数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.就把这个key对应的value放入数组下标i对应的位置</span><br><span class="line">table[i]=value;</span><br></pre></td></tr></table></figure>
<ul>
<li>那为什么要用链表呢？</li>
</ul>
<ol>
<li>再传进来一个<code>value</code>值,万一这个值对应的<code>key</code>算出来的<code>hash</code>值跟之前的重复了怎么办？这就要用到链表了。</li>
<li>将这个<code>key</code>对应的<code>value</code>值放在数组的同一个位置，只不过是以链表的形式。</li>
<li>那怎么放呢？是把这个元素放在链表的头部还是尾部呢？当然是采用<strong>头插法</strong>，因为尾插法效率低（他要遍历整个链表，要知道尾结点是谁，才能放入。）而放在头部只需要将<code>next</code>指向链表的头结点。</li>
<li>那么用<code>put（）</code>存进去了，用<code>get()</code>怎么取呢？，因为<code>get()</code>也是通过计算<code>hash</code>值，得到数组下标，但是这个下标上，有一个链表呀，怎么知道取的是哪个值呢？<strong>所以说：</strong> 一个新的结点插入到头部之后，要往下移动一个位置，（虽然说是移动一个位置，实际上是将这个新元素的值赋值给<code>table[i]</code>,这样，头结点在哪里，链表就在那里）那么取链表上的元素就好取了。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>先分析一下<code>put()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">         inflateTable(threshold);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             e.value = value;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     addEntry(hash, key, value, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过查看源码第一行的<code>if语句</code>可以看出，只有当要往里面存放元素的时候，才去初始化这个桶，懒加载（延迟初始化），在初始化数组的时候，调用了<code>inflateTable(threshold)</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在其中又调用了<code>roundUpToPowerOf2(toSize)</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>highestOneBit（）</code>方法,通过移位和或运算计算出小于<code>i</code>的<code>2的幂次方数capacity</code>（这就是庶族的初始化容量），比如说，传入10，计算得出8，传入19，计算得出16。这个方法里面的运算是先把传入的数转化为二进制，然后在进行移位位运算和或运算，就像这个方法名字一样：得到最高位的那一位，自然而然的得出来的数就是2次幂的数了。得出来的这个数就是<code>table数组</code>的长度，jdk的作者对于位运算的使用已经达到出神入化的境界。</li>
<li>这样做的目的是，如果你修改了这个<code>number值</code>，他也会在加载的时候将这个值转化小于<code>number</code>的2的幂次方数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">       i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">       <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再看<code>indexFor()</code>方法，是通过将算出来的<code>hash值</code>与数组长度进行一个与运算，得到这个数组下标<code>i</code>。这个<code>table[i]</code>就是要存的位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">思考为什么要length-<span class="number">1</span>？</span><br><span class="line">因为length是<span class="number">2</span>的幂次方数</span><br><span class="line">经过与运算之后，只得到低四位有效，有效的低四位取值范围就是<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">就得出了下标在<span class="number">0</span>-<span class="number">15</span>这个范围之内。</span><br></pre></td></tr></table></figure>
<ul>
<li>这就可以解决以上的一个问题了，为什么hashmap在初始化一个数组的容量的时候，要是一个2的幂次方数，因为要配合<code>indexFor()</code>计算出数组下标，对应存储。但是这样算出来的<code>hash值</code>会覆盖掉很多种情况，这就导致了很多元素算出来的下标值一样，存储在同一链表上，链表就会很长，进而影响到<code>get()</code>的效率，因为<code>get()</code>要循环链表嘛，所以回到上一步，可以看到<code>hash()方法</code>。</li>
<li>再看<code>hash()</code>方法（并不是<code>hashcode()方法哦</code>），它里面有异或和移位运算（这样高位就参与到运算了–高低位混合运算），可以理解为<code>再次哈希</code>，这样就增加了散列性。解决了的单条链表很长的问题。如果我们要改写<code>hashcode（）</code>，但是我们水平不行，改了之后导致返回的<code>hashcode值</code>非常不均匀，那么这个<code>hash()方法</code>就会帮我们容错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再看<code>for循环</code>，它要做的事就是遍历链表，看看有没有key值相同的，比如说<code>put(1,2);</code>和<code>put(1,3)</code>，可以看到，两个key值是相等的，for循环判断之后，就会用新的值覆盖老的值，再返回老的值<code>oldValue</code>。</li>
<li><code>modCount++</code>跟多线程并发有关。</li>
<li><code>addEntry(hash,key,value,i)</code>这才是真正的将<code>key和value</code>放到数组上面去。<code>if</code>里面的语句就是涉及到扩容了，<code>threshold</code>是通过阈值<code>capacity</code>乘加载因子<code>DEFAULT_LOAD_FACTOR</code>得到的，如16<em>0.75=12，可以看到扩容要满足两个条件。这里的<code>size</code>是指当前数组占用了多少，而不是指链表的长度。后面那个条件是指数组中没有位置为空了，*</em>大于阈值，并且发生过一次碰撞之后就扩容！！！**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容的目的就是为了提高效率，因为链表上元素太多了，就会影响<code>get()</code>的效率。点开<code>resize()</code>方法可以看到，先<code>new</code>出来一个新的数组，长度是原先的两倍，然后在调用<code>transfer()</code>方法将老元素移动到新数组中。在转移的时候，将一个长链表拆成两个个短链表，减轻了压力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容是怎么来实现的呢？看这个<code>transfer()</code>方法中显示，有需要进行<code>rehash</code>的情况，也有不需要<code>rehash</code>的情况。看到<code>for()循环</code>是遍历这个数组上有没有空，而嵌套的<code>while()</code>循环是遍历这个链表上的元素。</li>
</ul>
<ol>
<li>先看不需要<code>rehash</code>的情况（<strong>适用于单线程</strong>）此时<code>rehash=false</code>，可以看到下面又使用了<code>indexFor</code>方法，传入的是被遍历的这个元素的hash值，和新数组的长度，计算得出一个值<code>i</code>，这就是新数组的下标，把老元素放到<code>newTable[i]</code>上。事实上，根据运算得到的<code>i</code>值和原先是一样的，因为原本的hash值没有变，只是拿过来用，而变化的是数组长度，但是并不会影响算出来的<code>i</code>值，所以说，传到新数组后，下标还是没有变。但是这样引发了扩容之后的一个问题：<strong>链表上的元素全部倒过来了，意思就是新链表的顺序和之前的完全颠倒了。</strong></li>
<li>多线程情况下，如果有两个线程同时调用haspmap的这个对象，都会使用到<code>put()</code>方法，如果最终同时走到了<code>resize()</code>方法中，各种混乱的走法之后，<strong>最终会产生一个循环链表，最终耗尽CPU的资源。</strong>–这就是haspmap扩容带来的第二个问题</li>
<li>再看需要<code>rehash</code>的情况，其实很少会走到<code>rehash()</code>中，在<code>rehash（）</code>中打了一个断点，测试的时候无限<code>put()</code>,却发现，始终不会执行<code>rehash（）</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h3><ul>
<li><strong>HashMap底层是怎么实现的呢？</strong><br>答：在jdk1.7的时候，底层是由数组+链表实现的，由key和value组成一个entry对象，用put方法将key和value传入，当调用这个put方法的时候，就会初始化一个数组（也就是所说的延迟初始化），这个数组的初始容量给的是16，负载因子是0.75，根据这个key值使用hash方法算出hash值，再用这个hash值跟数组的长度做模运算，得到一个数组下标，就将这个元素的值放入到对应下标的位置，那如果再传入的另一个元素算出来的hash值也是一样的（这就叫hash冲突），那么进而算出来的下标也是一样的，这就要用到链表了，使用头插法，并保证最新插入的这个元素是整个链表的头结点，就实现了存储的过程。</li>
<li><strong>扩容的机制？</strong><br>在put的时候，有一个方法是<code>addEntry</code>，先判断当前的size是不是大于阈值，这里的阈值就是（数组初始长度<em>加载因子），默认的就是12，大于这个阈值，并且发生了hash碰撞的时候，就要进行扩容了，就是执行<code>resize()</code>方法，扩容的方法就是，new一个新数组，长度是原数组长度的两倍，然后在用<code>transfer</code>方法将老数组中的元素转移过去，还重新算一下扩容之后的阈值，这样做出现的问题就是：在单线程情况下还好，只不过转移过去的链表会反转，*</em>但是在多线程的情况下**，就会出现一个闭环，会把cpu的资源耗尽。这里面还有一个<code>rehash()</code>方法，但是这个方法我并没有具体研究，涉及到一个哈希种子，其实这个rehash方法并不会用到。在源码rehash中打个断点，测试代码中无限put操作，发现程序并不会停止。</li>
<li><strong>HashMap为什么是线程不安全的？</strong><br>HashMap在put的时候，超过的阈值就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</li>
</ul>
<h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="大致了解-1"><a href="#大致了解-1" class="headerlink" title="大致了解"></a>大致了解</h3><ul>
<li>在1.7中叫entry对象，在1.8中叫node结点。</li>
<li><strong>在1.8中加入了红黑树，为什么加红黑树？</strong><br>虽然在1.7中实行了很多措施，如扩容，去增加元素的散列性，使链表的长度更短一些，但是还是会出现一些极端情况，某些地方链表还是会很长，所以加入了红黑树，当链表达到一定长度大于8的时候，就要先看数组，决定是否要扩容，然后在不行就要换用红黑树了。当红黑树结点小于6的时候，又变为链表了。</li>
<li><strong>为什么链表上限设置为8，为红黑树下限设置为6呢？为什么不设置为8？</strong><br>这样是为了防止平凡的插入和删除，打个比方，当我插入第9个元素的时候，这就要变为红黑树了，可是我马上又删除了一个元素，红黑树又要变成链表，这样不停的来回转换，会拉低效率，所以将红黑树结点下限设置为6。</li>
</ul>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>分析put（）方法。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416091904314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200416094525420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>在1.8中初始化容量的时候，和1.7有不同，如果你传入的一个数字，会调用<code>tableSizeFor()</code>方法进行移位运算，最终得到一个大于你传入的这个数字的数（这个数依旧是2的次幂），而1.7中得到的这个数字是小于你传入的这个数。这个数用来作为数组的初始容量。</p>
</li>
<li><p>在1.8中采用尾插法加入元素，这是因为，每次加入元素的时候，本来就要遍历一下链表，看有没有超过八个结点，超过了就变成红黑树，总之是要遍历的，直接用尾插法，一举两得。</p>
</li>
<li><p>在遍历的过程中，还要看有没有与老元素key值相同的，相同则覆盖掉，除此之外还要判断是否为红黑树。</p>
</li>
<li><p><strong>关于树化:</strong> 点开treeifyBin方法发现：在链表上的结点大于八个的时候，不会第一时间去树化，而是先判断是否需要扩容，然后再去决定要不要树化，其实扩容大概率能减少链表的长度了。一举两得，扩容比树化优点好多了。基于对内存的一个节省，不能扩容的太大，就用红黑树。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020041609544419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>1.8里的扩容只要满足一个条件，而1.7中需要满足两个。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416094609702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>扩容详解，条件只有一个，但是代码却长了很多，核心思想就是：使用2次幂的扩展（长度变两倍）所以，要么元素的位置是在原位置，要么是在原位置基础上移动2次幂的位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到里面的算hash值的方法。跟1.7的差不多。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416092054872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><ul>
<li>JDK1.8中，HashMap是怎么实现的？<br>在JDK1.8中，底层是由数组+链表/红黑树实现的，将key和value封装成一个node结点，计算hash值和1.7是差不多的，在put的时候，有两点要注意，一个是判断新元素key值是否与老元素相等，相等则覆盖掉，不相等就直接插入，另一点就是判断是链表还是红黑树，选择遍历的方式，采用尾插法来插入元素，也不用担心需要遍历整个链表，因为判断链表上结点个数的时候总是要遍历的，这里值得注意的是，在判断是否需要变为红黑树的时候，（也就是链表结点大于等于8的时候）首先要考虑的是扩容，因为扩容大概率能够解决链表长度的问题，而且还增大了空间，但是不能一味的扩容，这样会导致内存浪费，所以就转换成红黑树了。</li>
</ul>
<h2 id="对比JDK1-7和1-8"><a href="#对比JDK1-7和1-8" class="headerlink" title="对比JDK1.7和1.8"></a>对比JDK1.7和1.8</h2><table>
<thead>
<tr>
<th></th>
<th>1.7</th>
<th>1.8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层实现</strong></td>
<td>数组+链表</td>
<td>数组+链表/红黑树</td>
</tr>
<tr>
<td><strong>形式</strong></td>
<td>Entry&lt;key，value&gt;对象</td>
<td>Node&lt;key,value&gt;结点</td>
</tr>
<tr>
<td><strong>下标值</strong></td>
<td>hash &amp;（length-1）</td>
<td>（n-1）&amp; hash</td>
</tr>
<tr>
<td><strong>元素插入</strong></td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>resize（链表反转，循环链表）</td>
<td>解决了链表反转的问题</td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>链表：n</td>
<td>红黑树：log（n）</td>
</tr>
<tr>
<td><strong>扩容</strong></td>
<td>transfor（）方法，新数组两倍长度</td>
<td>resize（）方法</td>
</tr>
</tbody></table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li><p><strong>HashMap线程不安全，为什么还要用它？</strong><br>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。但综合各种因素，首要推荐使用ConcurrentHashMap。</p>
</li>
<li><p><strong>ConcurrentHashMap实现</strong><br>ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</p>
</li>
<li><p><strong>ConcurrentHashMap有哪些优点？</strong></p>
</li>
</ul>
<ol>
<li>线程安全的，在多线程下效率更高。</li>
<li>ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有。</li>
<li>ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 </li>
</ol>
<ul>
<li><strong>ConcourrentHashMap和Hashtable都是线程安全的，为什么不用Hashtable？</strong></li>
</ul>
<ol>
<li>hashtable:使用一把锁处理并发问题，当有多个线程访问时，需要多个线程竞争一把锁，导致阻塞。</li>
<li>concurrentHashMap则使用分段，相当于把一个hashmap分成多个，然后每个部分分配一把锁，这样就可以支持多线程访问。</li>
</ol>
]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>一、HashMap的底层实现原理</title>
    <url>/2744944506/</url>
    <content><![CDATA[<p>HeshMap是基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。在面试中也经常出现这道考题，记录一下！</p>
<a id="more"></a>


<h1 id="HsahMap的实现原理"><a href="#HsahMap的实现原理" class="headerlink" title="HsahMap的实现原理"></a>HsahMap的实现原理</h1><h2 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h2><ul>
<li>HashMap 基于 Hash 算法实现的，底层是由数组+链表/红黑树构成的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表，否则使用红黑树。</li>
</ul>
<h2 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h2><ul>
<li>HashMap通过<strong>键值对</strong>实现存取。</li>
<li><code>put（）</code>方法：对key做null检查。如果key是null，会被存储到table[0]，因为null的hash值总是0。 key的hashcode()方法会被调用，然后计算hash值。hash值用来找到存储Entry对象的数组的索引。有时候hash函数可能写的很不好，所以JDK的设计者添加了另一个叫做hash()的方法，它接收刚才计算的hash值作为参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  		 Node&lt;K,V&gt;[] tab; </span><br><span class="line">  		 Node&lt;K,V&gt; p; </span><br><span class="line">  		 <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Get（）</code>：对key进行null检查。如果key是null，table[0]这个位置的元素将被返回。<br>key的hashcode()方法被调用，然后计算hash值。indexFor(hash,table.length)用来计算要获取的Entry对象在table数组中的精确的位置，使用刚才计算的hash值。在获取了table数组的索引之后，会迭代链表，调用equals()方法检查key的相等性，如果equals()方法返回true，get方法返回Entry对象的value，否则，返回null。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="built_in">return</span> (e = getNode(<span class="built_in">hash</span>(key), key)) == null ? null : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Implements Map.get and related methods.</span><br><span class="line">    *</span><br><span class="line">    * @param <span class="built_in">hash</span> <span class="built_in">hash</span> <span class="keyword">for</span> key</span><br><span class="line">    * @param key the key</span><br><span class="line">    * @<span class="built_in">return</span> the node, or null <span class="keyword">if</span> none</span><br><span class="line">    */</span><br><span class="line">   final Node&lt;K,V&gt; getNode(int <span class="built_in">hash</span>, Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">           (first = tab[(n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == <span class="built_in">hash</span> &amp;&amp; // always check first node</span><br><span class="line">               ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="built_in">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != null) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                   <span class="built_in">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(<span class="built_in">hash</span>, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="built_in">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>补充：</p>
<ol>
<li>HashMap有一个叫做Entry的内部类，它用来存储key-value对。</li>
<li>上面的Entry对象是存储在一个叫做table的Entry数组中。</li>
<li>table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。</li>
<li>key的hashcode()方法用来找到Entry对象所在的桶。</li>
<li>如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。</li>
<li>key的equals()方法用来确保key的唯一性。</li>
</ol>
<h1 id="有关知识的具体解析"><a href="#有关知识的具体解析" class="headerlink" title="有关知识的具体解析"></a>有关知识的具体解析</h1><h2 id="一、Map的几种类型"><a href="#一、Map的几种类型" class="headerlink" title="一、Map的几种类型"></a>一、Map的几种类型</h2><p><img src="https://img-blog.csdnimg.cn/20200314144530842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Map就是一个值key对应一个value。</li>
<li>Hashtable（线程安全）和HashMap（非线程安全）在代码实现上，基本上是一样的。现在Hashtable已经过时了(小写的t，因为sun当时的一个失误，因为是JDK1.0的产物，所以不方便改)。</li>
<li>ConcurrentHashMap也是线程安全的，但性能比HashTable好很多，Hashtable是锁整个Map对象，而ConcurrentHashMap是锁Map的部分结构。</li>
</ul>
<h2 id="二、什么是哈希表？"><a href="#二、什么是哈希表？" class="headerlink" title="二、什么是哈希表？"></a>二、什么是哈希表？</h2><ul>
<li>利用<strong>数组</strong>寻址容易，但插入和删除困难。而<strong>链表</strong>是：寻址困难，插入和删除容易。而<strong>哈希表</strong>便综合两者的特性，是一种寻址容易，插入删除也容易的数据结构。</li>
<li>哈希表有多种不同的实现方法，最常用的方法—— 拉链法，可以理解为“链表的数组”<br><img src="https://img-blog.csdnimg.cn/20200314161134205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>一个长度为16的数组中，每个元素存储的是一个链表的头结点。这些元素是按照什么样的规则存储到数组中呢？一般情况是通过<code>hash(key)%len</code>获得，也就是元素的key的哈希值对数组长度取模得到。</li>
<li>比如上述哈希表中12%16=12 , 28%16=12 , 108%16=12 , 140%16=12。所以12、28、108，140都存储在数组下标为12的位置。</li>
<li><strong>HashMap其实也是一个线性数组（<code>Entry[]</code>）实现的,所以可以理解为其存储数据的容器就是一个线性数组。但是一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap是做了一些处理的。</strong></li>
</ul>
<h2 id="三、什么是哈希算法？"><a href="#三、什么是哈希算法？" class="headerlink" title="三、什么是哈希算法？"></a>三、什么是哈希算法？</h2><ul>
<li>Hash算法虽然被称为算法，但实际上它更像是一种思想。Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法。</li>
<li>哈希（hash）算法又称为散列算法，通过hash算法，可以将任意长度的信息转换成一个固定长度的二进制数据，我们经常会使用十六进制值来表示转换后的信息。</li>
<li>比如，数字123，使用md5的hash算法后，得到十六进制的值：202cb962ac59075b964b07152d234b70</li>
<li>哈希算法的特点：<br>（1）不同的信息，理论上得到的hash值不同，我们称之为“无碰撞”，或者发生“碰撞”的概率非常小。<br>（2）不可逆，hash算法是单向的，从hash值反向推导出原始信息是很困难的。所以，有些系统中，我们可以使用hash算法对密码进行处理后保存。</li>
<li>哈希算法的应用<br>①</li>
</ul>
<h2 id="四、什么是红黑树？"><a href="#四、什么是红黑树？" class="headerlink" title="四、什么是红黑树？"></a>四、什么是红黑树？</h2><ul>
<li><strong>二叉树（BST）</strong>：<br>①左子树结点的值小于等于根节点的值。<br>②右子树结点的值大于等于根节点的值。<br>③左右子树分开来也是单独的二叉树。<br><img src="https://img-blog.csdnimg.cn/20200314174010980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul>
<li><strong>红黑树（RBT）</strong>：红黑树是一种自平衡的二叉树，除了符合二叉树的基本特征之外还引入了一些附加的条件。<br>①节点是红色或黑色。<br>②根节点是黑色。<br>③每个叶子节点都是黑色的空节点（NIL节点）。<br>④每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。<br>⑥从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br><img src="https://img-blog.csdnimg.cn/20200314174041551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h2 id="五、HashMap-和-Hashtable-有什么区别？"><a href="#五、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="五、HashMap 和 Hashtable 有什么区别？"></a>五、HashMap 和 Hashtable 有什么区别？</h2><ul>
<li>HashMap是非线程安全的，HashMap是Map的一个实现类，是将键映射到值的对象，不允许键值重复。允许空键和空值；由于非线程安全，HashMap的效率要较 Hashtable 的效率高一些。</li>
<li>Hashtable 是线程安全的一个集合，不允许 null 值作为一个 key 值或者value 值。             </li>
<li>Hashtable是sychronized，多个线程访问时不需要自己为它的方法实现同步，而HashMap 在被多个线程访问的时候需要自己为它的方法实现同步。</li>
<li>一般现在不建议用Hashtable：<br>①注意是小写的t，这是sun公司的一个失误，但是由于是JDK1.0的产物，所以没有改<br>②是Hashtable是遗留类，内部实现很多没优化和冗余。<br>③即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li>
</ul>
<h1 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h1><h2 id="产生hash冲突的原因"><a href="#产生hash冲突的原因" class="headerlink" title="产生hash冲突的原因"></a>产生hash冲突的原因</h2><ul>
<li>当我们通过put(key, value)向hashmap中添加元素时，需要通过hash函数确定元素究竟应该放置在数组中的哪个位置，因为不同的元素可能通过hashcode（）计算得到的哈希值相同，那么不同的元素被放置在了数据的同一个位置时，后放入的元素会以链表的形式，插在前一个元素的尾部，这个时候我们称发生了hash冲突。</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>事实上，想让hash冲突完全不发生，是不太可能的，我们能做的只是尽可能的降低hash冲突发生的概率。<br>①开放定址法<br>②链地址法（拉链法）<br>Java 中 HashMap 解决 Hash 冲突就是利用了这个方法，具体实现这里暂时不做详解，可以参考 Jdk HashMap 源码进行理解。<br>③再哈希法<br>④建立公共溢出区</li>
</ul>
]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HTPP中的GET和POST</title>
    <url>/1483407090/</url>
    <content><![CDATA[<p>当我们在浏览器点击某个按钮，会向服务器发送一个请求（request），服务器收到请求之后，会返回给我们一个响应（response），那这个请求是如何发送的呢。</p>
<a id="more"></a>

<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><ul>
<li>HTTP是什么？<br>HTTP基于TCP/IP，它是关于<strong>数据如何在万维网中通讯</strong> 的协议。</li>
<li>GET和POST是什么？<br>HTTP协议中的两种<strong>发送请求</strong> 的方法。</li>
</ul>
<h2 id="二、简单理解"><a href="#二、简单理解" class="headerlink" title="二、简单理解"></a>二、简单理解</h2><ul>
<li><p>把万维网传输线路比作一条高速公路，公路上的汽车就相当于一个个<strong>TCP</strong> ，用他们来实现可靠数据传输，但是车也有不同车型，如果全都一样，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通就会瘫痪。为了避免这种情况发生，需要制定好交通规则，也就是<strong>HTTP</strong>协议。</p>
</li>
<li><p>HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等。<br>①当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。<br>②如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物；也可以在POST的时候在车顶上也放一些数据。<strong>HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</strong></p>
</li>
<li><p>不同的浏览器（发起http请求）和服务器（接受http请求），虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是数据量太大对浏览器和服务器都是很大负担。 于是大多数浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分不处理。如果使用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p>
</li>
<li><p>所以可以这么理解：GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
</li>
</ul>
<h2 id="三、标准答案"><a href="#三、标准答案" class="headerlink" title="三、标准答案"></a>三、标准答案</h2><ul>
<li>GET参数通过URL传递，POST放在Request body中。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ul>
<h2 id="四、关键区别"><a href="#四、关键区别" class="headerlink" title="四、关键区别"></a>四、关键区别</h2><ul>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li>
<li>通俗来讲就是：<br>①对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。<br>②对于POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
<li>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。但是！！！！<br>①GET与POST都有自己的语义，不能随便混用。<br>②在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br>③并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ul>
]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC基础知识</title>
    <url>/3453823259/</url>
    <content><![CDATA[<p>JDBC概述，作用，类型，以及使用时如何选择。</p>
<a id="more"></a>
<h2 id="一、JDBC是什么？"><a href="#一、JDBC是什么？" class="headerlink" title="一、JDBC是什么？"></a>一、JDBC是什么？</h2><ul>
<li>百度百科解释：JDBC(java database connectivity)驱动程序是对JDBC规范完整的实现，它的存在在Java程序与数据库系统之间建立了一条通信的渠道。它是 一 种可用于执行 SQL 语句的 Java API(<strong>Application Programming Interface， 应用程序设计接口</strong>)。</li>
<li>简单理解：java 数据库连接。有了它，就能够在java代码中操作任何数据库。由于数据库种类繁多，并且java程序使用广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问。</li>
<li>刚开始每个数据库（Oracle，Mysql，SqlServer）的访问规则都不同，后来SUN公司想一统天下，出台了一套规范，各个数据库要按照这个规范去写底层代码，与此同时，Java程序也直接去找JDBC。</li>
</ul>
<h2 id="二、作用是什么？"><a href="#二、作用是什么？" class="headerlink" title="二、作用是什么？"></a>二、作用是什么？</h2><ul>
<li>JDBC 为数据库应用开发人员、数据库前台开发人员提供了一种标准的应用程序设计接口， 使开发人员可以用纯 Java 语言编写完整的数据库应用程序。</li>
<li>JDBC 通过调用其接口提供的方法， 提供了 Java 应用程序与各种数据库服务器之间的连接服务，。</li>
<li>它支持 ANSI SQL- 92 标准， 实现了从 Java 程序内调用标准的 SQL 命令对数据库进行查询、插入、删除和更新等操作， 并确保数据事务的正常进行。</li>
</ul>
<h2 id="三、JDBC驱动程序"><a href="#三、JDBC驱动程序" class="headerlink" title="三、JDBC驱动程序"></a>三、JDBC驱动程序</h2><p>根据访问数据库的技术不同， JDBC 驱动程序相应地分为四种类型。不同类型的驱动程序有着不一样的特性和使用方法。</p>
<p> 1.<strong>JDBC-ODBC桥驱动程序(JDBC-ODBC Bridge Driver)</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 此类驱动程序由JDBC-ODBC桥和一个ODBC驱动程序组成。</li>
<li><input disabled="" type="checkbox"> 工作原理：通过一段本地<strong>C代码</strong>将JDBC调用转化成ODBC调用。这一类型必须在本地计算机上先安装好ODBC驱动程序，然后通过JDBC-ODBCBridge的转换，将Java程序中使用的JDBC API访问指令转化成ODBC API指令，进而通过ODBC驱动程序调用本地数据库驱动代码完成对数据库的访问。</li>
</ul>
<p> 2.<strong>部分Java的本地JDBC API驱动程序</strong></p>
<ul>
<li><input disabled="" type="checkbox"> JDBC API驱动程序(Anative API partly Java technology-enabled Driver)</li>
<li><input disabled="" type="checkbox"> 工作原理：此类驱动程序也必须在本地计算机上先安装好特定的驱动程序(类似ODBC)，然后通过PartialJavaJDBCDriver的转换，把Java程序中使用的JDBC API转换成NativeAPI，进而存取数据库。</li>
</ul>
<p>3.<strong>纯Java的数据库中间件驱动程序</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 纯Java的数据库中间件驱动程序(Pure Java Driver for Database Middleware)使用这类驱动程序时，不需要在本地计算机上安装任何附加软件，但是必须在安装数据库管理系统的服务器端加装中间件(Middleware)，这个中间件负责所有存取数据库时必要的转换。</li>
<li><input disabled="" type="checkbox"> 工作原理：驱动程序将JDBC访问转换成与数据库无关的标准网络协议(通常是HTTP或HTTPS)送出，然后再由中间件服务器将其转换成数据库专用的访问指令，完成对数据库的操作。中间件服务器能支持对多种数据库的访问。</li>
</ul>
<p>4.<strong>纯Java的JDBC驱动程序</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 纯Java的JDBC驱动程序(Direct-to-DatabasePureJavaDriver)这类驱动程序是直接面向数据库的纯Java驱动程序，即所谓的”瘦”驱动程序。</li>
<li><input disabled="" type="checkbox"> 工作原理：使用这类驱动程序时无需安装任何附加的软件(无论是本地计算机或是数据库服务器端)，所有存取数据库的操作都直接由JDBC驱动程序来完成，此类驱动程序能将JDBC调用转换成DBMS专用的网络协议，能够自动识别网络协议下的特殊数据库并能直接创建数据连接。</li>
</ul>
<h2 id="四、JDBC驱动程序的选择"><a href="#四、JDBC驱动程序的选择" class="headerlink" title="四、JDBC驱动程序的选择"></a>四、JDBC驱动程序的选择</h2><p>在企业内部信息系统中，选择合适的JDBC驱动程序，使之符合数据库程序设计的要求，是提高系统性能必须考虑的一个方面。不同的应用有不同的需要，所以要根据应用选择合适的驱动程序。</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>JDBC-ODBC桥驱动程序(JDBC-ODBC Bridge Driver)</strong></li>
<li>优点：节省投资，利用了已有的ODBC驱动程序。</li>
<li>缺点：中间有多次调用，性能受到影响，执行效率比较低，不适合对大数据量存取的应用。有损Java数据库程序的兼容性，不具备跨平台性，不适合基于Internet/Intranet的应用。</li>
<li>应用：桥接驱动程序用于已经在ODBC技术上投资的情形，例如已经投资了Windows应用服务器。</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>部分Java的本地JDBC API驱动程序</strong></li>
<li>优点：具有开放性，其利用多层结构，上层用Java实现，支持多数据库，下层为本地代码(包括一些二进制代码和一个轻量的Java库)，加快了执行速度，提高了数据库访问效率。</li>
<li>缺点：没有使用纯Java的API，如果在本地代码中存在缺陷，将可能使Java虚拟机完全垮掉。</li>
<li>应用：受到限制</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>纯Java的数据库中间件驱动程序</strong></li>
<li>优点：由纯Java语言开发而成的，并且中间件也仅需要在服务器上安装，不再需要客户端的本机代码，这类驱动程序的体积最小，效率较高，具有最大的灵活性。此类驱动采用标准的网络协议，可以被防火墙支持，是开发Applet程序理想的选择(其实这些驱动是为Applet特别编写的)，是Internet应用理想的解决方案。开发者还可以利用单一的驱动程序连接到多种数据库。</li>
<li>缺点：需要在服务器端安装中间件，这适当影响了驱动程序的效率。</li>
<li>应用：基于Web的应用系统的开发。</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>纯Java的JDBC驱动程序</strong></li>
<li>最佳的JDBC驱动程序类型。</li>
<li>优点：无需安装任何附加软件，不会增加任何额外开销，效率最高，拥有最佳的兼容性。</li>
<li>缺点：可能不被防火墙支持，在Internet中会存在潜在安全隐患，成为这类驱动最大的缺陷。</li>
<li>应用：在企业级应用软件中，是应优先考虑的。因此，一个Servlet程序，要适应不同的操作系统，最好使用此类驱动;这种驱动也非常适合Applet程序，事实证明它能安全通过TCP/IP协议连接到数据库。</li>
</ul>
<p> <img src="https://img-blog.csdnimg.cn/20200220152318929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/202002201540355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC,MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP&amp;EL&amp;JSTL</title>
    <url>/1540231261/</url>
    <content><![CDATA[<p>JSP，EL表达式，JSTL介绍</p>
<a id="more"></a>
<h1 id="一、JSP"><a href="#一、JSP" class="headerlink" title="一、JSP"></a>一、JSP</h1><h2 id="什么是jsp？"><a href="#什么是jsp？" class="headerlink" title="什么是jsp？"></a>什么是jsp？</h2><p><strong>Java Server Page</strong>  从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p>
<h2 id="为什么会有jsp"><a href="#为什么会有jsp" class="headerlink" title="为什么会有jsp?"></a>为什么会有jsp?</h2><p>为了有更好的用户体检，更好的交互效果。因为html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， <strong>jsp里面可以写java代码。</strong> </p>
<h2 id="jsp怎么用？"><a href="#jsp怎么用？" class="headerlink" title="jsp怎么用？"></a>jsp怎么用？</h2><h3 id="一、jsp指令"><a href="#一、jsp指令" class="headerlink" title="一、jsp指令"></a>一、jsp指令</h3><p><strong>一、page指令</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200229121757727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">指令写法：</span><br><span class="line">&lt;%@ 指令名字 %&gt;</span><br><span class="line"></span><br><span class="line">page指令：</span><br><span class="line">1. language：表明jsp页面中可以写java代码</span><br><span class="line"></span><br><span class="line">2. contentType：其实就是说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</span><br><span class="line">	contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">	text/html  MIMEType 这是一个文本，html网页</span><br><span class="line"></span><br><span class="line">3. pageEncoding：jsp内容编码</span><br><span class="line"></span><br><span class="line">4. extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</span><br><span class="line"></span><br><span class="line">5. import 导包使用的，一般不用手写。</span><br><span class="line"></span><br><span class="line">6. session </span><br><span class="line"> - 值可选的有<span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line"> - 用于控制在这个jsp页面里面，能够直接使用session对象。</span><br><span class="line"> - 具体的区别是，请看翻译后的java文件：</span><br><span class="line">	如果该值是<span class="literal">true</span> , 那么在代码里面会有getSession（）的调用，</span><br><span class="line">	如果是<span class="literal">false</span> :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</span><br><span class="line"></span><br><span class="line">7. errorPage： 指的是错误的页面， 值需要给错误的页面路径</span><br><span class="line"></span><br><span class="line">8. isErrorPage：上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</span><br></pre></td></tr></table></figure>

<p><strong>二、include指令</strong></p>
<ul>
<li>包含另外一个jsp的内容进来。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"other02.jsp"</span>%&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>背后细节:<br>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</li>
</ul>
<p><strong>三、taglib</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">""</span>  uri=<span class="string">""</span>%&gt;  </span><br><span class="line">	uri: 标签库路径</span><br><span class="line">	prefix : 标签库的别名</span><br></pre></td></tr></table></figure>

<h3 id="二、jsp动作标签（写在body里面）"><a href="#二、jsp动作标签（写在body里面）" class="headerlink" title="二、jsp动作标签（写在body里面）"></a>二、jsp动作标签（写在body里面）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">""</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">""</span> name=<span class="string">""</span>/&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- jsp:include</span><br><span class="line">&lt;jsp:include page=<span class="string">"other02.jsp"</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 </span><br><span class="line"></span><br><span class="line">- jsp:forward</span><br><span class="line">前往哪一个页面。</span><br><span class="line"> 	&lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br><span class="line">等同于：请求转发</span><br><span class="line">&lt;% request.getRequestDispatcher(<span class="string">"other02.jsp"</span>).forward(request,response);%&gt;	</span><br><span class="line"></span><br><span class="line">- jsp:param</span><br><span class="line">第一步：在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</span><br><span class="line">&lt;jsp:forward page=<span class="string">"other02.jsp"</span>&gt;</span><br><span class="line">	&lt;jsp:param value=<span class="string">"beijing"</span> name=<span class="string">"address"</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line"></span><br><span class="line">第二步：在other02.jsp中获取这个参数</span><br><span class="line">&lt;br&gt;收到的参数是：&lt;br&gt;</span><br><span class="line">&lt;%= request.getParameter(<span class="string">"address"</span>)%&gt;</span><br></pre></td></tr></table></figure>
<h2 id="jsp内置对象（重点！）"><a href="#jsp内置对象（重点！）" class="headerlink" title="jsp内置对象（重点！）"></a>jsp内置对象（重点！）</h2><p> 所谓内置对象（有九个），就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p>
<h3 id="作用域对象"><a href="#作用域对象" class="headerlink" title="作用域对象"></a>作用域对象</h3><ul>
<li><strong>作用域对象有四个：</strong><ol>
<li><strong>pageContext</strong></li>
<li><strong>request</strong></li>
<li><strong>session</strong></li>
<li><strong>application</strong></li>
</ol>
</li>
</ul>
<ul>
<li><strong>作用域 ：</strong> 表示这些对象可以存值，他们的取值范围有限定。<br>用setAttribute   和  getAttribute来进行存取。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用作用域来存储数据&lt;br&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">	request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">	session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">	application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">取出四个作用域中的值&lt;br&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用域范围大小：（由小到大）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pageContext -- request --- session -- application</span><br></pre></td></tr></table></figure>
<ul>
<li>四个作用域的区别</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11. pageContext 【PageContext】</span><br><span class="line">作用域仅限于当前的页面，还可以获取到其他八个内置对象。</span><br><span class="line"></span><br><span class="line">12. request 【HttpServletRequest】</span><br><span class="line">作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</span><br><span class="line"></span><br><span class="line">13. session 【HttpSession】</span><br><span class="line">作用域限于一次会话（多次请求与响应） 当中。 </span><br><span class="line"></span><br><span class="line">14. application 【ServletContext】</span><br><span class="line"> 整个工程都可以访问， 服务器关闭后就不能访问了。</span><br></pre></td></tr></table></figure>
<h3 id="其他内置对象"><a href="#其他内置对象" class="headerlink" title="其他内置对象"></a>其他内置对象</h3><ul>
<li>out                 【JspWriter】</li>
<li>response      【HttpServletResponse】<br><img src="https://img-blog.csdnimg.cn/20200229140948897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>exception  【Throwable】</li>
<li>page             【Object】 —就是这个jsp翻译成的java类的实例对象</li>
<li>config         【ServletConfig】</li>
</ul>
<h1 id="二、EL表达式"><a href="#二、EL表达式" class="headerlink" title="二、EL表达式"></a>二、EL表达式</h1><ul>
<li>是为了简化jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">写法格式：</span><br><span class="line">	<span class="variable">$&#123;表达式 &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</li>
</ul>
<h3 id="EL取值方式"><a href="#EL取值方式" class="headerlink" title="EL取值方式"></a>EL取值方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 取出4个作用域中存放的值</span><br><span class="line">	&lt;%</span><br><span class="line">		pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">		request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">		session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">		application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">	%&gt;</span><br><span class="line">		</span><br><span class="line">	按普通手段取值：</span><br><span class="line">	&lt;%= pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">	&lt;%= request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">	&lt;%= session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">	&lt;%= application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">		</span><br><span class="line">	使用EL表达式取出作用域中的值：</span><br><span class="line">	<span class="variable">$&#123; pageScope.name &#125;</span></span><br><span class="line">	<span class="variable">$&#123; requestScope.name &#125;</span></span><br><span class="line">	<span class="variable">$&#123; sessionScope.name &#125;</span></span><br><span class="line">	<span class="variable">$&#123; applicationScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. 如果域中所存的是数组</span><br><span class="line">   	&lt;%	String [] a = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>&#125;;</span><br><span class="line">   		pageContext.setAttribute(<span class="string">"array"</span>, a); %&gt;</span><br><span class="line">   		</span><br><span class="line">   	使用EL表达式取出作用域中数组的值：</span><br><span class="line">   	<span class="variable">$&#123;array[0] &#125;</span> , <span class="variable">$&#123;array[1] &#125;</span>,<span class="variable">$&#123;array[2] &#125;</span>,<span class="variable">$&#123;array[3] &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 如果域中存的是集合</span><br><span class="line">	使用EL表达式取出作用域中集合的值：</span><br><span class="line">	<span class="variable">$&#123;li[0] &#125;</span> , <span class="variable">$&#123;li[1] &#125;</span>,<span class="variable">$&#123;li[2] &#125;</span>,<span class="variable">$&#123;li[3] &#125;</span></span><br><span class="line"></span><br><span class="line">4. 取出Map集合的值</span><br><span class="line">	&lt;br&gt;-------------Map数据----------------&lt;br&gt;</span><br><span class="line">  	&lt;%</span><br><span class="line">   		Map map = new HashMap();</span><br><span class="line">   		map.put(<span class="string">"name"</span>, <span class="string">"zhangsna"</span>);</span><br><span class="line">   		map.put(<span class="string">"age"</span>,18);</span><br><span class="line">   		map.put(<span class="string">"address"</span>,<span class="string">"北京.."</span>);</span><br><span class="line">   		map.put(<span class="string">"address.aa"</span>,<span class="string">"深圳.."</span>);</span><br><span class="line">   		pageContext.setAttribute(<span class="string">"map"</span>, map);</span><br><span class="line">   	%&gt;</span><br><span class="line">   	</span><br><span class="line">   	使用EL表达式取出作用域中Map的值：</span><br><span class="line">   	<span class="variable">$&#123;map.name &#125;</span> , <span class="variable">$&#123;map.age &#125;</span> , <span class="variable">$&#123;map.address &#125;</span>  , <span class="variable">$&#123;map["address.aa"] &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="取值细节"><a href="#取值细节" class="headerlink" title="取值细节"></a>取值细节</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.  从域中取值。  得先存值。</span><br><span class="line"></span><br><span class="line">  &lt;%  //pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">      session.setAttribute(<span class="string">"name"</span>, <span class="string">"lisi..."</span>);  %&gt;</span><br><span class="line">  </span><br><span class="line">   直接指定说了，到这个作用域里面去找这个name</span><br><span class="line">   <span class="variable">$&#123; pageScope.name &#125;</span> </span><br><span class="line"></span><br><span class="line">   //先从page里面找，没有去request找，去session，去application </span><br><span class="line">   <span class="variable">$&#123; name &#125;</span></span><br><span class="line"></span><br><span class="line">   指定从session中取值</span><br><span class="line">   <span class="variable">$&#123; sessionScope.name &#125;</span>  </span><br><span class="line"></span><br><span class="line">2. 取值方式</span><br><span class="line"></span><br><span class="line">- 如果这份值是有下标的，那么直接使用[]</span><br><span class="line">	&lt;%	String [] array = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;</span><br><span class="line">		session.setAttribute(<span class="string">"array"</span>,array);  %&gt;</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$&#123; array[1] &#125;</span> --&gt; 这里array说的是attribute的name </span><br><span class="line"></span><br><span class="line">- 如果没有下标， 直接使用 .的方式去取</span><br><span class="line">	&lt;%	User user = new User(<span class="string">"zhangsan"</span>,18);</span><br><span class="line">		session.setAttribute(<span class="string">"u"</span>, user);  %&gt;</span><br><span class="line">		</span><br><span class="line">	<span class="variable">$&#123; u.name &#125;</span>  , <span class="variable">$&#123; u.age &#125;</span> </span><br><span class="line"></span><br><span class="line">3. 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。</span><br></pre></td></tr></table></figure>
<h3 id="EL表达式-的11个内置（隐式）对象"><a href="#EL表达式-的11个内置（隐式）对象" class="headerlink" title="EL表达式 的11个内置（隐式）对象"></a>EL表达式 的11个内置（隐式）对象</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">内置对象：已经存在，不用创建，可以直接获取成员变量或者属性</span><br><span class="line">	用法：<span class="variable">$&#123; 对象名.成员 &#125;</span></span><br><span class="line"></span><br><span class="line">JSP相关对象</span><br><span class="line">- pageContext </span><br><span class="line"></span><br><span class="line">作用域相关对象（用的比较多）</span><br><span class="line">- pageScope</span><br><span class="line">- requestScope</span><br><span class="line">- sessionScope</span><br><span class="line">- applicationScope</span><br><span class="line"></span><br><span class="line">请求头信息相关对象</span><br><span class="line">- header</span><br><span class="line">- headerValues</span><br><span class="line"></span><br><span class="line">请求参数信息相关对象</span><br><span class="line">- param</span><br><span class="line">- paramValues</span><br><span class="line"></span><br><span class="line">Cookie</span><br><span class="line">- cookie</span><br><span class="line"></span><br><span class="line">全局初始化参数</span><br><span class="line">- initParam</span><br></pre></td></tr></table></figure>

<h1 id="三、-JSTL（标准标签库）"><a href="#三、-JSTL（标准标签库）" class="headerlink" title="三、 JSTL（标准标签库）"></a>三、 JSTL（标准标签库）</h1><ul>
<li>全称 ： JSP Standard Tag Library  ： jsp标准标签库</li>
<li>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</li>
</ul>
<h2 id="JSTL使用"><a href="#JSTL使用" class="headerlink" title="JSTL使用"></a>JSTL使用</h2><ol>
<li>导入jar文件到工程的WebContent/Web-Inf/lib    jstl.jar和standard.jar</li>
<li>在jsp页面上，使用taglib 指令，来引入标签库</li>
<li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;c:<span class="built_in">set</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">""</span>&gt;&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:forEach&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. c:<span class="built_in">set</span></span><br><span class="line">		&lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt;</span><br><span class="line">		&lt;c:<span class="built_in">set</span> var=<span class="string">"name"</span> value=<span class="string">"zhangsan"</span> scope=<span class="string">"session"</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">		</span><br><span class="line">		<span class="variable">$&#123;sessionScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. c:<span class="keyword">if</span></span><br><span class="line"> 判断<span class="built_in">test</span>里面的表达式是否满足，如果满足，就执行c:<span class="keyword">if</span>标签中的输出 ， c:<span class="keyword">if</span> 是没有<span class="keyword">else</span>的。 </span><br><span class="line">		&lt;c:<span class="built_in">set</span> var=<span class="string">"age"</span> value=<span class="string">"18"</span> &gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">		&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span>&gt;</span><br><span class="line">			年龄大于了26岁...</span><br><span class="line">		&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">		&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &lt;= 26 &#125;</span>"</span>&gt;</span><br><span class="line">			年龄小于了26岁...</span><br><span class="line">		&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		------------------------------</span><br><span class="line"></span><br><span class="line">		定义一个变量名 flag  去接收前面表达式的值，然后存在session域中</span><br><span class="line"></span><br><span class="line">		&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span> var=<span class="string">"flag"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">			年龄大于了26岁...</span><br><span class="line">		&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. c:forEach</span><br><span class="line">	从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， </span><br><span class="line">	&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"10"</span> var=<span class="string">"i"</span> step=<span class="string">"2"</span>&gt;</span><br><span class="line">		<span class="variable">$&#123;i &#125;</span></span><br><span class="line">	&lt;/c:forEach&gt;</span><br><span class="line">	-----------------------------------------------</span><br><span class="line"></span><br><span class="line">	&lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 </span><br><span class="line">	var: 遍历出来的每一个元素用user 去接收。 --&gt;</span><br><span class="line">	&lt;c:forEach var=<span class="string">"user"</span> items=<span class="string">"<span class="variable">$&#123;list &#125;</span>"</span>&gt;</span><br><span class="line">		<span class="variable">$&#123;user.name &#125;</span> ----<span class="variable">$&#123;user.age &#125;</span></span><br><span class="line">	&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---CPU调度</title>
    <url>/789539749/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机的三大核心部件：CPU，存储器，I/O设备，其中CPU作为操作系统的运算和控制核心，是信息处理、程序运行的最终执行单元，起到了大脑的作用。CPU又包括两部分：控制器、运算器。众所周知，在某一个时间段，CPU只能被一个进程占用，这篇文章就认识一下CPU的调度策略。</p>
<a id="more"></a>
<h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><ul>
<li>我们所做的多进程，多线程，多道程序设计，批处理等等一些操作的目的就是为了最大化cpu的利用率。</li>
<li>用一会cpu，等待一会IO，循环往复，交替执行（通过IO获得数据，再通过CPU对数据进行处理，在通过IO将结果输出）</li>
<li>通过考虑CPU和IO的占用，我们还可以将进程划分为两大类：<br>①：CPU绑定进程（对CPU使用的比较多，很少量的时间使用IO）<br>②：IO绑定进程（与之相反）</li>
<li>调度：队列里面有好多个进程，选择哪一个去运行，决定下一个是谁。<br>①抢占式：（被动的）<br>②非抢占式：（自愿让出CPU）</li>
<li>CPU的利用率：占了百分之多少，越多越好。</li>
<li>吞吐率：单位时间内完成了多少进程。越多，效率越高。</li>
<li>周转时间：一个进程从创建到结束，一共用了多少时间。</li>
<li>等待时间：一个进程在等待状态多长时间，这个时间越短越好。</li>
<li>响应时间：正在等待的进程，对已经发生的事件，的响应速度，越快越好。</li>
</ul>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><ul>
<li>但是看得不是单个进程的性能指标，看得是所有进程加在一起，算出来的平均周转时间，平均等待时间，平均响应时间。才能看出调度能力。</li>
<li><strong>最短作业优先（SJF）</strong> ：谁运行时间最短谁来使用CPU。</li>
<li><strong>最短剩余时间优先：</strong> 不看他以前运行了多久，只看他剩下多少时间。</li>
<li>上面这两种调度策略是在已知需要在CPU上运行多少时间的情况，但是这个运行时间未知呢？调度最有效的依据是进程将来在CPU上消耗的时间，并期望用时最短的进程最优先执行。</li>
<li><strong>预测未来：</strong> 基于统计过去这个进程对CPU的使用情况来 预测。根据统计IO的时间多，还是使用CPU的时间多。</li>
<li><strong>先来先服务（FCFS）</strong> ：谁优先级高运行谁。会导致优先级低的进程饿死。</li>
<li><strong>时间片轮转算法（Round Robin）</strong> ：广泛采用，给定每个进程一个时间片，用完了就去等待。这个时候就要考虑时间片的设置大小。越合理越好。如果时间片太大，那么他就近似成了一个先来先服务算法。</li>
<li>将时间片轮转和优先级结合起来：时间片轮转就在就绪队列里选择优先级高的进程先运行。</li>
<li><strong>多级队列（Multilevel  Queue）</strong> ：把整个系统所有的进程放在好多个队列中，这个队列里面的进程优先级是一样的，调度的时候，就按着这个队列找。<br>①系统级队列（最高优先级）：系统进程要应对很关键的问题，它负责系统的中断处理的。（中断指令一定要及时响应，否则下一个中断进来了，就会丢失一个中断）<br>② 交互式的进程：属于IO绑定的进程，很少使用CPU，随时给用户一个反馈。响应速度必须得快。<br>③批处理进程：频繁使用CPU的进程。</li>
<li><strong>多级反馈队列（普遍采用）：</strong> 根据这个进程以前的行为的统计来预测以后怎么处置他，这个预测就是由反馈实现的。<br>①反馈怎么实现？：新来的进程首先设置他的优先级为最高，来根据他的行为，表现，来确定他的优先级，降级。<br>②只要长时间使用了CPU，就把你优先级降低，只要你做过一次IO操作，就把你优先级提一级，形成一个<strong>动态的变换</strong>。</li>
</ul>
<h2 id="多CPU调度"><a href="#多CPU调度" class="headerlink" title="多CPU调度"></a>多CPU调度</h2><ul>
<li>多核，重核。每一个内核在任意时刻只能运行一个进程。未来可能会出现128核，实际上，会有备用的核，因为出厂的时候，也许会有坏核，备用核就顶上。</li>
<li>特别之处：调度问题的复杂度增加了，如何去做负载均衡（比如说一个CPU太忙，一个CPU太闲,那这样多核就没有意义了）。</li>
<li>同构（CPU完全一样的）<br>①非对称式的多处理器管理（现阶段用不到）：（每个内核的作用是不同的）让一个内核只运行操作系统，其他的内核只运行应用程序。好处：对操作系统简单多了，只用管理自己的内核。<br>②对称式的多处理器管理：所有的处理机都是完全平等的，每个内核既运行操作系统，也运行应用程序，完全由繁忙程度来决定。每一个处理器都有私有的队列。</li>
<li>异构（CPU有不同之处，特别复杂，基本上用不到）</li>
<li>负载均衡：通过迁移进程来实现，会产生cache刷新，但是利大于弊。</li>
</ul>
<h2 id="操作系统是如何实现多级反馈的"><a href="#操作系统是如何实现多级反馈的" class="headerlink" title="操作系统是如何实现多级反馈的"></a>操作系统是如何实现多级反馈的</h2><ul>
<li>太难了，不想了解！！！</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC学习</title>
    <url>/473128650/</url>
    <content><![CDATA[<p>如何使用JDBC连接到数据库</p>
<a id="more"></a>
<h2 id="一、添加JDBC驱动包"><a href="#一、添加JDBC驱动包" class="headerlink" title="一、添加JDBC驱动包"></a>一、添加JDBC驱动包</h2><p><img src="https://img-blog.csdnimg.cn/2020022310204253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200223102114577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020022310240148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="二、使用JDBC简单步骤"><a href="#二、使用JDBC简单步骤" class="headerlink" title="二、使用JDBC简单步骤"></a>二、使用JDBC简单步骤</h2><ul>
<li>1、注册驱动`</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br></pre></td></tr></table></figure>
<ul>
<li>2、建立连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn=(Connection) DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/数据库名"</span>, <span class="string">"root"</span>, <span class="string">"daq"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>3、创建statement—-跟数据库打交道，一定需要这个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">st = conn.createStatement();</span><br></pre></td></tr></table></figure>
<ul>
<li>4、执行sql 查询，得到结果集ResultSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select * from t_stu"</span>;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure>
<ul>
<li>5、遍历查询每一条记录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">		<span class="keyword">int</span> id=rs.getInt(<span class="string">"cid"</span>);</span><br><span class="line">		String name =rs.getString(<span class="string">"cname"</span>);</span><br><span class="line">		String desc =rs.getString(<span class="string">"cdesc"</span>);</span><br><span class="line">				</span><br><span class="line">		System.out.println(<span class="string">"cid"</span>+id +<span class="string">"cname"</span>+name +<span class="string">"cdesc"</span>+desc);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6、关闭，释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">新建一个包放置适房资源的工具类，在JDBC释放资源时调用即可</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@deprecated</span> 释放资源</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(ResultSet rs,Statement st,Connection conn)</span></span>&#123;</span><br><span class="line">		closeRs(rs);</span><br><span class="line">		closeSt(st);</span><br><span class="line">		closeConn(conn);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			rs=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSt</span><span class="params">(Statement st)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">				st.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			st=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConn</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			conn=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、JDBC工具类（修改原有代码）"><a href="#三、JDBC工具类（修改原有代码）" class="headerlink" title="三、JDBC工具类（修改原有代码）"></a>三、JDBC工具类（修改原有代码）</h2><ul>
<li>查看源代码，有一段静态代码块（类加载的时候就会执行），所以等同于说注册了两次驱动，其实驱动只需要注册一次就够了。</li>
<li><strong>1、注册驱动（防止二次注册）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">改成以下代码即可</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">引号里面是Driver的全路径</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>2、在工具类中加方法getconn（）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String url=<span class="string">"jdbc:mysql://localhost/daq"</span>;</span><br><span class="line"><span class="keyword">static</span> String name=<span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> String password=<span class="string">"daq"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getconn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		<span class="comment">// 2.建立连接</span></span><br><span class="line">		conn = (Connection) DriverManager.getConnection(</span><br><span class="line">				url, name, password);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用properties配置文件</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.创建properties</span><br><span class="line">	在src下面新建一个**jdbc.properties** 文件</span><br><span class="line">	写入：</span><br><span class="line">	driverClass=com.mysql.jdbc.Driver</span><br><span class="line">	url=jdbc:mysql:<span class="comment">//localhost/daq</span></span><br><span class="line">	name=root</span><br><span class="line">	password=daq</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>.读取properties</span><br><span class="line">	在JDBCUtil工具类中添加静态代码块，保证工具类一加载，就可以读取配置文件。</span><br><span class="line">	<span class="keyword">static</span> String driverClass = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> String name = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.创建一个属性配置对象</span></span><br><span class="line">			Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">			InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">			<span class="comment">// 导入输入流</span></span><br><span class="line">			properties.load(is);</span><br><span class="line">			<span class="comment">// 读取属性</span></span><br><span class="line">			driverClass =properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">			url =properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">			name =properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">			password =properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、JDBC的CRUD"><a href="#四、JDBC的CRUD" class="headerlink" title="四、JDBC的CRUD"></a>四、JDBC的CRUD</h2><p><img src="https://img-blog.csdnimg.cn/20200223163750100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>insert（插入）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">INSERT INTO t_stu <span class="title">VALUES</span> <span class="params">(NULL,<span class="string">'wangqiang2'</span>,<span class="number">28</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">		<span class="comment">// 1. 获取连接对象</span></span></span><br><span class="line"><span class="function">			conn </span>= JDBCUtil.getconn();</span><br><span class="line">			<span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//3. 执行添加</span></span><br><span class="line">			String sql = <span class="string">"insert into t_stu values(null , 'aobama' , 59)"</span>;</span><br><span class="line">			<span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line">			<span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">				System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>delete（删除）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DELETE FROM t_stu WHERE id = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 获取连接对象</span></span><br><span class="line">		conn = JDBCUtil.getConn();</span><br><span class="line">		<span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">		st = conn.createStatement();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3. 执行添加</span></span><br><span class="line">		String sql = <span class="string">"delete from stu where name='XXX'"</span>;</span><br><span class="line">		<span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line">		<span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">			System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>query（查询）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_stu</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 1. 获取连接对象</span></span><br><span class="line">			conn = JDBCUtil.getConn();</span><br><span class="line">			<span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 3. 执行sql语句，返回ResultSet</span></span><br><span class="line">			String sql = <span class="string">"select * from stu"</span>;</span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 4. 遍历结果集</span></span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">				<span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">	</span><br><span class="line">				System.out.println(name + <span class="string">"   "</span> + age);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>update（更新）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UPDATE t_stu SET age = <span class="number">38</span> WHERE id = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 1. 获取连接对象</span></span><br><span class="line">			conn = JDBCUtil.getConn();</span><br><span class="line">			<span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//3. 执行添加</span></span><br><span class="line">			String sql = <span class="string">"update t_stu set age = 26 where name ='qyq'"</span>;</span><br><span class="line">			<span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line">			<span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">				System.out.println(<span class="string">"更新成功"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>补充：单元测试junit</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 定义一个类， TestXXX , 里面定义方法 testXXX.</span><br><span class="line"></span><br><span class="line">- 添加junit的支持。 </span><br><span class="line"></span><br><span class="line">  	右键工程 --- add Library --- Junit --- Junit4</span><br><span class="line"></span><br><span class="line">- 在方法的上面加上注解 ， 其实就是一个标记。</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@Test</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		...</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">- 光标选中方法名字，然后右键执行单元测试。  或者是打开outline视图， 然后选择方法右键执行。</span><br></pre></td></tr></table></figure>
<h2 id="五、DAO模式"><a href="#五、DAO模式" class="headerlink" title="五、DAO模式"></a>五、DAO模式</h2><ul>
<li><strong>Data Access Object 数据访问对象</strong></li>
</ul>
<p> <img src="https://img-blog.csdnimg.cn/20200223175345761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>1、新建一个dao的接口， 里面声明数据库访问规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义操作数据库的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询所有</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、新建一个dao的实现类，具体实现早前定义的规则</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Connection conn = <span class="keyword">null</span>;</span><br><span class="line">			Statement st = <span class="keyword">null</span>;</span><br><span class="line">			ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//1. 获取连接对象</span></span><br><span class="line">				conn = JDBCUtil.getConn();</span><br><span class="line">				<span class="comment">//2. 创建statement对象</span></span><br><span class="line">				st = conn.createStatement();</span><br><span class="line">				String sql = <span class="string">"select * from t_user"</span>;</span><br><span class="line">				rs = st.executeQuery(sql);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">					String userName = rs.getString(<span class="string">"username"</span>);</span><br><span class="line">					String password = rs.getString(<span class="string">"password"</span>);</span><br><span class="line">					</span><br><span class="line">					System.out.println(userName+<span class="string">"="</span>+password);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				JDBCUtil.release(conn, st, rs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接使用实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">	UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">	dao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、JDBC-Statement安全问题"><a href="#六、JDBC-Statement安全问题" class="headerlink" title="六、JDBC Statement安全问题"></a>六、JDBC Statement安全问题</h2><ul>
<li>Statement执行 ，其实是拼接sql语句的。  先拼接sql语句，然后在一起执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select * from t_user where username='"</span>+ username  +<span class="string">"' and password='"</span>+ password +<span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">	UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">	dao.login(<span class="string">"admin"</span>, <span class="string">"100234khsdf88' or '1=1"</span>);</span><br><span class="line">	</span><br><span class="line">	SELECT * FROM t_user WHERE username=<span class="string">'admin'</span> AND PASSWORD=<span class="string">'100234khsdf88'</span> or <span class="string">'1=1'</span> </span><br><span class="line">	</span><br><span class="line">	前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 </span><br><span class="line">	rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure>
<h2 id="七、PreparStatement-CRUD"><a href="#七、PreparStatement-CRUD" class="headerlink" title="七、PreparStatement  CRUD"></a>七、PreparStatement  CRUD</h2><ul>
<li>该对象就是替换前面的statement对象。</li>
<li>相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"insert into t_user values(null , ? , ?)"</span>;</span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">			 </span><br><span class="line">		<span class="comment">//给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。</span></span><br><span class="line">		ps.setString(<span class="number">1</span>, userName);</span><br><span class="line">		ps.setString(<span class="number">2</span>, password);</span><br></pre></td></tr></table></figure>
<ul>
<li>PreparStatement的添加，删除，更新，</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC,MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE---反射</title>
    <url>/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射就像是一面镜子，这面镜子其实就是JVM，他能照出你的类的所有属性和方法，也能调用你所有对象的属性和方法，<strong>crazy~</strong></p>
<a id="more"></a>
<h1 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h1><ul>
<li>先说<strong>正</strong>是怎么一回事。我要使用某个类，我必须要知道它是什么类，有何作用？用的时候，要先实例化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化一个对象，实例化的过程牵扯太多，不赘述</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Studnt();</span><br><span class="line">Class c1 = stu.getClass();</span><br><span class="line">System.out.println(c1.getName());</span><br></pre></td></tr></table></figure>
<ul>
<li>上面这个Student类，JVM在加载的时候这个类的时候，其实会在JAVA堆中创建一个<code>java.lang.class类</code>的对象，就是上面的<code>c1</code>，这个class对象代表类的相关信息。可以使用这个对象的一些方法来获取类的相关信息，这里也体现出了<strong>万物皆对象</strong>的理念，连类都是对象。</li>
<li>看看class类，这还只是一小部分方法，跟类相关的都可以在Class类中找到。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/202004181940283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>那说了这么多，反射到底是什么呢？</li>
</ul>
<p>我的理解：在运行状态中，可以知道任意一个类的属性和方法，也可以调用任意一个对象的属性和方法，也就是动态获取信息，动态获取对象方法和属性，然而这些底层的实现细节都被屏蔽了，只留下API库给我们使用，也就是<code>java.lang.reflect</code>类库，这些API学习并不难，难在理解反射这个概念，由于实现细节都被屏蔽了，我们也就很少写到反射的代码。</p>
<h1 id="反射有什么意义？"><a href="#反射有什么意义？" class="headerlink" title="反射有什么意义？"></a>反射有什么意义？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我直接<code>new</code>出来一个对象不就可以了，为什么用反射，要兜个大圈子？其实出去这些浅显表面的，反射真正的意义在于提高程序的灵活性，屏蔽底层实现细节，便于使用。</p>
<h1 id="反射如何使用？"><a href="#反射如何使用？" class="headerlink" title="反射如何使用？"></a>反射如何使用？</h1><p>这个在使用的时候直接查API即可，常用的有以下几种。</p>
<ul>
<li>通过一个对象获得完整的包名和类名。</li>
<li>实例化Class对象。</li>
<li>获取一个对象的父类与实现的接口。</li>
<li>获取某个类的全部构造函数。</li>
<li>通过反射机制实例化一个对象。</li>
<li>获取某个类的全部属性</li>
<li>获取某个类的全部方法</li>
</ul>
<h1 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h1><ul>
<li>JDBC（连接数据库与后端的桥梁），这其中就牵扯到一个连接的问题，我们将数据库的连接信息（用户名，用户密码，库名…）写在配置文件里，而不是写在代码里，为什么？因为这样我们更换数据库的时候，只需要改配置信息，而不是去改代码。而这里的由配置文件到代码，就是由反射来加载驱动的。</li>
<li>Spring MVC，学<code>servlet</code>的时候各种<code>getParameter()</code>获取信息，但是在SpringMVC框架中只需要在<code>javaBean</code>中约定好字段名，就可以把值填充进去。这就是反射的好处。</li>
<li>Spring，这个我学的还不多，但是涉及到一个自动组装的问题，只要字段名的顺序是约定一致的，就可使实现自动组装的效果，就像一个萝卜一个坑一样。如果顺序颠倒，可能在你想象中组装出来的是超跑，但是现实却是拖拉机。</li>
<li>Java的反射用的最多的地方就是在框架里面。比如说有两个程序员，他们各自创建了两个类，第一个程序员现在需要第二个程序员创建的类，可是现在第二个程序员创建的类还没有完成。那么第一个程序员编译自然不成功，但是现在第一个程序员又要使用第二个程序员的类，这个时候，反射就可以完成这个任务。因为反射是在类运行的时候获取对象的各个信息，所以第一个程序员的类就可以完成编译了。</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE基础知识</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE---集合</title>
    <url>/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要用集合？因为以前用数组存储数据，因为创建数组的时候就要初始化数组的长度，由于这个长度是不可变的，这就导致两个问题：定义数组长度值太大，实际用不了那么多，就会造成内存的浪费，那定义的太小了，不够用了又得扩容，这就得不偿失了，所以这个时候，集合横空出世，相当于一个没有上限的盒子，数据直接丢进去。</p>
<a id="more"></a>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><img src="https://img-blog.csdnimg.cn/20200415200516371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="它有什么好处？"><a href="#它有什么好处？" class="headerlink" title="它有什么好处？"></a>它有什么好处？</h2><ul>
<li>集合包括了各种常用的数据结构：List表，Set集合，Map映射等等。</li>
<li>封装成了一个工具类，使用者不必了解底层实现，方便使用。</li>
<li>从JavaSE5.0，使用了泛型，这样集合中对象的数据类型就可以被记住，使用者不用担心，把对象丢进集合中，就丢失了他的数据类型。</li>
</ul>
<h2 id="特点在哪里？"><a href="#特点在哪里？" class="headerlink" title="特点在哪里？"></a>特点在哪里？</h2><p><img src="https://img-blog.csdnimg.cn/20200415120759134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>java集合框架采用接口与实现相分离（就是面向接口编程的理念）。图中最底层的都是实现类，其他的都是接口，实现了接口中的方法，可以直接拿来用</li>
<li>java的集合中只能存储对象，而不能存储基本数据类型。</li>
<li>根据Colletion和Map框架，可以将集合分为三大类：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="right"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">list集合</td>
<td align="right">有序集合</td>
<td align="center">元素可以重复</td>
</tr>
<tr>
<td align="center">set集合</td>
<td align="right">无序集合</td>
<td align="center">元素不可以重复</td>
</tr>
<tr>
<td align="center">Map集合</td>
<td align="right">键值对集合</td>
<td align="center">key是无序集合Set，value是有序集合List</td>
</tr>
</tbody></table>
<h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><ul>
<li>通过分析源码，可以看到collection集合继承了Iterable接口，这里注意是Iterable而不是Iterator。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415140320803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><ul>
<li><p><code>Iterator iterator()</code>方法是<code>Collection</code>从<code>Iterable</code>(可迭代的)接口继承下来，用于返回一个<code>Iterator</code>对象，<code>Iterator</code>也是接口，而且是集合框架的成员，他的作用不是用来存放对象，而是遍历集合中的元素，所以称之为迭代器。</p>
</li>
<li><p><strong>使用迭代器的好处：</strong><br>迭代模式是访问集合类的通用方法，只要集合类实现了Iterator接口，就可以用迭代的方式来访问集合类内部的数据，Iterator访问方式把对不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。 <code>Iterator接口屏蔽了迭代的底层实现，向用户提供了遍历Collection的统一接口</code>。</p>
</li>
<li><p><strong>为什么会有迭代器？</strong><br>如果没有使用Iterator，遍历一个数组的方法是使用索引，这种方法的缺点就是事先必须知道集合的数据结构，而且当我换了一种集合的话代码不可重用，要修改，比如我用set，就不能通过索引来遍历了。访问代码和集合是紧耦合，无法将访问逻辑从集合类和客户端代码中剥离出来，每一种集合类对应一种访问方式，代码不可重用。 </p>
</li>
<li><p>为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合， 每一种集合类返回的Iterator具体类型可能不同，Array可能返回ArrayIterator，Set可能返回SetIterator，Tree 可能返回TreeIterator，但是它们都实现了Iterator接口，因此，客户端不关心到底是哪种Iterator，它只需要获得这个 Iterator接口即可，<code>这就是面向对象的威力。 针对抽象编程的原则：对具体类的依赖性最小。</code></p>
</li>
<li><p>查看Iterable接口源码：可以看到有iterator这个方法，还有一个forEach（）方法，也就是我们所说的增强for循环，这也是javaSE5.0以后，for循环一种优雅的写法。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415140947956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>如上面所看到的，iterable接口里面，还有一个Iterator接口，点进去是这样的：这里面的方法就是日常所用到的：hasNext()，next()，remove()方法。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415140954694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>iterator迭代器怎么用？<br>说到底，迭代器的最大作用就是遍历集合。但是他可以在遍历的时候删除元素。注意使用的<code>remove()</code>方法是<code>Iterator</code>的，而不是<code>Collection</code>的。有<code>remove()</code>必有<code>next()</code>在前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//向ArrayList中添加元素</span></span><br><span class="line">c.add(<span class="string">"DAQ"</span>);</span><br><span class="line">c.add(<span class="string">"LOVE"</span>);</span><br><span class="line">c.add(<span class="string">"WT"</span>);</span><br><span class="line"><span class="comment">//获取到迭代器</span></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	String element=(String)it.next();</span><br><span class="line">	System.Out.Println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><ul>
<li>List是线性表结构，包括顺序表Arraylist和链表LinkedList两种实现方式</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415144430273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><ul>
<li>底层数据结构是数组，线程不安全可以存放null值。因为它有扩容这一概念，可以实现动态增长，就不像原本的数组那样，长度固定不变了。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415144549588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041514401449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>ArrayList是基于动态数组实现的，在增删的时候，需要数组的拷贝复制。</li>
<li>ArrayList的默认容量是10，每次扩容的时候，变为原来的1.5倍，也就是15</li>
<li>删除元素的时候，容量不会减少，需要减少容量的时候，要调用trimToSize（）方法。</li>
<li>缺点：</li>
</ul>
<ol>
<li>从空间分配来看，除非预知数据的确切量或者近似值，否则频繁的扩容，或者大的容量初始值都会导致时间空间的浪费。</li>
<li>从运算时间来看，插入和删除的效率非常低。<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3></li>
</ol>
<ul>
<li>底层数据结构是双向链表，采用<strong>“按需分配”</strong>的原则为每个对象分配独立的存储空间，但是线程不安全。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415150446850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>LinkedList还实现了Deque接口，我们就可以像操作栈和队列一样操作LinkedList了。</li>
<li>只要有了头结点，其他的数据都可以轻松获取。</li>
</ul>
<p><strong>总结：</strong> 增删多用LinkedList，查询多用ArrayList。</p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><ul>
<li><p>相比list集合而言，Set看起来清爽多了。<br><img src="https://img-blog.csdnimg.cn/20200415151103807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>Set实现类依赖添加对象的equals（）方法检查对象的唯一性，只要两个对象使用equals比较结果为true，set就会拒绝加入此对象（哪怕他们是不同的对象），只要两个对象使用equals比较结果为false，set就会接受加入此对象（哪怕他们是相同的对象），所以在使用set时，重点就要重写equals（）方法，制定正规的比较规则。</p>
</li>
</ul>
<h3 id="HsahSet"><a href="#HsahSet" class="headerlink" title="HsahSet"></a>HsahSet</h3><p><img src="https://img-blog.csdnimg.cn/20200415152822770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>可以看出HashSet就是封装了HashMap，操作HashSet实际上就是在操作HashMap</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415153157522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>总结下来就是：</li>
</ul>
<ol>
<li>实现了Set接口，底层实际是一个HashMap实例</li>
<li>不保证迭代顺序，允许元素为null</li>
<li>非同步</li>
<li>初始容量影响迭代性能</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><img src="https://img-blog.csdnimg.cn/202004151542258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200415154111297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>总结：</li>
</ul>
<ol>
<li>实现了NavigableSet接口，底层实际是一个TreeMap实例</li>
<li>可以实现排序功能</li>
<li>非同步</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ul>
<li>归纳：</li>
</ul>
<ol>
<li>迭代是有序的</li>
<li>允许为null</li>
<li>底层实际上是一个HashMap+双链表实例</li>
<li>非同步 </li>
<li>与hashset相比，性能稍微差一点，因为要维护双链表</li>
<li>初始容量与迭代无关，LinkedHashSet迭代的是双链表</li>
</ol>
<h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><ul>
<li>底层是数组，线程安全</li>
<li>从源码中看出，他给每个方法都加上了synchronized锁，这样很消耗性能。</li>
<li>而且Vector初始长度是10，超过这个长度的时候，翻倍增长。这就比ArrayList更加消耗内存。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415145828218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><ul>
<li>为什么需要map？<br>map在java模型中称为映射，只要知道键值，就可以获取数据值。将键映射到值的对象，一个映射不能包含重复的键，每个键只能映射到一个值。</li>
<li>Map与Collection的区别：</li>
</ul>
<ol>
<li>Map集合存储元素是成对出现的，Map的键是唯一的，值是可以重复的。</li>
<li>Collection集合存储元素是单独出现的，set是唯一，list是可重复的。</li>
<li>Map数据结构针对键有效，跟值无关</li>
<li>Collection数据结构针对元素有效</li>
</ol>
<ul>
<li>Map的功能</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020041519240490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>散列表工作原理</li>
</ul>
<ol>
<li>散列表根据每个对象计算出一个整数，称之为散列码。根据计算出来的散列码，保存在对应的位置上。</li>
<li>在java中，散列表用链表数组实现，每个链表称为桶。</li>
<li>很可能有很多元素算出来的hash值（散列码）相同，这就会存储在同一个位置上，这种情况就叫做哈希冲突（散列冲突）。</li>
<li>但也不可能无限制装下去，在JDK1.8中，桶满时，链表会变成平衡二叉树，也就是所说的红黑树。</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>在另一篇文章中我有单独将HashMap拿出来分析，并且分为了JDK1.7和JDK1.8时的HashMap的结构，<a href="http://daqwt.top/HashMap/">HashMap源码分析</a></li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><img src="https://img-blog.csdnimg.cn/20200415193829403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>根据源码前的注释可以得出总结:</li>
</ul>
<ol>
<li>TreeMap实现了NavigableMap接口，而NavigableMap接口继承SortedMap接口，这就导致TreeMap是有序的。</li>
<li>TreeMap底层是红黑树，时间复杂度是<code>log(n)</code></li>
<li>非同步的</li>
<li>使用Comparator和Comparable来比较Key是否相等，与排序的问题。</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE基础知识</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE---泛型</title>
    <url>/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JDK1.5，引进泛型这个概念。是指在创建对象或者调用方法的时候，再去明确类型。即参数化类型，简单来说，就是把类型当作一种参数来传递，只不过一般情况下参数写在（）中，而类型写在&lt;&gt;中。并且在&lt;&gt;中只能是引用类型。</p>
<a id="more"></a>
<h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><ul>
<li><strong>泛型本质：</strong> 在创建对象或者调用方法的时候，再去明确类型。</li>
<li><strong>引用类型（reference type）：</strong> 指向一个对象，而不是原始值，指向对象的变量是引用变量。在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。</li>
</ul>
<ul>
<li><p><strong>泛型的设计原则：</strong>  只要在编译时期没有出现警告，那么运行时期就不会出现<code>ClassCastException</code>异常。</p>
</li>
<li><p><strong>一些常用的泛型类型变量：</strong></p>
</li>
</ul>
<pre><code>E：元素（Element），多用于java集合框架
K：关键字（Key）
N：数字（Number）
T：类型（Type）
V：值（Value）</code></pre><h2 id="泛型对比测试"><a href="#泛型对比测试" class="headerlink" title="泛型对比测试"></a>泛型对比测试</h2><ul>
<li>首先来看不加泛型的情况下，在list集合中添加不同类型的数据，并且在遍历的时候强转，编译的时候注定会报<code>ClassCastException</code>异常的。这就是由于集合中元素类型不统一造成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//添加一个String类型的元素</span></span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line"><span class="comment">//添加一个Integer类型的元素</span></span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">	<span class="comment">//都强转成String类型</span></span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加上泛型之后的，就规定了，这个集合中只能装这个类型的元素，要是装别的，在敲代码的时候就会报错，因为你加入的元素，跟规定的类型不一致，不让你加。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="为什么要使用泛型？"><a href="#为什么要使用泛型？" class="headerlink" title="为什么要使用泛型？"></a>为什么要使用泛型？</h2><ul>
<li>早期用Object来代替任意类型，但是这样做，有的时候就要进行向下强转，这样做不太安全。</li>
<li>没有泛型的话，像<code>Collection</code>，<code>Map</code>这种不限制元素类型的集合，你可以往里面丟任何元素，并且不会报语法错误，但是集合不知道这个元素是什么类型的，默认都是<code>Object</code>类型，等你取出来的时候，就给你返<code>Object</code>类型的，可谓乱丢一时爽，<code>get</code>火葬场。</li>
<li>有了泛型呢，就不用强制转换了，因为你在事先就规定好了，这个集合中装什么类型的元素，使代码更加简洁。程序也更加健壮（这才是猛男该做得事），因为只要编译没有警告，那么运行的时候就不会出现<code>ClassCastException</code>异常了。</li>
</ul>
<h2 id="使用泛型有什么好处？"><a href="#使用泛型有什么好处？" class="headerlink" title="使用泛型有什么好处？"></a>使用泛型有什么好处？</h2><ul>
<li>上面通过对比已经看出，泛型有哪些好处，这里在总结一下。<br>①代码更简洁<br>②程序更健壮<br>③可读性和稳定性<br>④配合增强for循环遍历集合</li>
</ul>
<h2 id="怎么使用泛型？"><a href="#怎么使用泛型？" class="headerlink" title="怎么使用泛型？"></a>怎么使用泛型？</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul>
<li>把泛型定义在类上，也可以定义在方法上，在使用该类或者方法的时候，才根据自己的需要，将类型明确下来。<strong>注意：</strong> <strong>类上声明的泛型，只对非静态成员有效。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.定义</span><br><span class="line"><span class="comment">//把泛型定义在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTool</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> object;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T object)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.object=object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>.使用</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）&#123;</span><br><span class="line">	<span class="comment">//创建对象，并指定其元素类型(这里是String型)</span></span><br><span class="line">	ObjectTool&lt;String&gt; tool1 = <span class="keyword">new</span> ObjectTool&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	tool1.setObj(<span class="keyword">new</span> String(<span class="string">"张三"</span>));</span><br><span class="line">	String s=tool.getObj();</span><br><span class="line">	System.Out.println(s);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建对象，并指定其元素类型(这里是Integer型)</span></span><br><span class="line">	ObjectTool&lt;Integer&gt; tool2 = <span class="keyword">new</span> ObjectTool&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	tool2.setObj(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">int</span> i=tool2.getObj();</span><br><span class="line">	System.Out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li>如果外界仅仅对一个方法感兴趣，而不关心类中的其他属性，那么将泛型定义在类上就有些小题大做，这里直接定义在方法上，精准打击！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.定义泛型方法</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">	System.Out.println(t);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>.泛型方法的使用</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建对象</span></span><br><span class="line">	ObjectTool obj = <span class="keyword">new</span> ObjectTool();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用方法，传进来什么类型，返回值就是什么类型</span></span><br><span class="line">	obj.show(<span class="string">"hello"</span>);</span><br><span class="line">	obj.show(<span class="number">4</span>);</span><br><span class="line">	obj.show(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类派生出的子类"><a href="#泛型类派生出的子类" class="headerlink" title="泛型类派生出的子类"></a>泛型类派生出的子类</h3><ul>
<li>换上马甲他还是王八，虽然加了泛型，但说到底，他还是个类，既然是个类，那么他就可以被继承。然而泛型类的继承也分两种。</li>
</ul>
<p>①<strong>子类明确泛型类的类型参数变量(泛型接口)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把泛型定义在接口上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类明确泛型类的类型参数变量:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②<strong>子类不明确泛型类的类型参数变量</strong></p>
<ul>
<li>此时，外界使用子类的时候，也需要传递类型参数变量进来，在实现类上需要定义出类型参数变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现类要定义出&lt;T&gt;类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><ul>
<li><strong>问题：</strong> 方法接收一个集合参数，遍历集合并把集合元素打印出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通解决办法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">加类型通配符？</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>就加了一个问号？，能有什么作用<br>答案是：更优雅~</li>
<li>还有一个问题是设置通配符上限和下限。这个问题很绕，搞不清楚，当然，大多时候，使用泛型方法来替代通配符，条条大路通罗马嘛。</li>
<li><strong>注意：加了？就只能调用与对象无关的方法，不能调用对象与类型有关的方法。因为直到外界使用才知道具体的类型是什么。也就是说，在上面的List集合，是不能使用add()方法的。因为add()方法是把对象丢进集合中，而现在不知道对象的类型。</strong></li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul>
<li>因为泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即<strong>挡住向集合中插入非法数据</strong>。但编译器编译完带有泛形的java程序后，生成的class文件中将不再带有泛形信息，以此使程序运行效率不受到影响，这个过程称之为“泛型擦除”。这一点应用在兼容老版本上，因为JDK1.5之前没有泛型，当把带有泛型特性的集合赋值给老版本的集合时候，就会把泛型擦除掉，amazing！</li>
</ul>
<h2 id="应用场景有哪些？"><a href="#应用场景有哪些？" class="headerlink" title="应用场景有哪些？"></a>应用场景有哪些？</h2><ul>
<li><strong>场景一：</strong>最常用的还是应用于限制集合的参数类型。</li>
<li><strong>场景二：</strong>项目中，每次都要写好几个DAO，会显得臃肿。</li>
<li><strong>优化办法–抽象DAO：</strong> 在抽象DAO中，是不知道哪一个DAO会继承它，所以是不知道其具体的类型的。而泛型就是在创建的时候才指定其具体的类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">抽象DAO</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="keyword">private</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.getClass();  <span class="comment">//拿到的是子类</span></span><br><span class="line">        ParameterizedType  pt = (ParameterizedType) clazz.getGenericSuperclass(); </span><br><span class="line">         <span class="comment">//BaseDao&lt;Category&gt;</span></span><br><span class="line">        clazz = (Class) pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        session.save(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) session.get(clazz, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        session.update(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        T t = (T) session.get(clazz, id);</span><br><span class="line">        session.delete(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">继承抽象DAO</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Category</span>&gt; </span>&#123;</span><br><span class="line">	将抽象DAO中的方法继承了下来</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE基础知识</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP模式&amp;&amp;MVC模式</title>
    <url>/2199266903/</url>
    <content><![CDATA[<p>一个项目有一个好的设计模式很重要，有一个好的设计模式，使得开发和维护也变得简单。MVC是一种程序开发设计模式，他实现了显示模块与功能模块分离，提高了程序的可维护性，可移植性，可扩展性，可重用性，降低了程序的开发难度。</p>
<a id="more"></a>

<h2 id="JSP模式-amp-MVC模式"><a href="#JSP模式-amp-MVC模式" class="headerlink" title="JSP模式&amp;MVC模式"></a>JSP模式&amp;MVC模式</h2><ul>
<li>MVC=model（模型）+view（视图）+contorller（控制）</li>
<li>商城=仓库（模型）+店铺（视图），（控制）店铺去仓库拿货（取数据）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200323093038355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323093051579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>MVC工作机制</strong></li>
</ul>
<ol>
<li>用户操作，将指令送到Conntoller（控制器）。</li>
<li>控制器将指令和数据传递给业务模型（model）。</li>
<li>模型进行业务逻辑判断，数据库存取。</li>
<li>根据业务逻辑选择不的视图（View）展示给用户</li>
</ol>
<ul>
<li>MVC设计模式可以分为两种：闭环和开放，但是开放派中（controllor）的职责过重。下面是闭环的优点：</li>
</ul>
<ol>
<li>耦合性低，实现了用户显示模块与功能（业务逻辑）模块的分离</li>
<li>提高应用系统的可维护性，可扩展性，可维护性，以及模块功能的复用性。</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>对于简单的页面来说，会增加结构的复杂性，产生过多的更新操作，降低运行效率，而且使用的时候要精心计划，由于模型和视图严格分离，给调试程序带来了一定的困难。</li>
<li>不适合中小应用程序，设计比较麻烦，用在中小应用上，或者改造一些工具来适应MVC，也是得不偿失的！！  </li>
</ol>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql多表操作</title>
    <url>/1663071716/</url>
    <content><![CDATA[<p><strong>问：</strong> 分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系？</p>
<a id="more"></a>
<h1 id="创建多表及多表的关系"><a href="#创建多表及多表的关系" class="headerlink" title="创建多表及多表的关系"></a>创建多表及多表的关系</h1><p> <strong>问：</strong> 分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">  cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  cname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  cdesc <span class="built_in">varchar</span>(<span class="number">31</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品,黑马生产'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂倾情打造'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼,茅台,二锅头'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'娃哈哈,蒙牛酸酸乳'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'馋嘴零食'</span>,<span class="string">'瓜子花生,八宝粥,辣条'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">category</span>;</span><br><span class="line"><span class="keyword">select</span> cname,cdesc <span class="keyword">from</span> <span class="keyword">category</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--所有商品</span></span><br><span class="line">1.商品ID</span><br><span class="line">2.商品名称</span><br><span class="line">3.商品的价格</span><br><span class="line">4.生产日期</span><br><span class="line">5.商品分类ID</span><br><span class="line"></span><br><span class="line">商品和商品分类 : 所属关系</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">	pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  	pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  	price <span class="keyword">double</span>,</span><br><span class="line">  	pdate <span class="built_in">timestamp</span>,</span><br><span class="line">  	cno <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小米mix4'</span>,<span class="number">998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'锤子'</span>,<span class="number">2888</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'阿迪王'</span>,<span class="number">99</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'老村长'</span>,<span class="number">88</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'劲酒'</span>,<span class="number">35</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小熊饼干'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'卫龙辣条'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'旺旺大饼'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>多表之间的关系如何来维护</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">外键约束: foreign key</span><br><span class="line">	-给product中的cno 添加一个外键约束</span><br><span class="line">	 <span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span>(cno)  <span class="keyword">references</span>  <span class="keyword">category</span>(cid);</span><br><span class="line">	-从分类表中,删除分类为5信息</span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">where</span> cid =<span class="number">5</span>;  //删除失败,</span><br><span class="line">	首先得去product表, 删除所有分类ID5  商品</span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">from</span> product <span class="keyword">where</span> cno=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>建数据库原则:  <strong>通常情况下,一个项目/应用建一个数据库</strong></li>
<li>多表之间的建表原则</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. 一对多 : 商品和分类</span><br><span class="line">    建表原则: 在多的一方添加一个外键,指向一的一方的主键</span><br><span class="line"></span><br><span class="line">2.多对多: 老师和学生, 学生和课程</span><br><span class="line">    建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表。</span><br><span class="line"></span><br><span class="line">3.一对一: 班级和班长, 公民和身份证, 国家和国旗</span><br><span class="line">    建表原则:  </span><br><span class="line">      - 将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表</span><br><span class="line">      - 直接将两张表合并成一张表</span><br><span class="line">      - 将两张表的主键建立起连接,让两张表里面主键相等</span><br><span class="line"></span><br><span class="line">4.实际用途: 用的不是很多.    (拆表操作  )</span><br><span class="line">	如：相亲网站: </span><br><span class="line">        - 个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,  特长,学历, 职业, 择偶目标,要求)</span><br><span class="line">        - 拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿,</span><br></pre></td></tr></table></figure>
<h1 id="网上商城表案例分析：用户购物流程"><a href="#网上商城表案例分析：用户购物流程" class="headerlink" title="网上商城表案例分析：用户购物流程"></a>网上商城表案例分析：用户购物流程</h1><p><img src="https://img-blog.csdnimg.cn/20200221150553826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>商品分类表(分类ID,分类名称,分类描述</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">   	cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">     	cname <span class="built_in">varchar</span>(<span class="number">15</span>),</span><br><span class="line">     	cdesc <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品,黑马生产'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂倾情打造'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼,茅台,二锅头'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'娃哈哈,蒙牛酸酸乳'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'馋嘴零食'</span>,<span class="string">'瓜子花生,八宝粥,辣条'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>商品表 (商品ID, 商品名称,商品价格,外键cno)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">    	pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">      	pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">      	price <span class="keyword">double</span>,</span><br><span class="line">      	cno <span class="built_in">int</span>,</span><br><span class="line">      	<span class="keyword">foreign</span> <span class="keyword">key</span>(cno) <span class="keyword">references</span> <span class="keyword">category</span>(cid)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小米mix4'</span>,<span class="number">998</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'锤子'</span>,<span class="number">2888</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'阿迪王'</span>,<span class="number">99</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'老村长'</span>,<span class="number">88</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'劲酒'</span>,<span class="number">35</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小熊饼干'</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'卫龙辣条'</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'旺旺大饼'</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>用户表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">  	uid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    	username <span class="built_in">varchar</span>(<span class="number">31</span>),</span><br><span class="line">    	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">31</span>),</span><br><span class="line">    	phone  <span class="built_in">varchar</span>(<span class="number">11</span>)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="string">'123'</span>,<span class="string">'13811118888'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders(</span><br><span class="line">    	<span class="keyword">oid</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">      	<span class="keyword">sum</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">        otime <span class="built_in">timestamp</span>,</span><br><span class="line">      	address <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      	uno <span class="built_in">int</span>,</span><br><span class="line">      	<span class="keyword">foreign</span> <span class="keyword">key</span>(uno) <span class="keyword">references</span> <span class="keyword">user</span>(uid)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> orders <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">200</span>,<span class="literal">null</span>,<span class="string">'学校'</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> orders <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">250</span>,<span class="literal">null</span>,<span class="string">'家里'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>订单项: 中间表(订单ID,商品ID,商品数量,订单项总价)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orderitem(</span><br><span class="line"> 	ono <span class="built_in">int</span>,</span><br><span class="line">   	pno <span class="built_in">int</span>,</span><br><span class="line">   	<span class="keyword">foreign</span> <span class="keyword">key</span>(ono) <span class="keyword">references</span> orders(<span class="keyword">oid</span>),</span><br><span class="line">   	<span class="keyword">foreign</span> <span class="keyword">key</span>(pno) <span class="keyword">references</span> product(pid),</span><br><span class="line">   	ocount <span class="built_in">int</span>,</span><br><span class="line">   	subsum <span class="keyword">double</span></span><br><span class="line"> );</span><br><span class="line"> <span class="comment">--给1号订单添加商品 200块钱的商品</span></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">8</span>,<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">--给2号订单添加商品 250块钱的商品 ()</span></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">35</span>);</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内连接查询</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">-隐式内连接</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product p,<span class="keyword">category</span> c <span class="keyword">where</span> p.cno=c.cid;</span><br><span class="line">-显式内连接</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product p <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">category</span> c <span class="keyword">on</span> p.cno=c.cid;</span><br><span class="line">-区别：</span><br><span class="line">	隐式内连接：在查询出结果的基础上去做where 条件过滤</span><br><span class="line">	显式内连接：带着条件去查询结果，执行效率高。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>连接查询</strong><br>左外连接：会将左表中的所有数据都查询出来，如果右表中没有对应的数据，用NULL代替。<br>右外连接：会将右表中的所有数据查询出来如果左表没有对应数据的话<img src="https://img-blog.csdnimg.cn/20200221170140826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>分页查询</strong><br>每页数据数据3，起始索引从0 ，第1页: 0，第2页: 3。<br>起始索引:  index 代表显示第几页 页数从1开始，每页显示3条数据</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">startIndex  = (index-1)*3</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数是索引<br>第二个参数显示的个数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">3</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>子查询</strong></p>
<p>sql的嵌套：查询语句里面嵌套查询语句</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础操作</title>
    <url>/81592902/</url>
    <content><![CDATA[<p>本文简单介绍了数据库，和一些基本操作。</p>
<a id="more"></a>
<h1 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h1><ul>
<li>数据库就是一个文件系统，只不过我们需要通过SQL命令来操作这个文件系统。</li>
<li>数据库（DataBase）是按照数据结构来组织，存储和管理数据的建立在计算机存储设备上的仓库。</li>
<li>作用：存储数据，数据的仓库，带有访问权限，限制不同的人可以有不同的操作。</li>
<li>java EE操作的都是后台数据，取到后台数据进行封装，然后交给前端去展现。</li>
</ul>
<h1 id="有哪些数据库"><a href="#有哪些数据库" class="headerlink" title="有哪些数据库"></a>有哪些数据库</h1><ul>
<li>mysql：开源免费，适用于中小企业的免费数据库。</li>
<li>oracle：甲骨文公司，收费软件，适用于大型网站。</li>
<li>db2：IBM公司，做解决方案，软件和硬件，服务器架构，银行系统。</li>
<li>sqlserver：windows里，政府网站。asp.net  大学教学，图形化做得好。</li>
</ul>
<h1 id="Mysql的sql语句有哪些？"><a href="#Mysql的sql语句有哪些？" class="headerlink" title="Mysql的sql语句有哪些？"></a>Mysql的sql语句有哪些？</h1><ul>
<li>SQL(Structure Query Language)结构化查询语言</li>
<li>DDL数据定义语言：定义数据库，数据表他们的结构，create（创建），drop（删除），alert（修改）</li>
<li>DML数据操纵语言：主要用来操作数据，insert（插入），update（修改），delete（删除）</li>
<li>DCL数据控制语言：定义访问权限，取消访问权限，安全设置，grant</li>
<li>DQL数据查询语言：select（查询） from子句 where子句</li>
</ul>
<h1 id="数据库的CRUD操作-增删改查"><a href="#数据库的CRUD操作-增删改查" class="headerlink" title="数据库的CRUD操作(增删改查)"></a>数据库的CRUD操作(增删改查)</h1><ul>
<li>登录数据库服务器</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pdaq</span><br></pre></td></tr></table></figure>
<ul>
<li>创建数据库：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;//指定字符集</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020022018024091.png" alt="在这里插入图片描述"></p>
<ul>
<li>查看指定数据库：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改数据库的字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库的名字<span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure>
<ul>
<li>切换数据库（选中数据库）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库的名字;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前正在使用的数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure>
<h1 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h1><ul>
<li>创建表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名（列名 列的类型(长度) 约束，列名<span class="number">2</span> 列的类型(长度) 约束）;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">列的类型：</span><br><span class="line">java     sql</span><br><span class="line">int      int</span><br><span class="line">char     char（固定长度）</span><br><span class="line">String   varchar（可变长度）长度代表字符的个数</span><br><span class="line">         </span><br><span class="line">         text：主要用来存放文本</span><br><span class="line">         blob：存放的是二进制</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">列的约束：</span><br><span class="line">	主键约束：primary key</span><br><span class="line">	唯一约束：unique</span><br><span class="line">	非空约束：not null</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	<span class="keyword">sid</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">	sname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	sex <span class="built_in">int</span>,</span><br><span class="line">	age <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有表：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看表的定义：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看表结构：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 添加列（add）：</span><br><span class="line">alter table 表名 add 列名 列的类型 列的约束;</span><br><span class="line">alter table student add greade int not null;</span><br><span class="line"></span><br><span class="line">- 修改列（modify）：</span><br><span class="line">alter table 表名 modify sex varchar（2）;</span><br><span class="line"></span><br><span class="line">- 修改列名（change）：</span><br><span class="line">alter table 表名 change sex gender varchar（2）;</span><br><span class="line"></span><br><span class="line">- 删除列（drop）</span><br><span class="line">alter table 表名 drop greade;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表名（rename）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> student <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表的字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>

<h1 id="Sql完成对表中数据的CRUD操作"><a href="#Sql完成对表中数据的CRUD操作" class="headerlink" title="Sql完成对表中数据的CRUD操作"></a>Sql完成对表中数据的CRUD操作</h1><ul>
<li>插入数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，列名<span class="number">3</span>）<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>);</span><br><span class="line">如：<span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">sid</span>,sname,sex,age)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">简单写法：插入的是全列名的数据，表名后面的列名可以省略</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>);</span><br><span class="line">如:<span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">如果插入的是部分数据，列名不能省略</span><br><span class="line">如：<span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">sid</span>,sname,sex)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">批量插入：效率比单条插入效率高。但不能出错</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>，<span class="number">23</span>),</span><br><span class="line">						     (<span class="number">2</span>,<span class="string">'lisi'</span>,<span class="number">0</span>，<span class="number">22</span>),</span><br><span class="line">						     (<span class="number">3</span>,<span class="string">'wangwu'</span>,<span class="number">1</span>，<span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>查看表中数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure>
<ul>
<li>表中插入数据中文乱码问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.暂停Mysql服务</span><br><span class="line">2.在Mysql安装路径中找到my.ini配置文件</span><br><span class="line">3.将57行的编码改成GBK。</span><br><span class="line">4.保存，退出，启动mysql服务</span><br></pre></td></tr></table></figure>
<ul>
<li>删除记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名[<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student;  如果没有指定条件，会将表中数据一条一条全部删除掉。</span><br></pre></td></tr></table></figure>
<ul>
<li>面试问题：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请说一下delete 删除数据和truncate删除数据有什么差别？</span><br><span class="line">答：delete：属于DML数据操纵语言，一条一条删除表中的数据。</span><br><span class="line">	truncate：属于DDL数据定义语言，先删除表，在重建表。 </span><br><span class="line"></span><br><span class="line">关于那条执行效率高：具体要看表中的数据量。</span><br><span class="line">	如果数据比较少，delete比较高效。</span><br><span class="line">	如果数据比较多，truncate比较高效。</span><br></pre></td></tr></table></figure>
<ul>
<li>更新表记录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名=列的值，列名<span class="number">2</span>=列的值<span class="number">2</span> [<span class="keyword">where</span> 条件]</span><br><span class="line"></span><br><span class="line">需求：将<span class="keyword">sid</span>为<span class="number">5</span>的名字改成李四</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> sname=<span class="string">'李四'</span> <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">5</span>;</span><br><span class="line">//如果参数是字符串或者日期，要加上单引号</span><br></pre></td></tr></table></figure>
<h1 id="select查询的简单查询"><a href="#select查询的简单查询" class="headerlink" title="select查询的简单查询"></a>select查询的简单查询</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] [ * ] [列名，列名<span class="number">2</span>] <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">distinct</span>：去除重复的数据</span><br><span class="line"></span><br><span class="line"><span class="comment">--简单商品：手机数码，鞋靴箱包</span></span><br><span class="line"><span class="number">1.</span>分类的<span class="keyword">ID</span></span><br><span class="line"><span class="number">2.</span>分类名称</span><br><span class="line"><span class="number">3.</span>分类描述</span><br><span class="line"></span><br><span class="line">//创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">	cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	cname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	cdesc <span class="built_in">varchar</span>(<span class="number">31</span>)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">//插入数据	</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'安慕希'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'家用电器'</span>,<span class="string">'美的空调'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--所有商品</span></span><br><span class="line">1.商品ID</span><br><span class="line">2.商品名称</span><br><span class="line">3.商品价格</span><br><span class="line">4，生产日期</span><br><span class="line">5，商品分类ID</span><br><span class="line"></span><br><span class="line">//创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">	pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	price <span class="keyword">double</span>,</span><br><span class="line">	pdate <span class="built_in">timestamp</span>,</span><br><span class="line">	cno <span class="built_in">int</span> </span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'xiaomi'</span>,<span class="number">998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'chuizi'</span>,<span class="number">2998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'nike'</span>,<span class="number">888</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'laocunzhang'</span>,<span class="number">88</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'jingjiu'</span>,<span class="number">32</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'xiaoxiong'</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'weilong'</span>,<span class="number">0.5</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'wangwang'</span>,<span class="number">0.5</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>简单查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1.查询所有的商品：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">2.查询商品名称和商品价格</span><br><span class="line"><span class="keyword">select</span> pname,price <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">3.别名查询，as 的关键字 ，as关键字可以省略</span><br><span class="line">	-表别名：<span class="keyword">select</span> p.pname,p.price,<span class="keyword">from</span> product p;(主要用在多表查询)</span><br><span class="line">	<span class="keyword">select</span> p.pname,p.price </span><br><span class="line">	<span class="keyword">from</span> product <span class="keyword">as</span> p;</span><br><span class="line">	-列别名：<span class="keyword">select</span> pname <span class="keyword">as</span> 商品名称,price <span class="keyword">as</span> 商品价格 <span class="keyword">from</span> product;</span><br><span class="line">	<span class="keyword">select</span> pname <span class="keyword">as</span> 商品名称,price <span class="keyword">as</span> 商品价格 <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">4.去掉重复的值</span><br><span class="line">	-查询商品所有的价格</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">5.select运算查询</span><br><span class="line">	<span class="keyword">select</span> *,price*<span class="number">1.5</span> <span class="keyword">as</span> 折后价 <span class="keyword">from</span> product; </span><br><span class="line"></span><br><span class="line">6.条件查询[where关键字]</span><br><span class="line">	指定条件，确定要操作的记录</span><br><span class="line">	-查询商品价格大于60元的所有商品信息</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price&gt;<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">7.where 后的条件写法</span><br><span class="line">	-关系运算符：&gt;  &gt;=  &lt;  &lt;=   =  !=  &lt;&gt;</span><br><span class="line">		&lt;&gt; : 不等于   ：标准SQL语法</span><br><span class="line">		!= : 不等于   ：非标准SQL语法</span><br><span class="line">	-查询商品价格不等于88的所有商品</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;&gt; <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price != <span class="number">88</span>;</span><br><span class="line">	-查询商品价格在10到100之间的商品</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price&lt;<span class="number">100</span> <span class="keyword">and</span> price &gt;<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line">	-逻辑运算：and   or   not</span><br><span class="line">	-查询出商品价格 小于100 或者大于900</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;<span class="number">100</span> <span class="keyword">or</span> price &gt;<span class="number">900</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1.like :模糊查询</span><br><span class="line">	_ ：代表的是一个字符</span><br><span class="line">	% ：代表的是多个字符</span><br><span class="line">	in：在某个范围内获得值</span><br><span class="line">	-查询出名字中带有饼的所有商品  ‘%饼%’</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'%饼%'</span>;</span><br><span class="line">	-查询第二名字是熊的所有商品  '_熊%'</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'_熊%'</span>;</span><br><span class="line">	-查询出商品分类ID在1，4，5里面的所有商品</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> cno <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">2.排序查询: order by  关键字</span><br><span class="line">	asc:   ascend  升序（默认的排序方式）</span><br><span class="line">	desc： descend 降序</span><br><span class="line">	-查询所有商品，按照降序排序</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line">	-查询名称有“小”的商品，按照升序排序</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'%小%'</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line">3.聚合函数：</span><br><span class="line">	-获得所有商品价格总和：</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> product;</span><br><span class="line">	-获得所有商品价格平均值：</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">avg</span>(price) <span class="keyword">from</span> product;</span><br><span class="line">	-获得所有商品的个数：</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">4.分组：group by</span><br><span class="line">	-根据cno字段分组，分组后统计商品的个数</span><br><span class="line">	<span class="keyword">select</span> cno,<span class="keyword">count</span>(*) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno; </span><br><span class="line">	-根据cno字段分组，分组后统计商品的平均价格，并且商品平均价格 &gt;60</span><br><span class="line">	<span class="keyword">select</span> cno,<span class="keyword">avg</span>(price) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno <span class="keyword">having</span> <span class="keyword">avg</span>(price) &gt;<span class="number">60</span>;</span><br><span class="line">	-having 关键字，他可以接聚合函数的，  出现在分组之后</span><br><span class="line">	-where 关键字，他不可以接聚合函数，出现在分组之前</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">编写顺序：</span><br><span class="line">S..F..W..G..H..O</span><br><span class="line">select..from..where..group by..having..drder <span class="keyword">by</span></span><br><span class="line">执行顺序：</span><br><span class="line">F..W..G..H..S..O</span><br><span class="line">from..where..group by..having..select..drder <span class="keyword">by</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet学习笔记</title>
    <url>/441652674/</url>
    <content><![CDATA[<p>java Web离不开Servlet，它其实就是一个java程序，运行在我们的web服务器上，用于<strong>接收和响应</strong> 客户端的http请求。 </p>
<a id="more"></a>
<h2 id="一、Web资源介绍"><a href="#一、Web资源介绍" class="headerlink" title="一、Web资源介绍"></a>一、Web资源介绍</h2><ul>
<li><strong>在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。</strong></li>
<li>有两种分类：</li>
<li>静态资源：html 、 js、 css</li>
<li>动态资源：servlet/jsp</li>
</ul>
<h2 id="二、Servlet介绍"><a href="#二、Servlet介绍" class="headerlink" title="二、Servlet介绍"></a>二、Servlet介绍</h2><ul>
<li><strong>servlet是什么?</strong><ol>
<li>其实就是一个java程序，运行在我们的web服务器上，用于<strong>接收和响应</strong> 客户端的http请求。 </li>
<li>更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet</li>
</ol>
</li>
</ul>
<h2 id="三、Selvlet简单使用Web工程"><a href="#三、Selvlet简单使用Web工程" class="headerlink" title="三、Selvlet简单使用Web工程"></a>三、Selvlet简单使用Web工程</h2><ol>
<li><p>得写一个Web工程 ， 要有一个服务器。</p>
</li>
<li><p>测试运行Web工程：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">得写一个Web工程 ， 要有一个服务器。</span><br><span class="line">测试运行Web工程</span><br><span class="line">	1. 新建一个类， 实现Servlet接口`public class HelloServlet implements Servlet&#123;&#125;`</span><br><span class="line"></span><br><span class="line">	2. 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。</span><br><span class="line">		在webContent/WEB-INF/web.xml里面写上以下内容：</span><br><span class="line">		</span><br><span class="line">		  &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.itheima.servlet.HelloServlet --&gt;</span><br><span class="line">		  &lt;servlet&gt;</span><br><span class="line">		  	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">		  	&lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">		  &lt;/servlet&gt;</span><br><span class="line">		  </span><br><span class="line">		  &lt;!-- 注册servlet的映射。  servletName : 找到上面注册的具体servlet，  url-pattern: 在地址栏上的path 一定要以/打头 --&gt;</span><br><span class="line">		  &lt;servlet-mapping&gt;</span><br><span class="line">		  	&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">		  	&lt;url-pattern&gt;/a&lt;/url-pattern&gt;</span><br><span class="line">		  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">		3. 在地址栏上输入 http://localhost:8080/项目名称/a</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200226115856385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、Servlet执行过程"><a href="#四、Servlet执行过程" class="headerlink" title="四、Servlet执行过程"></a>四、Servlet执行过程</h2><p><img src="https://img-blog.csdnimg.cn/20200226120652999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="五、Servlet的通用写法"><a href="#五、Servlet的通用写法" class="headerlink" title="五、Servlet的通用写法"></a>五、Servlet的通用写法</h2><ul>
<li>实现Servlet接口，但接口里的方法很多，有些用不到。</li>
</ul>
<ol>
<li>Servlet (接口)        </li>
<li>GenericServlet    </li>
<li>HttpServlet （用于处理http的请求）</li>
</ol>
<ul>
<li>定义一个类，继承HttpServlet ,复写doGet 和 doPost</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200226124900942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="六、Servlet的生命周期方法"><a href="#六、Servlet的生命周期方法" class="headerlink" title="六、Servlet的生命周期方法"></a>六、Servlet的生命周期方法</h2><ul>
<li>生命周期： 从创建到销毁的一段时间</li>
<li>生命周期方法： 从创建到销毁，所调用的那些方法。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. init方法</span><br><span class="line">	在创建该servlet的实例时，就执行该方法。</span><br><span class="line">	一个servlet只会初始化一次， init方法只会执行一次</span><br><span class="line">	默认情况下是 ： 初次访问该servlet，才会创建实例。 </span><br><span class="line">		</span><br><span class="line">2.service方法</span><br><span class="line">	只要客户端来了一个请求，那么就执行这个方法了。</span><br><span class="line">	该方法可以被执行很多次。 一次请求，对应一次service方法的调用</span><br><span class="line">	</span><br><span class="line">3.destroy方法</span><br><span class="line">	servlet销毁的时候，就会执行该方法</span><br><span class="line">			1. 该项目从tomcat的里面移除。</span><br><span class="line">		  	2. 正常关闭tomcat就会执行 shutdown.bat</span><br><span class="line"></span><br><span class="line">4. doGet 和 doPost不算生命周期方法。</span><br><span class="line">所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。</span><br><span class="line">```	 </span><br><span class="line"><span class="comment">## 七、让Servlet创建实例的时机提前。</span></span><br><span class="line">1. 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 </span><br><span class="line"></span><br><span class="line">2. 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 为了提升用户的体验，需要让这个初始化的时机提前一点。 </span><br><span class="line"></span><br><span class="line">3. 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt;</span><br><span class="line">	&lt;load-on-startup&gt;2&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<h2 id="八、ServletConfig"><a href="#八、ServletConfig" class="headerlink" title="八、ServletConfig"></a>八、ServletConfig</h2><ul>
<li><strong>Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 得到servlet配置对象 专门用于在配置servlet的信息</span></span><br><span class="line">ServletConfig config = getServletConfig();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//获取到的是配置servlet里面servlet-name 的文本内容</span></span><br><span class="line">String servletName = config.getServletName();</span><br><span class="line">System.out.println(<span class="string">"servletName="</span>+servletName);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//2. 可以获取具体的某一个参数。 </span></span><br><span class="line">String address = config.getInitParameter(<span class="string">"address"</span>);</span><br><span class="line">System.out.println(<span class="string">"address="</span>+address);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取所有的参数名称</span></span><br><span class="line">Enumeration&lt;String&gt; names = config.getInitParameterNames();</span><br><span class="line"><span class="comment">//遍历取出所有的参数名称</span></span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">	String key = (String) names.nextElement();</span><br><span class="line">	String value = config.getInitParameter(key);</span><br><span class="line">	System.out.println(<span class="string">"key==="</span>+key + <span class="string">"   value="</span>+value);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数在哪里配置？在web.xml中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;aa&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;com.daq.servlet.HelloServletConfig&lt;/servlet-class&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 可以添加初始化参数 --&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;adress&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;bejing&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">	</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet02&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/HelloServlet02&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<h2 id="九、为什么需要有ServletConfig？"><a href="#九、为什么需要有ServletConfig？" class="headerlink" title="九、为什么需要有ServletConfig？"></a>九、为什么需要有ServletConfig？</h2><ol>
<li><p>未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。做成了jar包，它的代码放置在了自己的servlet类里面。 </p>
</li>
<li><p>刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params</p>
</li>
<li><p>在开发当中比较少用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql安装与卸载</title>
    <url>/3168578773/</url>
    <content><![CDATA[<p>MySql的卸载与安装</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>运行安装程序，在启动配置教程之前，一路下一步，没有下一步的话就直接<code>finish</code></li>
<li>第一次<code>finish</code>之后启动服务器配置教程</li>
<li>第一个注意：<code>include mysql bin directory to windows path</code></li>
<li>第二个注意：端口号不要修改，字符集选择UTF-8</li>
</ul>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><ul>
<li>打开控制面板，删除软件</li>
<li>删除mysql安装目录的所有文件</li>
<li>删除mysql数据存放文件，C盘下面的<code>Programe data</code>里，它是隐藏文件，要点击查看隐藏文件。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat发布项目的三种方式</title>
    <url>/2665853047/</url>
    <content><![CDATA[<p>本文介绍Tomcat发布项目到服务器上的三种方式</p>
<a id="more"></a>
<h2 id="一、拷贝这个文件到webapps-ROOT底下，-在浏览器里面访问。"><a href="#一、拷贝这个文件到webapps-ROOT底下，-在浏览器里面访问。" class="headerlink" title="一、拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问。"></a>一、拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/stu.xml</span><br></pre></td></tr></table></figure>

<ul>
<li>在webaps下面新建一个文件夹xml  , 然后拷贝文件放置到这个文件夹中</li>
<li><a href="http://localhost:8080/xml/stu.xml">http://localhost:8080/xml/stu.xml</a></li>
<li><a href="http://localhost:8080">http://localhost:8080</a> ： 对应的是到webapps/root</li>
<li><a href="http://localhost:8080/xml/">http://localhost:8080/xml/</a> : 对应是 webapps/xml</li>
<li>使用IP地址访问：http://本机ip:8080/xml/stu.xml</li>
</ul>
<h2 id="二、配置虚拟路径"><a href="#二、配置虚拟路径" class="headerlink" title="二、配置虚拟路径"></a>二、配置虚拟路径</h2><p> 使用localhost：8080 打开tomcat首页， 找到Tomcat 8.5 Documentation,进入Reference，点击configuration ，找到左边的context，点击进入，复制此页面路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/docs/config/context.html</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200225123552708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>在conf/server.xml 找到host元素节点。加入以下内容。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200225124622947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>在浏览器地址栏上输入： <a href="http://localhost:8080/daq/person.xml">http://localhost:8080/daq/person.xml</a></li>
</ul>
<h2 id="配置虚拟路径2"><a href="#配置虚拟路径2" class="headerlink" title="配置虚拟路径2"></a>配置虚拟路径2</h2><ol>
<li><p>在<code>tomcat/conf/catalina/localhost/</code> 文件夹下新建一个xml文件，名字可以自己定义。 <code>person.xml</code></p>
</li>
<li><p>在这个文件里面写入以下内容</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span>?&gt;</span><br><span class="line">&lt;Context docBase=<span class="string">"F：\XML2"</span>&gt;&lt;/Context&gt;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>在浏览器上面访问:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/person/xml的名字即可</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE---Object类</title>
    <url>/Object/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object类是所有类的父类，位于java.lang包中。这也是面试的一个小考点吧，这篇文章看看Object中有哪些方法。</p>
<a id="more"></a>

<h2 id="Object类概述"><a href="#Object类概述" class="headerlink" title="Object类概述"></a>Object类概述</h2><ul>
<li>Object类是JDK默认提供的一个类。java中除了Object类，所有类都存在继承，默认会继承Object父类</li>
<li>所有类的对象都可以使用 Object 接收。</li>
<li>Object 达到最高参数统一化。</li>
</ul>
<h2 id="什么时候使用Object类"><a href="#什么时候使用Object类" class="headerlink" title="什么时候使用Object类?"></a>什么时候使用Object类?</h2><ul>
<li>对于Object类的使用可以分为两个阶段：JDK 1.5以前，以及JDK 1.5之后。</li>
<li>Object之所以会被大量的进行参数的接收处理，很大的一部分原因在于：你的程序里面需要接受的类型很多，并不固定，可是现在的开发理念中强调的问题不再是这一点了，而是如何可以避免向下转型（如果避无可避，那么就用），因为从JDK1.5之后引入了泛型机制（在基础课程讲解泛型机制的时候重点分析了Object缺陷）。</li>
<li>现在的设计思想是用泛型来避免向下转型的操作（ClassCastException），如果你要认真读了API文档你会发现，可以接收Object类型的方法是越来越少了，开发中尽量回避Object接收的项目为主。</li>
</ul>
<h2 id="Object类有哪些方法？"><a href="#Object类有哪些方法？" class="headerlink" title="Object类有哪些方法？"></a>Object类有哪些方法？</h2><ul>
<li>可以看到里面都是用native关键字修饰的方法。都是原生函数，得调用C++的函数。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020041711473684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>JavaSE基础知识</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>github下载项目加速</title>
    <url>/3770390475/</url>
    <content><![CDATA[<p>在github上面找好的开源项目，想要clone到本地，自己调试运行一下，但是由于github的服务器在国外，所以下载速度真的是惊人的慢，有的时候2k/s，如果是一个小项目的话。那还好，等个两三分钟，但是项目大一点的，那就很鸡肋了，这里就介绍一个投机取巧的方法，来加速git clone</p>
<a id="more"></a>

<ul>
<li><strong>核心思想：</strong> 利用<code>gitee</code>（码云）做中间工具</li>
</ul>
<ol>
<li>注册好码云，并配置好本地仓库，保证可以从<code>gitee</code>上<code>git clone</code></li>
<li>在<code>github</code>上复制你要克隆的项目的<code>url</code>。在码云中选择新建仓库的<code>从github/github导入仓库</code>，选择<code>从url导入</code>。粘贴刚才<code>github</code>上的<code>URL</code>到其中，点击导入即可。</li>
<li>然后在从码云将项目克隆到本地。</li>
<li>但是现在的项目，关联的是码云，而不是github。所以就要修改配置文件。</li>
<li>打开项目的<code>.git</code>，找到<code>config</code>文件，找到里面的<code>url</code>关键字，修改<code>gitee</code>为<code>github</code>，即可。</li>
</ol>
<ul>
<li><strong>补充：</strong> 修改，提交四步走</li>
</ul>
<ol>
<li><code>git status</code></li>
<li><code>git add &quot; 文件&quot;</code></li>
<li><code>git commit -m &quot;本次提交操作的相关描述&quot;</code></li>
<li><code>git push</code></li>
</ol>
]]></content>
      <categories>
        <category>git+github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/2557304751/</url>
    <content><![CDATA[<p>git分布式版本控制工具，在日常的开发中起到了非常重要的作用，掌握一些基本的命令也对工作效率的提高有很大的帮助，下面介绍一些基本的git操作。</p>
<a id="more"></a>
<h2 id="一、配置相关"><a href="#一、配置相关" class="headerlink" title="一、配置相关"></a>一、配置相关</h2><ul>
<li>配置全局帐户，该账户对所有git仓库都有效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">'你的账户名称'</span></span><br><span class="line">git config --global user.email <span class="string">'你的email'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置局部账户，该账户只对当前Git仓库有效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'你的账户名称'</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">'你的email'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看配置情况</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure>
<h2 id="二、本地操作"><a href="#二、本地操作" class="headerlink" title="二、本地操作"></a>二、本地操作</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>1.查看变更情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>2.查看当前工作在那个分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<p>3.切换到指定分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 指定分支名称</span><br></pre></td></tr></table></figure>
<p>4.把当前目录及子目录下所有变更都加入到<code>暂存区</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>5.把仓库内所有变更都加入到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure>
<p>6.把指定文件添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure>
<p>7.创建正式的<code>commit</code>，也就是把当前更改提交，并附加描述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"本次提交的描述"</span></span><br></pre></td></tr></table></figure>

<h3 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h3><p>1.比较某文件工作区和暂存区的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff 某文件</span><br></pre></td></tr></table></figure>

<p>2.比较某文件暂存区和HEAD的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cache 某文件</span><br></pre></td></tr></table></figure>
<p>3.比较工作区和暂存区的所欲差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>4.比较暂存区和HEAD的所有差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cache</span><br></pre></td></tr></table></figure>
<h3 id="暂存区与工作区之间回滚"><a href="#暂存区与工作区之间回滚" class="headerlink" title="暂存区与工作区之间回滚"></a>暂存区与工作区之间回滚</h3><p>1.把工作区指定文件恢复和暂存区一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 文件1 文件2... 文件n</span><br></pre></td></tr></table></figure>
<p>2.把暂存区指定文件恢复和HEAD一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure>
<p>3.把暂存区和工作区所有文件恢复和HEAD一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reaet --head</span><br></pre></td></tr></table></figure>
<p>4.用<code>difftool</code>比较两个<code>commit</code>的差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git difftool commit1 commit2</span><br></pre></td></tr></table></figure>
<p>5.查看哪些文件没有被<code>git</code>管控</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure>

<p>6.补充：从工作区回滚到暂存区用<code>checkout</code>， 否则用reset</p>
<h2 id="三、-加塞临时任务处理"><a href="#三、-加塞临时任务处理" class="headerlink" title="三、 加塞临时任务处理"></a>三、 加塞临时任务处理</h2><p>1.把未处理完的变更先保存到<code>stash</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>2.临时任务处理处理完之后继续之前的工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop //pop相当于出栈和入栈一样，把之前的任务弹出来</span><br><span class="line">或者</span><br><span class="line">git stash apply //与pop不同的是，apply相当于从栈顶把任务取出来，但是不会从栈中把任务移除</span><br></pre></td></tr></table></figure>
<p>3.查看所有<code>stash</code>的变更</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>4.取回某次<code>stash</code>的变更</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop stash @｛n｝</span><br></pre></td></tr></table></figure>

<h2 id="四、修改个人分支历史"><a href="#四、修改个人分支历史" class="headerlink" title="四、修改个人分支历史"></a>四、修改个人分支历史</h2><ul>
<li>仓库在每次变更执行commit的时候，会生成一个新的commit，有时候不想生成新的，只是修改一下之前的，该如何操作呢？</li>
</ul>
<p>1.修改最后一次<code>commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在工作区中修改文件 </span><br><span class="line">git add</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>2.修改第（N）次的<code>commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i N前面一个commit的id</span><br><span class="line">在工作区修改文件</span><br><span class="line">git add</span><br><span class="line">git rebase --contiue</span><br></pre></td></tr></table></figure>

<h2 id="五、查看变更日志"><a href="#五、查看变更日志" class="headerlink" title="五、查看变更日志"></a>五、查看变更日志</h2><p>1.当前分支的各个commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --online</span><br></pre></td></tr></table></figure>
<p>2.显示最近n个commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n</span><br></pre></td></tr></table></figure>
<p>3.用图示显示所有的历史分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --online --graph --all</span><br></pre></td></tr></table></figure>
<p>4.查看涉及到某文件变更的所有commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> 某文件</span><br></pre></td></tr></table></figure>
<p>5.某文件各行最后修改对应的commit以及作者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame 文件名</span><br></pre></td></tr></table></figure>

<h2 id="六、分支与标签"><a href="#六、分支与标签" class="headerlink" title="六、分支与标签"></a>六、分支与标签</h2><h3 id="①创建新分支"><a href="#①创建新分支" class="headerlink" title="①创建新分支"></a>①创建新分支</h3><p>1.基于当前分支创建新分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 新分支</span><br></pre></td></tr></table></figure>
<p>2.基于指定分支创建新分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 新分支 已有分支</span><br></pre></td></tr></table></figure>
<p>3.基于某个commit创建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 新分支 某个commit 的id</span><br></pre></td></tr></table></figure>
<p>4.创建分支并切换到该分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cheakout -b 新分支</span><br></pre></td></tr></table></figure>
<h3 id="②列出分支"><a href="#②列出分支" class="headerlink" title="②列出分支"></a>②列出分支</h3><p>1.列出本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<p>2.列出本地和远端分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure>
<p>3.列出远端所有分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -rv</span><br></pre></td></tr></table></figure>
<p>4.列出名称符合某样式的远端分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -rv -l <span class="string">'某样式'</span></span><br></pre></td></tr></table></figure>
<h3 id="③删除分支"><a href="#③删除分支" class="headerlink" title="③删除分支"></a>③删除分支</h3><p>1.安全删除本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d 要删除的分支</span><br></pre></td></tr></table></figure>
<p>2.强制删除本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D 分支</span><br></pre></td></tr></table></figure>
<p>3.删除已经合并到master分支的所有本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">'^\*\| master'</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure>
<p>4.删除远端origin已不存在的所有本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>
<p>5.打标签：从commit上打标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 标签名 commit 的id</span><br></pre></td></tr></table></figure>

<h2 id="七、两分支之间的集成"><a href="#七、两分支之间的集成" class="headerlink" title="七、两分支之间的集成"></a>七、两分支之间的集成</h2><p>1.把A分支合入到当前分支，且为merge创建commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge A分支</span><br></pre></td></tr></table></figure>
<p>2.把A分支和入到B分支，且为Merge创建commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge A分支 B分支</span><br></pre></td></tr></table></figure>
<p>3.把当前分支基于B分支作为rebase，以便B分支合入到当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase B分支</span><br></pre></td></tr></table></figure>
<p>4.把A分支基于B分支做rebase，以便B分支合入到A分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase B分支 A分支</span><br></pre></td></tr></table></figure>
<h2 id="八、和远端交互"><a href="#八、和远端交互" class="headerlink" title="八、和远端交互"></a>八、和远端交互</h2><p>1.列出所有的remote</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>2.增加remote</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add URL地址</span><br></pre></td></tr></table></figure>
<p>3.删除remote </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove remote的名称</span><br></pre></td></tr></table></figure>
<p>4.改变remote的名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rname 旧名称 新名称</span><br></pre></td></tr></table></figure>
<p>5.把远端所有分支和标签的变更都拉到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch remote</span><br></pre></td></tr></table></figure>
<p>6.把远端分支变更拉到本地，且merge到本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull remote名称 分支名</span><br></pre></td></tr></table></figure>
<p>7.把本地分支push到远端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote名称 分支名</span><br></pre></td></tr></table></figure>
<p>8.删除远端分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote --delete 远端分支名</span><br><span class="line">或者</span><br><span class="line">git push remote：远端分支名</span><br></pre></td></tr></table></figure>
<p>9.向远端提交指定标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote 标签名</span><br></pre></td></tr></table></figure>
<p>10.向远端提交所有标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote --tags</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git+github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux启动过程和目录结构</title>
    <url>/3247955720/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装好了linux系统之后，第一步当然要对linux有一个基本的了解，它有哪些特点，应用场景有哪些，为什么要用linux，了解了这些，然后在作具体深入的命令行操作。</p>
<a id="more"></a>

<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="https://img-blog.csdnimg.cn/20200401183454555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><code>bin</code>：存放二进制可执行文件</li>
<li><code>sbin</code>：存放二进制可执行文件，只有<code>root</code>才可以访问。</li>
<li><code>etc</code>：存放系统配置文件</li>
<li><code>usr</code>：用于存放共享的系统资源</li>
<li><code>home</code>：存放用户文件的根目录</li>
<li><code>root</code>：超级用户目录</li>
<li><code>dev</code>：用于存放设备文件</li>
<li><code>lib</code>：存放跟文件系统中的程序运行所需要的共享库以及内核模块</li>
<li><code>mnt</code>：系统管理员安装临时文件的安装点</li>
<li><code>boot</code>：存放用于系统引导时使用的各种文件</li>
<li><code>tmp</code>：用于存放各种临时文件</li>
<li><code>var</code>：用于存放运行时需要改变数据的文件</li>
</ul>
<h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><ol>
<li>BIOS自检</li>
<li>启动GRUB 2</li>
<li>加载内核</li>
<li>执行systemd进程</li>
<li>初始化系统环境</li>
</ol>
<h1 id="linux和windows的区别？"><a href="#linux和windows的区别？" class="headerlink" title="linux和windows的区别？"></a>linux和windows的区别？</h1><p><strong>从使用情况来看：</strong></p>
<ul>
<li>windows比较倾向于给非专业办公人士用，图形化界面使办公更方便。linux面向开发人员。</li>
<li>windows平台：数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 </li>
<li>linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。</li>
</ul>
<p><strong>从安全性上来看：</strong></p>
<ul>
<li>Windows平台：三天两头打补丁安装系统安全更新，还是会中病毒木马什么的，各位用户自己感受。 </li>
<li>Linux平台：要说linux没有安全问题，那当然是不可能的，不会中病毒什么的，也不可能，这一点仁者见仁智者见智，相对来说肯定比Windows平台要更加安全，使用linux你也不用装杀毒软件了。</li>
</ul>
<h1 id="linux的特点是什么？"><a href="#linux的特点是什么？" class="headerlink" title="linux的特点是什么？"></a>linux的特点是什么？</h1><ul>
<li><strong>稳定的系统 ：</strong>安装Linux的主机连续运行一年以上不曾宕机、不必关机是很平常的事。</li>
<li><strong>安全性和漏洞的快速修补 ：</strong>Linux是开发人员在使用，所以维护者众多，更新维护很快。</li>
<li><strong>多任务，多用户 ：</strong>你可以在一个Linux主机上规划出不同等级的用户，而且每个用户登录系统时工作环境可以不同，还可以允许不同用户在同一时间登陆主机以使用主机的资源。</li>
<li><strong>相对较少的系统资源占用 ：</strong>这是最吸引眼球的地方，目前市面上任何一款个人计算机都可以达到使用Linux搭建一个服务上百人以上的主机。</li>
<li><strong>模块化程度高：</strong>Linux的内核设计非常精巧，分成进程调度、内存管理、进程间通信、虚拟文件系统和网络接口五大部分;其独特的模块机制可根据用户的需要，实时地将某些模块插入或从内核中移走，使得Linux系统内核可以裁剪得非常小巧，很适合于嵌入式系统的需要。</li>
</ul>
<h1 id="linux可以做什么？"><a href="#linux可以做什么？" class="headerlink" title="linux可以做什么？"></a>linux可以做什么？</h1><ul>
<li>linux简直太适合不过做服务器了，百分之95的服务器都是基于linux平台的，我自己也有一台云服务器，搭载的就是centOS7系统，目前这个博客网站就是运行在这台云服务器上的，它可以保证一年不关机，不宕机。</li>
<li>当然，除此之外，作为开发人员的开发工具也是很常见的。</li>
</ul>
]]></content>
      <categories>
        <category>linux学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装常用环境</title>
    <url>/2004179649/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手里有一台免费的阿里云服务器是真的很香，但是我也不能让他就这样只放一个博客网站吧，于是乎，我想在这片几乎空白的区域，开拓出一块儿良好的开发环境，也顺便熟悉一下linux系统的操作。这篇主要就是讲了，如何在云服务器上安装JDK，MySql，Tomcat</p>
<a id="more"></a>

<h1 id="一、安装JDK1-8"><a href="#一、安装JDK1-8" class="headerlink" title="一、安装JDK1.8"></a>一、安装JDK1.8</h1><h2 id="①查看有无自带的JDK"><a href="#①查看有无自带的JDK" class="headerlink" title="①查看有无自带的JDK"></a>①查看有无自带的JDK</h2><ul>
<li>有很多linux系统自带了<code>OpenJDK</code>，<code>OpenJDK</code>不包含<code>Deployment</code>（部署）功能，源代码不完整，而且精简化，只适合个人使用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 查看有无jdk，如果有，则会出现openjdk</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line">2.查看关于java的所有文件</span><br><span class="line">rpm -qa | grep java</span><br><span class="line"></span><br><span class="line">3. 删除掉openjdk（后面跟你自己的版本进行删除）</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="②下载JDK"><a href="#②下载JDK" class="headerlink" title="②下载JDK"></a>②下载JDK</h2><ul>
<li>去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">ORACLE官网</a>下载对应的linux版本。记得后缀是<code>.tar.gz</code>结尾。先下载到本地，再通过工具上传到linux上。这里推荐使用的工具是finalshell。详情使用请另参考。</li>
</ul>
<h2 id="③安装JDK"><a href="#③安装JDK" class="headerlink" title="③安装JDK"></a>③安装JDK</h2><ul>
<li>在<code>usr/local/src</code>目录下新建一个文件夹<code>jdk</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/src/jdk</span><br></pre></td></tr></table></figure>
<ul>
<li>将本地JDK上传到这个目录下。</li>
<li>进入文件夹，并解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/jdk</span><br><span class="line">tar zvxf 你的压缩包</span><br></pre></td></tr></table></figure>
<ul>
<li>安装完成</li>
</ul>
<h2 id="④配置环境变量"><a href="#④配置环境变量" class="headerlink" title="④配置环境变量"></a>④配置环境变量</h2><ul>
<li>进入环境变量的配置文件,编辑</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<ul>
<li>在最下面添加以下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/src/jdk/jdk1.8.0_161 （这里填写你自己的文件路径）</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写完之后：<code>ESC-&gt;:wq</code>退出。</li>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h1 id="二、安装Tomcat"><a href="#二、安装Tomcat" class="headerlink" title="二、安装Tomcat"></a>二、安装Tomcat</h1><h2 id="①下载tomcat"><a href="#①下载tomcat" class="headerlink" title="①下载tomcat"></a>①下载tomcat</h2><p>我下载的是Tomcat8.5，和安装JDK几乎一样的步骤，<a href="http://mirrors.ustc.edu.cn/apache/tomcat/">点击下载</a>对应的版本。</p>
<h2 id="②上传，解压"><a href="#②上传，解压" class="headerlink" title="②上传，解压"></a>②上传，解压</h2><ul>
<li>新建存放目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/src/Tomcat</span><br></pre></td></tr></table></figure>

<ul>
<li>用工具上传到该目录中。</li>
<li>解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> //usr/<span class="built_in">local</span>/src/Tomcat</span><br><span class="line">tar zvxf 你的安装包</span><br></pre></td></tr></table></figure>
<h2 id="③配置环境变量"><a href="#③配置环境变量" class="headerlink" title="③配置环境变量"></a>③配置环境变量</h2><ul>
<li>修改/etc/profile，加入Tomcat环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">2.加入以下代码：</span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=你的tomcat路径</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;CATALINA_HOME&#125;</span>/bin</span><br><span class="line"></span><br><span class="line">3.刷新环境变量</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="④启动tomcat"><a href="#④启动tomcat" class="headerlink" title="④启动tomcat"></a>④启动tomcat</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/Tomcat/apache-tomcat-8.5.53/bin</span><br><span class="line">sh start.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>查看端口号和日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.查看端口号</span><br><span class="line">ss -tan</span><br><span class="line"></span><br><span class="line">2.查看日志</span><br><span class="line">tail -f ../logs/catalina.out</span><br></pre></td></tr></table></figure>

<h1 id="三、安装Mysql"><a href="#三、安装Mysql" class="headerlink" title="三、安装Mysql"></a>三、安装Mysql</h1><h2 id="①查看自带版本"><a href="#①查看自带版本" class="headerlink" title="①查看自带版本"></a>①查看自带版本</h2><ul>
<li>查看有没有<code>mysql</code>，有则卸载。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 查看</span><br><span class="line">rpm -qa | grep mysql</span><br><span class="line">2. 卸载</span><br><span class="line">rpm -e --nodeps 查出来的mysql</span><br></pre></td></tr></table></figure>
<h2 id="②命令下载mysql"><a href="#②命令下载mysql" class="headerlink" title="②命令下载mysql"></a>②命令下载mysql</h2><ul>
<li>如果直接去官网下载，不知道要等多久，于是我找到了一个<a href="http://mirrors.sohu.com/mysql/MySQL-5.6/">镜像网站</a>，点击找到你的对应版本，这里以<code>mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</code>为例</li>
<li>命令安装：既然找到了具体网址，那我们就用<code>wget</code>命令安装，省去上传的时间。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>创建mysql用户组及用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/mysql/support-files/my-default.cnf /etc/my.cnf</span><br><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line"></span><br><span class="line">#设置3306端口 </span><br><span class="line">port = <span class="number">3306</span>  </span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录 根据实际目录进行配置</span><br><span class="line">basedir=/usr/local/mysql </span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录 根据实际目录进行配置</span><br><span class="line">datadir=/usr/local/mysql/data </span><br><span class="line"></span><br><span class="line"># 允许最大连接数 </span><br><span class="line">max_connections=<span class="number">200</span> </span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集 </span><br><span class="line">character-set-server=utf8 </span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎 </span><br><span class="line"><span class="keyword">default</span>-storage-engine=INNODB </span><br><span class="line"></span><br><span class="line">max_allowed_packet=<span class="number">16</span>M</span><br></pre></td></tr></table></figure>
<ul>
<li>安装autoconf库，赋权并执行初始化数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install autoconf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R mysql.mysql /usr/<span class="built_in">local</span>/src/mysql5.6</span><br><span class="line">/usr/<span class="built_in">local</span>/src/mysql5.6/scripts/mysql_install_db --verbose --user=mysql --defaults-file=/etc/my.cnf --datadir=/usr/<span class="built_in">local</span>/src/mysql5.6/data --basedir=/usr/<span class="built_in">local</span>/src/mysql5.6</span><br></pre></td></tr></table></figure>

<h2 id="③-启动msyql："><a href="#③-启动msyql：" class="headerlink" title="③ 启动msyql："></a>③ 启动msyql：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
<ul>
<li>如果出现以下情况：请按照以下步骤来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Failed to start mysql.service: Unit not found.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.查询/etc/init.d/下是否存在mysql，一般都没有，如果有的话，记得备份</span><br><span class="line">ll /etc/init.d/ | grep mysql</span><br><span class="line"></span><br><span class="line">2. 到你的mysql安装目录下，查看是否有mysql.server</span><br><span class="line">find / -name mysql.server</span><br><span class="line"></span><br><span class="line">3.如果有，把他复制到/etc/init.d/mysql</span><br><span class="line">cp /usr/<span class="built_in">local</span>/src/mysql5.6/support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>再次启动mysql</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
<ul>
<li>查看mysql运行状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql status</span><br></pre></td></tr></table></figure>

<ul>
<li>配置环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.vim ~/.bash_profile</span><br><span class="line">添加：<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/src/mysql5.6/bin</span><br><span class="line"></span><br><span class="line">2.source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h2 id="③登录"><a href="#③登录" class="headerlink" title="③登录"></a>③登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p </span><br><span class="line">Enter password: 直接回车</span><br></pre></td></tr></table></figure>

<p>-出现如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.29</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<h2 id="④修改密码"><a href="#④修改密码" class="headerlink" title="④修改密码"></a>④修改密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> password <span class="keyword">for</span> root@localhost = password(<span class="string">'new password'</span>);;</span><br><span class="line">new password替换成你要设置的密码</span><br><span class="line">注意:密码设置必须要大小写字母数字和特殊符号（,/<span class="string">';:等）,不然不能配置成功</span></span><br></pre></td></tr></table></figure>
<h2 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h2><h3 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h3><ul>
<li>必须要开启了3306端口才可以</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.开启端口</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent </span><br><span class="line"></span><br><span class="line">2.重启</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">3.查看是否有3306</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<h3 id="方法一：（不建议）"><a href="#方法一：（不建议）" class="headerlink" title="方法一：（不建议）"></a>方法一：（不建议）</h3><ul>
<li>在linux上登陆mysql，登陆成功后，依次执行命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span> and host =<span class="string">'localhost'</span>; </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<ul>
<li>并不建议对root账户进行开启远程访问权限，因为一旦拿到root权限之后，就可以对数据库执行任何操作，不安全。</li>
</ul>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul>
<li>新建一个用户并开启远程访问权限：</li>
<li>登录MySQL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">grant all privileges on 库名.表名 to <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> identified by <span class="string">'密码'</span> with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<ul>
<li>详细参数解释<br><code>库名</code>要远程访问的数据库名称,所有的数据库使用<code>*</code><br><code>表名</code>    要远程访问的数据库下的表的名称，所有的表使用<code>*</code><br><code>用户名</code>    要赋给远程访问权限的用户名称（这里写一个你自己创建的用户）<br><code>IP地址</code>    可以远程访问的电脑的IP地址，所有的地址使用<code>%</code><br><code>密码</code>要赋给远程访问权限的用户对应使用的密码</li>
</ul>
<h2 id="本地连接"><a href="#本地连接" class="headerlink" title="本地连接"></a>本地连接</h2><ul>
<li>保证本地mysql服务是打开的，3306端口是开的。</li>
<li>打开sqlyong，新建连接，填入以下数据</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200403172306622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="大功告成！！！"><a href="#大功告成！！！" class="headerlink" title="大功告成！！！"></a>大功告成！！！</h2>]]></content>
      <categories>
        <category>linux学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/3524511244/</url>
    <content><![CDATA[<p>TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略来建立连接。通过四次挥手来释放连接。</p>
<a id="more"></a>

<ul>
<li>用<code>wireshark</code>抓包分析一次连接的报文信息</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200409123355146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>这是tcp报文的数据包格式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200315135901175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>序列号seq：</strong> 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li>
</ul>
<ul>
<li><strong>确认号ack：</strong> 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li>
</ul>
<ul>
<li><strong>确认ACK：</strong> 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li>
</ul>
<ul>
<li><strong>同步SYN：</strong> 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li>
</ul>
<ul>
<li><strong>终止FIN：</strong> 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li>
</ul>
<ul>
<li><strong>补充：</strong> ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</li>
</ul>
<h2 id="三次握手过程与作用"><a href="#三次握手过程与作用" class="headerlink" title="三次握手过程与作用"></a>三次握手过程与作用</h2><p>刚开始客户端处于<code>CLOSE</code>的状态，服务端处于<code>LISTEN</code>状态。<br><strong>第一次握手：</strong></p>
<ul>
<li>建立连接时，客户端发送SYN包（同时随机生成初始序列号seq=x，并进入<code>SYN_SENT</code>状态，等待服务器确认。</li>
<li>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</li>
</ul>
<p> <strong>第二次握手：</strong></p>
<ul>
<li>服务器收到SYN包，发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要<strong>为自己</strong>随机初始化一个序列号 seq=y，此时服务器进入<code>SYN_RECV</code>状态。</li>
<li>这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</li>
</ul>
<p><strong>第三次握手：</strong></p>
<ul>
<li>客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。</li>
</ul>
<ul>
<li>第三次的ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200315113736297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>三次握手的作用</strong></p>
<ol>
<li>确认双方的接受能力，发送能力是否正常。</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备。</li>
<li>如果是Https协议的话，三次握手这个过程，还会进行数字证书的验证，以及加密秘钥的生成。</li>
</ol>
<h2 id="面试常见问题："><a href="#面试常见问题：" class="headerlink" title="面试常见问题："></a>面试常见问题：</h2><h3 id="①（ISN）是固定的吗？"><a href="#①（ISN）是固定的吗？" class="headerlink" title="①（ISN）是固定的吗？"></a>①（ISN）是固定的吗？</h3><ul>
<li>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number，初始序列号), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</li>
<li>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</li>
</ul>
<h3 id="②什么是半连接队列？"><a href="#②什么是半连接队列？" class="headerlink" title="②什么是半连接队列？"></a>②什么是半连接队列？</h3><ul>
<li>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</li>
<li>补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</li>
</ul>
<h3 id="③三次握手过程中可以携带数据吗？"><a href="#③三次握手过程中可以携带数据吗？" class="headerlink" title="③三次握手过程中可以携带数据吗？"></a>③三次握手过程中可以携带数据吗？</h3><ul>
<li><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，<strong>而第三次握手是可以携带数据的</strong>。</p>
</li>
<li><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
</li>
<li><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
</li>
</ul>
<h3 id="④为什么要三次握手呢？有人说两次握手就好了"><a href="#④为什么要三次握手呢？有人说两次握手就好了" class="headerlink" title="④为什么要三次握手呢？有人说两次握手就好了"></a>④为什么要三次握手呢？有人说两次握手就好了</h3><ul>
<li><p>举例：已失效的连接请求报文段。</p>
</li>
<li><p>客户端发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。</p>
</li>
</ul>
<h2 id="四次挥手过程详解"><a href="#四次挥手过程详解" class="headerlink" title="四次挥手过程详解"></a>四次挥手过程详解</h2><p><strong>第一次挥手：</strong></p>
<ul>
<li>TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态。</li>
<li>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
</ul>
<p><strong>第二次挥手</strong></p>
<ul>
<li>​ 服务端收到这个FIN，他发回一个<strong>ACK报文</strong> 确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。​ 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态。</li>
<li>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
</ul>
<p><strong>第三次挥手：</strong></p>
<ul>
<li>​ 服务端发送一个<strong>FIN(结束)</strong>到客户端，服务端关闭客户端的连接。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</li>
</ul>
<p><strong>第四次挥手：</strong></p>
<ul>
<li>​ 客户端发送<strong>ACK</strong> 报文确认，并将确认的序号+1，这样关闭完成。​ 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。此时TCP连接还没有释放，必须经过<code>2∗∗MSL</code>（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200315131718947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h2><h3 id="①为什么是4次挥手呢？"><a href="#①为什么是4次挥手呢？" class="headerlink" title="①为什么是4次挥手呢？"></a>①为什么是4次挥手呢？</h3><ul>
<li>为了确保数据能够完成传输。关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li>
</ul>
<h3 id="②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？"><a href="#②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？" class="headerlink" title="②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？"></a>②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？</h3><ul>
<li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，<strong>“你发的FIN报文我收到了”</strong>。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li>
</ul>
<h3 id="③客户端突然挂掉了怎么办？"><a href="#③客户端突然挂掉了怎么办？" class="headerlink" title="③客户端突然挂掉了怎么办？"></a>③客户端突然挂掉了怎么办？</h3><ul>
<li>正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现长时期的空闲。解决办法是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。</li>
</ul>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><p><strong>背景：</strong></p>
<ul>
<li>初始化连接的 SYN 超时问题Client发送SYN包给Server后挂了，Server回给Client的SYN-ACK一直没收到Client的ACK确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让Server将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的SYN连接队列耗尽。</li>
</ul>
<p><strong>让正常的连接无法得到处理。</strong></p>
<ul>
<li>​ 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。</li>
</ul>
<p><strong>什么是 SYN 攻击？</strong></p>
<ul>
<li>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。</li>
</ul>
<p><strong>如何检测 SYN 攻击？</strong></p>
<ul>
<li>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的netstats 命令来检测 SYN 攻击。</li>
</ul>
<p><strong>如何防御 SYN 攻击？</strong></p>
<ul>
<li>​ SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：<br>①缩短超时（SYN Timeout）<br>②时间增加最大半连接数<br>③过滤网关防护SYN<br>④cookies技术</li>
</ul>
]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE---四种内部类</title>
    <url>/517577219/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，<strong>可以将一个类定义在另一个类里面或者一个方法里边</strong>，这样的类称为<strong>内部类</strong>，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。</p>
<a id="more"></a>

<p> <strong>1. 成员内部类</strong><br>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；<br>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；<br>（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；<br>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。</p>
<p> <strong>2.  局部内部类</strong><br>（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；<br>（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<p><strong>3.匿名内部类</strong><br>（1）一般使用匿名内部类的方法来编写事件监听代码；<br>（2）匿名内部类是不能有访问修饰符和static修饰符的；<br>（3）匿名内部类是唯一一种没有构造器的类；<br>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p><strong>4.静态内部类</strong><br>（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；<br>（2）不能使用外部类的非static成员变量或者方法。</p>
<h2 id="内部类的共性："><a href="#内部类的共性：" class="headerlink" title="内部类的共性："></a>内部类的共性：</h2><ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。</li>
<li>内部类不能用普通的方式访问。</li>
<li>内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量。</li>
<li>外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问。</li>
</ul>
<h2 id="内部类的作用："><a href="#内部类的作用：" class="headerlink" title="内部类的作用："></a>内部类的作用：</h2><ul>
<li>内部类方法可以访问该类定义所在的作用域的数据，包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来,一般的非内部类，是不允许有 private 与protected权限的，但内部类可以。</li>
<li>可以实现多重继承。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li>
</ul>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><strong>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。大家都知道Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。</strong></p>
<h2 id="外部类："><a href="#外部类：" class="headerlink" title="外部类："></a>外部类：</h2><p>外部的类。定义一个类A，在A的内部再定义一个类B，则A就是外部类，B就是内部类。</p>
<h2 id="内部类与外部类区别与联系"><a href="#内部类与外部类区别与联系" class="headerlink" title="内部类与外部类区别与联系"></a>内部类与外部类区别与联系</h2><p>内部类可以访问外部类所有的方法和属性，如果内部类和外部类有相同的成员方法和成员属性，内部类的成员方法调用要优先于外部类即内部类的优先级比较高（只限于类内部，在主方法内，内部类对象不能访问外部类的成员方法和成员属性），外部类只能访问内部类的静态常量或者通过创建内部类来访问内部类的成员属性和方法。</p>
]]></content>
      <categories>
        <category>JavaSE基础知识</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>XML学习</title>
    <url>/4122240603/</url>
    <content><![CDATA[<p><strong>XML:  extendsible  markup  labguage  可扩展的标记语言</strong></p>
<a id="more"></a>

<h2 id="一、XML的作用？"><a href="#一、XML的作用？" class="headerlink" title="一、XML的作用？"></a>一、XML的作用？</h2><ol>
<li>可以用来保存数据（数据多的时候用数据库，少量时候用XML）</li>
<li>可以用来做配置文件</li>
<li>数据传输载体</li>
</ol>
<h2 id="二、XML文档结构-倒状树形结构"><a href="#二、XML文档结构-倒状树形结构" class="headerlink" title="二、XML文档结构_倒状树形结构"></a>二、XML文档结构_倒状树形结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;stus&gt;</span><br><span class="line">	&lt;stu&gt;</span><br><span class="line">		&lt;name&gt;daiaoqi&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">		&lt;desc&gt;我要学编程&lt;/desc&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">	&lt;stu&gt;</span><br><span class="line">		&lt;name&gt;wt&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;20&lt;/age&gt;</span><br><span class="line">		&lt;desc&gt;我要找工作&lt;/desc&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、文档定义-amp-声明"><a href="#三、文档定义-amp-声明" class="headerlink" title="三、文档定义&amp;声明"></a>三、文档定义&amp;声明</h2><ul>
<li>定义：其实就是一个文件，文件的后缀为 <strong>.xml</strong></li>
<li>声明：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"gbk"</span> standalone=<span class="string">"no"</span> ?&gt;</span><br><span class="line">version : 解析这个xml的时候，使用什么版本的解析器解析</span><br><span class="line">encoding : 解析xml中的文字的时候，使用什么编码来翻译</span><br><span class="line">standalone  : no：该文档会依赖关联其他文档，yes：这是一个独立的文档</span><br></pre></td></tr></table></figure>
<ul>
<li>encoding：默认文件保存的时候，使用的是GBK的编码保存。<br>要想让我们的xml能够正常的显示中文，有以下解决办法：<ol>
<li>让encoding也是GBK 或者 gb2312 。</li>
<li>如果encoding是 utf-8 ， 那么保存文件的时候也必须使用utf-8。</li>
<li>保存的时候见到的ANSI 对应的其实是我们的本地编码 GBK。</li>
<li>为了通用，建议使用UTF-8编码保存，以及encoding 都是 utf-8。</li>
</ol>
</li>
</ul>
<h2 id="四、元素定义"><a href="#四、元素定义" class="headerlink" title="四、元素定义"></a>四、元素定义</h2><p>1.其实就是里面的标签， &lt;&gt; 括起来的都叫元素 。 成对出现。  如下： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;stu&gt; &lt;/stu&gt;</span><br></pre></td></tr></table></figure>

<p>2.文档声明下来的第一个元素叫做根元素 (根标签)<br>3.标签里面可以嵌套标签<br>4.空标签：既是开始也是结束， 一般配合属性来用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;age/&gt;</span><br><span class="line">		&lt;stu&gt;</span><br><span class="line">			&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">			&lt;age/&gt;</span><br><span class="line">		&lt;/stu&gt;</span><br></pre></td></tr></table></figure>
<p>5.标签可以自定义。<br>XML 元素必须遵循以下命名规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.名称可以含字母、数字以及其他的字符 </span><br><span class="line">2.名称不能以数字或者标点符号开始 </span><br><span class="line">3.名称不能以字符 “xml”（或者 XML、Xml）开始 </span><br><span class="line">4.名称不能包含空格 </span><br><span class="line">5.命名尽量简单，做到见名知义</span><br></pre></td></tr></table></figure>

<h2 id="五、元素定义"><a href="#五、元素定义" class="headerlink" title="五、元素定义"></a>五、元素定义</h2><ul>
<li>简单元素：元素里面包含了普通的文字</li>
<li>复杂元素：元素里面还可以嵌套其他的元素</li>
</ul>
<h2 id="六、属性定义"><a href="#六、属性定义" class="headerlink" title="六、属性定义"></a>六、属性定义</h2><ul>
<li>定义在元素里面， &lt;元素名称  属性名称=”属性的值”&gt;&lt;/元素名称&gt;</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;stus&gt;</span><br><span class="line">	&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">		&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">	&lt;stu id=<span class="string">"10087"</span>&gt;</span><br><span class="line">		&lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;28&lt;/age&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure>
<h2 id="七、xml注释"><a href="#七、xml注释" class="headerlink" title="七、xml注释"></a>七、xml注释</h2><p>与html的注释一样。 xml的注释，不允许放置在文档的第一行。 必须在文档声明的下面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- --&gt; </span><br><span class="line">	如： </span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		//这里有两个学生</span><br><span class="line">		//一个学生，名字叫张三， 年龄18岁， 学号：10086</span><br><span class="line">		//另外一个学生叫李四  。。。</span><br><span class="line">	--&gt;</span><br></pre></td></tr></table></figure>
<h2 id="八、CDATA区"><a href="#八、CDATA区" class="headerlink" title="八、CDATA区"></a>八、CDATA区</h2><ul>
<li>所有 XML 文档中的文本均会被解析器解析，只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。<br>在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始，”&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。<br>在html中，某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</li>
<li>一般在数据传输的时候会出现，比如说服务器给客户端传数据。</li>
<li>严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;   &amp;lt;</span><br><span class="line">&amp;   &amp;amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>CDATA区写法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CDATA区 开始于 <span class="string">"&lt;![CDATA["</span></span><br><span class="line">        结束于 <span class="string">"]]&gt;"</span></span><br><span class="line">    如：</span><br><span class="line">&lt;des&gt;&lt;![CDATA[&lt;a href=<span class="string">"http://www.baidu.com"</span>&gt;我要学编程&lt;/a&gt;]]&gt;&lt;/des&gt;</span><br></pre></td></tr></table></figure>

<h2 id="九、XML解析"><a href="#九、XML解析" class="headerlink" title="九、XML解析"></a>九、XML解析</h2><ul>
<li>其实就是获取元素里面的字符数据或者属性数据。</li>
<li>XML解析方式(<strong>面试常问</strong>)有很多种，常用的有两种（DOM和SAX）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200224114632758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>针对以上两种解析方式，给出的解决方案有哪些？</li>
</ul>
<ol>
<li>jaxp  sun公司自带的， 比较繁琐</li>
<li>jdom        </li>
<li>dom4j  （常用）使用比较广泛<br>补充：jdom和dom4j的故事：刚开始都是一伙人做的，后来产生了分歧，另外一批人就做了dom4j，把jdom挤下去了。</li>
</ol>
<h2 id="十、Dom4j-基本用法"><a href="#十、Dom4j-基本用法" class="headerlink" title="十、Dom4j 基本用法"></a>十、Dom4j 基本用法</h2><p><img src="https://img-blog.csdnimg.cn/20200224140840458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">element.element(<span class="string">"stu"</span>) : 返回该元素下的第一个stu元素</span><br><span class="line">element.elements(); 返回该元素下的所有子元素。</span><br></pre></td></tr></table></figure>

<ol>
<li>创建SaxReader对象</li>
<li>指定解析的xml</li>
<li>获取根元素。</li>
<li>根据根元素获取子元素或者下面的子孙元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javapackage com.daq.test;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1.创建sax读取对象</span></span><br><span class="line">			SAXReader reader = <span class="keyword">new</span> SAXReader();<span class="comment">//jdbc--classloader</span></span><br><span class="line">			<span class="comment">//2.指定解析的xml源</span></span><br><span class="line">			Document document=reader.read(<span class="keyword">new</span> File(<span class="string">"src/xml/stus.xml"</span>));</span><br><span class="line">			<span class="comment">//3.得到元素</span></span><br><span class="line">			<span class="comment">//得到根元素</span></span><br><span class="line">			Element rootElement=document.getRootElement();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//4.获取根元素下面的子元素age</span></span><br><span class="line"><span class="comment">//			rootElement.element("age");</span></span><br><span class="line"><span class="comment">//			System.out.println(rootElement.element("stu").element("age").getStringValue());</span></span><br><span class="line">			</span><br><span class="line">			List&lt;Element&gt; elements=rootElement.elements();</span><br><span class="line">			<span class="comment">//遍历所有的stu元素</span></span><br><span class="line">			<span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">				<span class="comment">//获取stu下面的name元素</span></span><br><span class="line">				String name=element.element(<span class="string">"name"</span>).getText();</span><br><span class="line">				String age=element.element(<span class="string">"age"</span>).getText();</span><br><span class="line">				String adress=element.element(<span class="string">"adress"</span>).getText();</span><br><span class="line">				System.out.println(<span class="string">"name="</span>+name+<span class="string">"age="</span>+age+<span class="string">"adress="</span>+adress);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、Dom4j-的-Xpath使用"><a href="#十一、Dom4j-的-Xpath使用" class="headerlink" title="十一、Dom4j 的 Xpath使用"></a>十一、Dom4j 的 Xpath使用</h2><ul>
<li>dom4j里面支持Xpath的写法。 xpath其实是<strong>xml的路径语言</strong>，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。<ol>
<li>添加jar包依赖 ：jaxen-1.1-beta-6.jar</li>
<li>在查找指定节点的时候，根据XPath语法规则来查找</li>
<li>后续的代码与以前的解析代码一样。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。 </span></span><br><span class="line">Element nameElement = (Element) rootElement.selectSingleNode(<span class="string">"//name"</span>);</span><br><span class="line">	System.out.println(nameElement.getText());</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取文档里面的所有name元素 </span></span><br><span class="line">	List&lt;Element&gt; list = rootElement.selectNodes(<span class="string">"//name"</span>);</span><br><span class="line">	<span class="keyword">for</span> (Element element : list) &#123;</span><br><span class="line">		System.out.println(element.getText());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十二、XML-约束（了解即可）"><a href="#十二、XML-约束（了解即可）" class="headerlink" title="十二、XML 约束（了解即可）"></a>十二、XML 约束（了解即可）</h2><p>如下的文档， 属性的ID值是一样的。 这在生活中是不可能出现的。 并且第二个学生的姓名有好几个。 一般也很少。那么怎么规定ID的值唯一， 或者是元素只能出现一次，不能出现多次？ 甚至是规定里面只能出现具体的元素名字。 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;stus&gt;</span><br><span class="line">	&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">		&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">		&lt;address&gt;深圳&lt;/address&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">	&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">		&lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">		&lt;name&gt;李五&lt;/name&gt;</span><br><span class="line">		&lt;name&gt;李六&lt;/name&gt;</span><br><span class="line">		&lt;age&gt;28&lt;/age&gt;</span><br><span class="line">		&lt;address&gt;北京&lt;/address&gt;</span><br><span class="line">	&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure>
<p><strong>约束：</strong></p>
<ul>
<li>DTD：语法自成一派， 早前就出现的。 可读性比较差。 </li>
<li>Schema：其实就是一个xml ， 使用xml的语法规则， xml解析器解析起来比较方便 ， 是为了替代DTD 。但是Schema 约束文本内容比DTD的内容还要多。 所以目前也没有真正意义上的替代DTD</li>
</ul>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---中断机制</title>
    <url>/1622515277/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断机制可以说是操作系统里程碑上最划时代的一次变革。它在系统中起着通信网络的作用，协调系统对各种外部事件的响应和处理，中断是实现多道程序设计的必要条件，中断是CPU 对系统发生的某个事件作出的一种反应。因为有了它，我们才可以有条不紊的使用电脑！</p>
<a id="more"></a>

<ul>
<li><p>举个例子，CPU老板是一家公司的光杆司令，所有的顾客都要他亲自跑去处理，还要跟有关部门打点关系，CPU觉得顾客和公关这两样事它一个人搞不来，这就是轮询；终于这家公司升级发展了，CPU老板请了一个秘书，所有的顾客都先由秘书经手，CPU心情好的时候就去看一下，大部分时间都忙着去公关了，这时它觉得轻松了很多，这就是中断了~~</p>
</li>
<li><p>也就是说，中断和轮询是从CPU老板的角度来看的，不管怎样，事件都还是有人来时刻跟踪才能被捕获处理，不过是老板还是秘书的问题。所有的中断（或者异步，回调等）背后都有一个轮询（循环，listener）。</p>
</li>
<li><p><strong>中断机制的本质：CPU执行完每条指令时，都会去检查一个中断标志位</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200312181724601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312182615189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt=" "></p>
<p><img src="https://img-blog.csdnimg.cn/20200312182607627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312183153533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312183251723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>了解操作系统</title>
    <url>/1988581478/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机三件套之一：计算机操作系统，我刚开始看学校发的教材的时候，根本看不进去，一是知识太过于理论化，而且关于底层的东西，动手实践起来真的很难。但是一些简单的东西还是要了解一下的。其实在我看来，没有太大追求的话，就了解一些基本的就可以了，操作系统就那点儿东西：CPU调度，死锁，中断机制，进程管理，内存管理，文件系统，虚拟内存，就没了<del>~</del></p>
<a id="more"></a>
<h1 id="操作系统有哪些？"><a href="#操作系统有哪些？" class="headerlink" title="操作系统有哪些？"></a>操作系统有哪些？</h1><h2 id="1-简单的批处理操作系统"><a href="#1-简单的批处理操作系统" class="headerlink" title="1.简单的批处理操作系统"></a>1.简单的批处理操作系统</h2><p>一批一批处理任务的系统，用户将一批作业提交给操作系统后便不再干预，由操作系统控制它们自动运行。用户一次可以提交多个作业，但系统一次只处理一个作业，处理完一个作业后，再调入下一个作业进行处理。这些调度、切换系统自动完成。</p>
<h2 id="2-多道程序批处理操作系统"><a href="#2-多道程序批处理操作系统" class="headerlink" title="2.多道程序批处理操作系统"></a>2.多道程序批处理操作系统</h2><p>简单批处理系统一次只能处理一个作业，系统资源的利用率就不高，因此出现<strong>多道程序</strong>批处理系统。把同一个批次的作业调入内存，存放在内存的不同部分，当一个作业由于等待输入输出操作而让<strong>处理机</strong>出现空闲，系统自动进行切换，处理另一个作用，这就是多道程序批处理系统。相对简单批处理系统，由于充分利用了处理机的空闲时间，因此多道程序批处理系统的<strong>资源利用效率</strong>要高。</p>
<h2 id="3-分时操作系统"><a href="#3-分时操作系统" class="headerlink" title="3.分时操作系统"></a>3.分时操作系统</h2><p>分时操作系统：“分时”的含义是指多个用户使用同一台计算机，多个程序分时（分时间片）共享硬件和软件资源。分时操作系统是指在一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户通过主机的终端，以<strong>交互</strong>方式使用计算机，共享主机中的资源。分时操作系统将CPU的时间划分成若干个片段，称为<strong>时间片</strong>，操作系统以时间片为单位，轮流为每个终端用户服务 。</p>
<ul>
<li>总结：一个作业只能在<strong>一个</strong>时间片的时间内使用CPU,时间到时，系统将剥夺作业CPU的使用权，然后根据一定的算法将CPU分配给其他作业使用。</li>
</ul>
<h2 id="4-实时操作系统"><a href="#4-实时操作系统" class="headerlink" title="4.实时操作系统"></a>4.实时操作系统</h2><p>指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。</p>
<h2 id="5-网络操作系统"><a href="#5-网络操作系统" class="headerlink" title="5.网络操作系统"></a>5.网络操作系统</h2><p>指的是一台计算机通过一个<strong>网络接口控制器</strong>(网卡)连接到网络上，可以进行网络通信功能，网络资源的管理和使用。根据使用环境的不同，操作系统又可以分为<strong>服务器操作系统</strong>、<strong>桌面操作系统</strong>、<strong>嵌入式操作系统</strong>等</p>
<h1 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h1><h2 id="一、手工操作"><a href="#一、手工操作" class="headerlink" title="一、手工操作"></a>一、手工操作</h2><p><img src="https://img-blog.csdnimg.cn/20200312165529351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="二、单道批处理"><a href="#二、单道批处理" class="headerlink" title="二、单道批处理"></a>二、单道批处理</h2><p><img src="https://img-blog.csdnimg.cn/20200312165540713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312165607449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="三、多道批处理操作系统"><a href="#三、多道批处理操作系统" class="headerlink" title="三、多道批处理操作系统"></a>三、多道批处理操作系统</h2><p><img src="https://img-blog.csdnimg.cn/20200312165604663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312165623503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312165626625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312173008164.png" alt="在这里插入图片描述"></p>
<h2 id="四、分时操作系统"><a href="#四、分时操作系统" class="headerlink" title="四、分时操作系统"></a>四、分时操作系统</h2><p><img src="https://img-blog.csdnimg.cn/20200312173731270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312173737316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200312173740994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>事务-学习笔记</title>
    <url>/1680230579/</url>
    <content><![CDATA[<p>事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。</p>
<a id="more"></a>
<h1 id="一、事务（Transaction）概述"><a href="#一、事务（Transaction）概述" class="headerlink" title="一、事务（Transaction）概述"></a>一、事务（Transaction）概述</h1><ul>
<li>其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(<strong>回滚</strong>)。</li>
<li><strong>为什么要有事务?</strong><br>为了确保逻辑的成功。 如： 银行转账。 </li>
</ul>
<h1 id="二、演示事务"><a href="#二、演示事务" class="headerlink" title="二、演示事务"></a>二、演示事务</h1><ul>
<li>命令行方式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开启事务：</span><br><span class="line">	start transaction;</span><br><span class="line">提交：</span><br><span class="line">	commit; 提交事务， 数据将会写到磁盘上的数据库</span><br><span class="line">回滚：</span><br><span class="line">	rollback ;  数据回滚，回到最初的状态。</span><br></pre></td></tr></table></figure>
<ul>
<li>代码里面的事务，主要是针对连接来的。 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-通过conn.setAutoCommit（<span class="literal">false</span> ）来关闭自动提交的设置。</span><br><span class="line">-提交事务  conn.commit();</span><br><span class="line">-回滚事务 conn.rollback();</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testTransaction</span></span>()&#123;</span><br><span class="line">	Connection conn = null;</span><br><span class="line">	PreparedStatement ps = null;</span><br><span class="line">	ResultSet rs = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		conn = JDBCUtil.getConn();</span><br><span class="line">		</span><br><span class="line">		//连接，事务默认就是自动提交的。 关闭自动提交。</span><br><span class="line">		conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">			</span><br><span class="line">		String sql = <span class="string">"update account set money = money - ? where id = ?"</span>;</span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">			</span><br><span class="line">		//扣钱， 扣ID为1 的100块钱</span><br><span class="line">		ps.setInt(1, 100);</span><br><span class="line">		ps.setInt(2, 1);</span><br><span class="line">		ps.executeUpdate();</span><br><span class="line">			</span><br><span class="line">		int a = 10 /0 ;//有了异常，下面代码就不会执行了</span><br><span class="line">			</span><br><span class="line">		//加钱， 给ID为2 加100块钱</span><br><span class="line">		ps.setInt(1, -100);</span><br><span class="line">		ps.setInt(2, 2);</span><br><span class="line">		ps.executeUpdate();</span><br><span class="line">			</span><br><span class="line">		//成功： 提交事务。</span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	&#125; catch (SQLException e) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			//失败： 回滚事务</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; catch (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">	&#125;finally &#123;</span><br><span class="line">		JDBCUtil.release(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、事务特性ACID（面试）"><a href="#三、事务特性ACID（面试）" class="headerlink" title="三、事务特性ACID（面试）"></a>三、事务特性ACID（面试）</h1><ul>
<li>原子性（Atom）<br>指的是 事务中包含的逻辑，不可分割。 </li>
<li>一致性（Consistent）<br>指的是 事务执行前后，数据完整性。</li>
<li>隔离性（Isolate）<br>指的是 事务在执行期间不应该受到其他事务的影响。</li>
<li>持久性（Durable）<br>指的是 事务执行成功，那么数据应该持久保存到磁盘上。</li>
</ul>
<h1 id="四、安全问题-amp-隔离级别（面试）"><a href="#四、安全问题-amp-隔离级别（面试）" class="headerlink" title="四、安全问题&amp;隔离级别（面试）"></a>四、安全问题&amp;隔离级别（面试）</h1><ul>
<li><strong>不考虑隔离级别设置</strong>，那么会出现以下问题。</li>
</ul>
<h2 id="读-问题"><a href="#读-问题" class="headerlink" title="读  问题"></a>读  问题</h2><ul>
<li>脏读<br>一个事务读到另外一个事务还未提交的数据。</li>
<li>不可重复读<br>一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。</li>
<li>幻读<br>一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一致。</li>
</ul>
<h2 id="写-问题"><a href="#写-问题" class="headerlink" title="写  问题"></a>写  问题</h2><ol>
<li><p>丢失更新：<br>B事务如果提交，会造成A事务的操作无效。<br>B事务回滚，也会造成A事务更新失效。</p>
</li>
<li><p>解决方法：悲观锁，乐观锁</p>
</li>
</ol>
<ul>
<li><strong>悲观锁</strong><br>指事务在一开始就认为丢失更新一定会发生， 这是一件很悲观的事情。 具体操作步骤如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.所以事务在执行操作前，先查询一次数据， 查询语句如下：</span><br><span class="line">	select * from student  <span class="keyword">for</span> update  ;           </span><br><span class="line">	后面的<span class="keyword">for</span> update 其实是数据库锁机制 、 一种排他锁。</span><br><span class="line"></span><br><span class="line">2.哪个事务先执行这个语句， 哪个事务就持有了这把锁， 可以查询出来数据， 后面的事务想再执行这条语句，不会有任何数据显示，就只能等着。 </span><br><span class="line"></span><br><span class="line">3.一直等到前面的那个事务提交数据后， 后面的事务数据才会出来，那么才可以往下接着操作。</span><br><span class="line"> </span><br><span class="line">4.补充：就像排队上厕所一样，只有里面的人出来了，才能进去。 这其实就是 java 中的同步的概念。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>乐观锁</strong><br>乐观锁是指，从来不会觉得丢失更新会发生。要求程序员在数据库中添加字段，然后在后续更新的时候，对该字段进行判定比对， 如果一致才允许更新。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例：</span><br><span class="line">1.数据库表中，额外添加了一个version字段， 用于记录版本， 默认从0 开始， 只要有针对表中数据进行修改的，那么version就+1.</span><br><span class="line"></span><br><span class="line">2.开启A事务， 然后开启B事务 。</span><br><span class="line"></span><br><span class="line">3.A 先执行数据库表操作。 因为以前都没有人修改过。 所以是允许A事务修改数据库的，但是修改完毕，就把version的值变成  1 了 。</span><br><span class="line"></span><br><span class="line">4.B事务， 这时候如果想执行修改，那么是不允许修改的。 因为B事务以前是没有查询过数据库内容的，所以它认为数据库版本还是0 。 但是数据库的版本经过A修改，已经是1了。</span><br><span class="line">所以这时候不允许修改， 要求其重新查询 。</span><br><span class="line"></span><br><span class="line">5.B重新查询后， 将会得到version 为 1的数据，这份数据就是之前A 事务修改的数据了， B 在进行修改，也是在A的基础上修改的。 所以就不会有丢失更新的情况出现了。</span><br><span class="line"></span><br><span class="line">补充：乐观锁的机制 ，其实是通过比对版本或者比对字段的方式来实现的，与版本控制软件【SVN , GIT】机制是一样的。</span><br></pre></td></tr></table></figure>

<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 按效率划分，从高到低</span><br><span class="line">	读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</span><br><span class="line"></span><br><span class="line">- 按拦截程度 ，从高到底</span><br><span class="line">	可串行化 &gt; 可重复读  &gt; 读已提交  &gt;  读未提交</span><br></pre></td></tr></table></figure>
<ul>
<li>Read Uncommited【读未提交】<br>指的是 ： 一个事务可以读取到另一个事务还未提交的数据。 这就会引发 “脏读” 读取到的是数据库<strong>内存</strong>中的数据，而并非真正磁盘上的数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例子： </span><br><span class="line">1.开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">设置当前窗口的事务隔离级别为：读未提交  命令如下：</span><br><span class="line">	<span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> uncommitted;</span><br><span class="line">2.另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交</span><br><span class="line">3.在A窗口重新执行查询， 会看到B窗口没有提交的数据。</span><br></pre></td></tr></table></figure>
<ul>
<li>Read Commited 【读已提交】<br>与前面的读未提交刚好相反，这个隔离级别是 ，只能读取到其他事务已经提交的数据，那些没有提交的数据是读不出来的。屏蔽了脏读的情况，但是这会造成一个问题是： 前后读取到的结果不一样。 发生了不可重复!!!, 所谓的不可重复读，就是不能执行多次读取，否则出现结果不一样。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line"> 设置当前窗口的事务隔离级别为：读已提交  命令如下：</span><br><span class="line">	<span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> committed;</span><br><span class="line">2. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">3. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">4. 在B窗口执行提交。</span><br><span class="line">5. 在A窗口中执行查看， 这时候才会看到B窗口已经修改的结果。</span><br><span class="line">6. 但是这会造成一个问题是： 在A窗口中， 第一次查看数据和第二次查看数据，结果不一样。</span><br></pre></td></tr></table></figure>
<ul>
<li>Repeatable Read 【重复读】<br>MySql 默认的隔离级别就是这个。该隔离级别， 可以让事务在自己的会话中重复读取数据，并且不会出现结果不一样的状况，即使其他事务已经提交了，也依然还是显示以前的数据。（读到的不是最新更新的数据，确保本事务不受其他事务影响）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2. 设置当前窗口的事务隔离级别为：重复读  命令如下：</span><br><span class="line">	<span class="built_in">set</span> session transaction isolation level repeatable <span class="built_in">read</span>;</span><br><span class="line">3. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">5. 在B窗口执行提交。</span><br><span class="line">6. 在A窗口中执行查看， 这时候查询结果，和以前的查询结果一致。不会发生改变。</span><br></pre></td></tr></table></figure>
<ul>
<li>Serializable 【可串行化（序列化）】<br>该事务级别是最高级的事务级别了，如果有一个连接设置隔离级别为可串行化，那么谁先打开事务，谁就有了先执行的权利，谁后打开事务，就只能等着，等前面的那个事务，提交或者回滚后才会执行。这种隔离级别比前面几种都要强大一点，也就是前面几种的问题【脏读、不可重复读、幻读】都能够解决。但是都使用该隔离级别也会有些问题。 比如造成并发的性能问题。 其他的事务必须得等当前正在操作表的事务先提交，才能接着往下，否则只能一直在等着。所以比较少用，容易造成性能上的问题，效率比较低。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2.设置当前窗口的事务隔离级别为：serializable 命令如下：</span><br><span class="line">	<span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> serializable;</span><br><span class="line">3.另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4.在A窗口重新执行查询， 会卡主，没有任何信息显示。 </span><br><span class="line">5.在B窗口执行提交。</span><br><span class="line">6.在A窗口中执行查看， 这时候才会显示结果。</span><br></pre></td></tr></table></figure>



<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>1.在代码里面使用事务 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">conn.commit();</span><br><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure>
<p>2.事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。<br>3.事务是会自动提交的。<br>4.安全隐患：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">读</span><br><span class="line">	脏读：一个事务读到了另一个事务未提交的数据。</span><br><span class="line">	不可重复读：一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致。</span><br><span class="line">	幻读：一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。</span><br><span class="line">写</span><br><span class="line">	丢失更新。</span><br></pre></td></tr></table></figure>

<p>5.隔离级别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">读未提交</span><br><span class="line">&gt; 引发问题： 脏读 </span><br><span class="line">读已提交</span><br><span class="line">&gt; 解决： 脏读 ， 引发： 不可重复读</span><br><span class="line">可重复读</span><br><span class="line">&gt; 解决： 脏读 、 不可重复读 ， 未解决： 幻读</span><br><span class="line">可串行化</span><br><span class="line">&gt; 解决： 脏读、 不可重复读 、 幻读。  导致：性能下降</span><br></pre></td></tr></table></figure>
<p>6.补充：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mySql 默认的隔离级别是 可重复读</span><br><span class="line">Oracle 默认的隔离级别是  读已提交</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>建站系列之---美化网站</title>
    <url>/551144596/</url>
    <content><![CDATA[<p><strong>说明：</strong> 展现在你眼前的，只是部分功能，很基础的，根据个人喜好，如果说追求美观，那么多去找一些方案，网上很多美化小技巧，装饰在自己博客上面，看着也赏心悦目，但是装饰太对，终究会拖加载速度的后腿，这就需要更多的技术来优化，例如SEO优化，但是博客嘛，以简洁为主还是很好的。不要太多了累赘，反而看着很舒服！</p>
<a id="more"></a>
<h2 id="更换Next主题"><a href="#更换Next主题" class="headerlink" title="更换Next主题"></a>更换Next主题</h2><ul>
<li>在<code>blog</code>文件夹下，右键打开<code>git bash here</code>，输入：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>可以看到<code>themes</code>文件夹下多了一个<code>next</code>文件，这就是next主题文件。</p>
<ul>
<li>启用主题：打开<code>F: \ blog \ _config.yml</code>,找到 <code>theme</code> 标签，更改为：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>F:\blog\themes\next\_config.yml</code>,找到<code>scheme</code>，启用<code>pisices</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line">	<span class="comment">#scheme: Muse</span></span><br><span class="line">	<span class="comment">#scheme: Mist</span></span><br><span class="line">	scheme: Pisces</span><br><span class="line">	<span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h2 id="网站基本设置"><a href="#网站基本设置" class="headerlink" title="网站基本设置"></a>网站基本设置</h2><ul>
<li>打开<code>F: \ blog \ _config.yml</code>,找到 <code>Site</code> 标签</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Site</span></span><br><span class="line">title: 代澳旗's Blog</span><br><span class="line"><span class="selector-tag">subtitle</span>: <span class="selector-tag">Welcome</span> <span class="selector-tag">to</span> <span class="selector-tag">my</span> <span class="selector-tag">World</span>！！！</span><br><span class="line"><span class="selector-tag">description</span>: 这是我在学习过程中用<span class="selector-tag">hexo</span>搭建的一个基于<span class="selector-tag">github</span>的个人博客网站，用来存储学习笔记！</span><br><span class="line">keywords: ''</span><br><span class="line"><span class="selector-tag">author</span>: 代澳旗</span><br><span class="line"><span class="selector-id">#avatar</span>: 网站头像外部链接 </span><br><span class="line"><span class="selector-tag">language</span>: <span class="selector-tag">zh-Hans</span></span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h2 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h2><ul>
<li>打开站点配置文件，修改如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /about/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打开命令行，输入：<code>hexo  n page categories</code>其他的页面也是如此。会看到<code>source</code>文件夹下有相应的文件生成。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305221225718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>打开里面的<code>index.md</code>，添加一个字段<code>type： categories</code>，其他的也是如此</li>
</ul>
<h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><ul>
<li>找到主题文件<code>F:\blog\themes\next\_config.yml</code>改为 true</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Canvas-nest</span></span><br><span class="line"><span class="selector-tag">canvas_nest</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>
<h2 id="鼠标点击效果图"><a href="#鼠标点击效果图" class="headerlink" title="鼠标点击效果图"></a>鼠标点击效果图</h2><ul>
<li>在<code>F:\blog\themes\next\source\js\src</code>里新建<code>love.js</code>，写入以下内容</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>F:\blog\themes\next\layout\_layout.swig</code>,在末尾添加代码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击效果 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/love.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h2><ul>
<li>找到主题文件<code>F:\blog\themes\next\_config.yml</code>，找到<code>since</code>标签</li>
</ul>
<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><ul>
<li>将头像图片放到<code>F:\blog\themes\next\source\images</code></li>
<li>打开<code>F:\blog\themes\next\_config.yml</code>，找到<code>avatar</code>，修改如下代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">avatar: /images/touxiang.jpg</span><br></pre></td></tr></table></figure>
<h2 id="修改网站图标"><a href="#修改网站图标" class="headerlink" title="修改网站图标"></a>修改网站图标</h2><ul>
<li>图标素材网站：<a href="https://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.d2b281273&type=2">iconfont</a></li>
<li>下载16x16以及32x32大小的PNG格式图标，置于<code>/themes/next/source/images/</code>下</li>
<li>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>favicon</code>，修改要更换的图标名字即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/wangzhantubiao-16.png</span><br><span class="line">  medium: /images/wangzhantubiao-32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加<code>RSS</code></h2><ul>
<li>在<code>Git bash here</code>中添加插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure>
<ul>
<li>在站点配置文件中添加如下代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line">plugin: hexo-generator-feed</span><br></pre></td></tr></table></figure>

<ul>
<li>在主题配置文件下添加</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h2 id="添加fork-me-Github"><a href="#添加fork-me-Github" class="headerlink" title="添加fork me Github"></a>添加fork me Github</h2><ul>
<li><p>点击<a href="https://github.blog/2008-12-19-github-ribbons/">http://tholman.com/github-corners/</a>挑选自己喜欢的样式，并复制代码。</p>
</li>
<li><p>找到<code>themes/next/layout/_layout.swig</code>文件，(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>改为你的<code>github</code>地址。</p>
<h2 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h2></li>
<li><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;i <span class="class"><span class="keyword">class</span>="<span class="title">fa</span> <span class="title">fa</span>-<span class="title">tag</span>"&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><ul>
<li>在 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code><br>文件,添加你想说的内容：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------结束啦&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>打开<code>\themes\next\layout\_macro\post.swig</code>文件，在 <code>&lt;footer class=&quot;post-footer&quot;&gt;</code> 之后， <code>post-footer</code> 之前添加：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h2><ul>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install gulp -g</span><br><span class="line">cnpm install gulp-minify-css gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>blog</code>下面新建<code>gulpfile.js</code>,写入：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">// 压缩 public 目录 css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public 目录 html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/js 目录 js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<ul>
<li>以后在生成博文是执行 <code>hexo g &amp;&amp; gulp</code>就会根据 <code>gulpfile.js</code> 中的配置，对 <code>public</code> 目录中的静态资源文件进行压缩。</li>
</ul>
<h2 id="修改代码块自定义样式"><a href="#修改代码块自定义样式" class="headerlink" title="修改代码块自定义样式"></a>修改代码块自定义样式</h2><ul>
<li>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//代码块自定义样式</span><br><span class="line">// Custom styles. </span><br><span class="line">code &#123;</span><br><span class="line">    color: <span class="comment">#ff7600;</span></span><br><span class="line">    background: <span class="comment">#fbf7f8;</span></span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid <span class="comment">#d6d6d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="侧边栏社交链接小图标"><a href="#侧边栏社交链接小图标" class="headerlink" title="侧边栏社交链接小图标"></a>侧边栏社交链接小图标</h2><ul>
<li>打开<code>F:\blog\themes\next\_config.yml</code>,搜索<code>social_icons:</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/DAQ121 || github</span><br><span class="line">  csdn: https://blog.csdn.net/weixin_44861399 || crosshairs</span><br><span class="line">  weibo: https://weibo.com/呜啦啦咦1 || weibo</span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#weibo: weibo</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  csdn: crosshairs</span><br><span class="line"></span><br><span class="line">  icons_only: <span class="literal">false</span></span><br><span class="line">  transition: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><ul>
<li>打开<code>/themes/next/layout/_macro/post.swig</code>,加上<code>&lt;span&gt;°C&lt;/span&gt;</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200306112055151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>打开<code>/themes/next/languages/zh-Hans.yml</code>，找到<code>visitors</code>标签，改为热度。</li>
</ul>
<h2 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h2><ul>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer</span><br><span class="line">npm install hexo-tag-aplayer</span><br></pre></td></tr></table></figure>
<ul>
<li>在网易云音乐生成外链，复制代码</li>
<li>打开<code>F:\blog\themes\next\layout\_macro</code>里的<code>sidebar.swig</code>，在此处添加复制胡链接</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200308110931114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h2><ul>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"theme-info"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"powered-by"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=<span class="string">"post-count"</span>&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="实现统计功能"><a href="#实现统计功能" class="headerlink" title="实现统计功能"></a>实现统计功能</h2><ul>
<li>在主题配置文件中，配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: <span class="literal">true</span></span><br><span class="line">  wordcount: <span class="literal">true</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  totalcount: <span class="literal">false</span></span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><ul>
<li>打开：<code>/themes/next/layout/_partials/head.swig</code>，添加代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改网页底部的桃心"><a href="#修改网页底部的桃心" class="headerlink" title="修改网页底部的桃心"></a>修改网页底部的桃心</h2><ul>
<li>打开：<code>/themes/next/layout/_partials/footer.swig</code>，修改你想用的图标</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;span class=<span class="string">"with-love"</span>&gt;</span><br><span class="line">   &lt;i class=<span class="string">"far fa-grin-tongue-wink"</span>&gt;&lt;/i&gt;</span><br><span class="line"> &lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h2 id="添加百度分享"><a href="#添加百度分享" class="headerlink" title="添加百度分享"></a>添加百度分享</h2><ul>
<li>给next主题添加了百度分享功能,在本地一切正常,但是当发布到github的时候,却不能正常显示，因为github上百度分享不支持在https上使用。</li>
<li>所以将主题配置<code>_config.yml</code>文件中关于<code>baidushare</code>部分的内容改为（其中<code>type</code>亦可以选择<code>button</code>）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  <span class="built_in">type</span>: slide</span><br><span class="line">  baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下载<code>static</code>文件夹，地址：<a href="https://github.com/hrwhisper/baiduShare">https://github.com/hrwhisper/baiduShare</a>，将<code>static</code>文件夹保存至<code>themes\next\source</code>目录下。</li>
<li>修改文件：<code>themes\next\layout_partials\share\baidushare.swig</code><br>末尾部分的代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.src=<span class="string">'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='</span>+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.src=<span class="string">'/static/api/js/share.js?v=89860593.js?cdnversion='</span>+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04系统安装，修改源</title>
    <url>/linux/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于疫情在家，看着家里有一台吃了一两年灰的台式电脑，大概是初三的时候买的，抹一下灰就跟新的一样，哈哈，于是突然心生一计，就开始动手整理这台电脑，首先重装系统，不过这次，我装的是win10+Ubuntu18.04双系统。</p>
<a id="more"></a>

<h1 id="一-准备："><a href="#一-准备：" class="headerlink" title="一. 准备："></a>一. 准备：</h1><ul>
<li><strong>终端如何复制粘贴？</strong><br>在文本区域左键复制，到终端里面直接按下鼠标滚轮即可。</li>
<li><strong>如何切换root权限？</strong><br>安装之后root是不设置密码的，以普通用户输入su  root按照步骤设置自己的密码</li>
</ul>
<h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><ul>
<li>大于4G的U盘一只，事先将里面的文件备份到电脑中。</li>
</ul>
<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>下载Ubuntu系统镜像——-后缀.iso的配置文件。因为是外网，所以去官网下载需要自备**（真是把我累伤心了），于是我找到了国内的开源网站：<a href="http://mirrors.163.com/ubuntu-releases/14.04/">https://blog.csdn.net/davidhzq/article/details/102575343</a></p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>  制作U盘启动盘—–需要下载USBWiter这个工具用来写入ISO镜像，下载地址：<a href="http://mydown.yesky.com/pcsoft/413551662.html">http://mydown.yesky.com/pcsoft/413551662.html</a><br> 解压后打开小工具：</p>
<p><img src="https://img-blog.csdnimg.cn/20200209220859288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p> 还要在硬盘腾出一块空间用来安装Ubuntu系统，具体操作如下：以管理的身份打开“我的电脑”，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200209221926433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200209222255142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 压缩完之后，就不用管了，会看到你刚才压缩的那个卷之后，会有一块空闲的空间。</p>
<h1 id="二-开始安装："><a href="#二-开始安装：" class="headerlink" title="二.开始安装："></a>二.开始安装：</h1><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><ul>
<li>拿着你做好的U盘，插到你要安装系统的电脑上，在开机的时候，会看到：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020021012440214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>如果没有的话，可能是你开机设置里不允许用U盘启动，我当时就遇到了这种情况，然后狂点F12，进入BIOS，主要是为了进入BIOS，不同型号的电脑按键不一样，自己上网查，按如下图设置后，按F10，保存并重启。<br><img src="https://img-blog.csdnimg.cn/2020021012462934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h3><p><img src="https://img-blog.csdnimg.cn/202002092238476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209223948185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209224129521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200209224527382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209224741212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020020922495535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>后面就一步一步点击继续就可以了，最后等待安装完成</strong></p>
<h2 id="在安装过程中遇到的问题："><a href="#在安装过程中遇到的问题：" class="headerlink" title="在安装过程中遇到的问题："></a>在安装过程中遇到的问题：</h2><p><img src="https://img-blog.csdnimg.cn/20200210125455148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200210125505598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200210125606591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最后的最后，还是一个人抗下了所有，安装崩溃了，我心态也奔溃了，但是重振旗鼓，找到问题：GRUB的引导问题，也找到了解决方案：<a href="https://blog.csdn.net/weixin_44123547/article/details/103243238">https://blog.csdn.net/weixin_44123547/article/details/103243238</a><br>最终还是安装完成了：</p>
<p><img src="https://img-blog.csdnimg.cn/20200210125944723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="三-修改源："><a href="#三-修改源：" class="headerlink" title="三. 修改源："></a>三. 修改源：</h1><p>因为Ubuntu默认下载源是国外源，我们修改为国内源，我改的是清华的源。<br>打开终端，<strong>切换到root权限</strong>输入以下命令：</p>
<h2 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>
<h2 id="2、修改sources-list文件"><a href="#2、修改sources-list文件" class="headerlink" title="2、修改sources.list文件"></a>2、修改sources.list文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi sources.list</span><br></pre></td></tr></table></figure>
<h2 id="3、修改源（复制进去）"><a href="#3、修改源（复制进去）" class="headerlink" title="3、修改源（复制进去）"></a>3、修改源（复制进去）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>
<h2 id="4、-更新源"><a href="#4、-更新源" class="headerlink" title="4、 更新源"></a>4、 更新源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>完成后，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h2 id="5、大功告成"><a href="#5、大功告成" class="headerlink" title="5、大功告成"></a>5、大功告成</h2>]]></content>
      <categories>
        <category>linux学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>入门设计模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目开发过程中，经过验证的解决方案，用于解决在特定环境下、重复出现的某些特定问题。前人栽树，后人乘凉，日常写代码，很少有创新，因为所做的80%都已经由前辈实现了，所以我们在学习过程中，要善于利用前辈们总结出来的经验。帮助我们少走弯路。</p>
<a id="more"></a>


<h2 id="23种设计模式概览"><a href="#23种设计模式概览" class="headerlink" title="23种设计模式概览"></a>23种设计模式概览</h2><ul>
<li>总体上分为三类：</li>
</ul>
<p><strong>①创建型模式：</strong>  用于创建对象<br><strong>②结构型模式：</strong> 用于处理类和对象的组合。<br><strong>③行为型模式：</strong> 描述类和对象之间的交互和怎样分配职责。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>创建型</td>
<td>工厂方法模式、抽象工厂模式、<strong>单例模式、</strong> 建造者模式、<strong>原型模式</strong>。</td>
</tr>
<tr>
<td>结构型</td>
<td>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</td>
</tr>
<tr>
<td>行为型</td>
<td>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</td>
</tr>
</tbody></table>
<ul>
<li>还有一种分类方式是：并发性模式与线程池模式。不做论述。</li>
</ul>
<h2 id="为什么要使用设计模式？"><a href="#为什么要使用设计模式？" class="headerlink" title="为什么要使用设计模式？"></a>为什么要使用设计模式？</h2><p>①学习设计模式对提高技术能力很有帮助。<br>②不用重复造轮子。<br>③节省大部分时间</p>
<h2 id="使用设计模式有什么好处？"><a href="#使用设计模式有什么好处？" class="headerlink" title="使用设计模式有什么好处？"></a>使用设计模式有什么好处？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老生常谈，所有的技术，存在即合理，一种技术。无非就是，节省写代码的时间，提高代码的健壮性，可维护性，复用性，简化问题。</p>
<h2 id="反模式是什么？"><a href="#反模式是什么？" class="headerlink" title="反模式是什么？"></a>反模式是什么？</h2><ul>
<li>是指用来解决问题的带有共同性的不良方法。它们已经经过研究并分类，以防止日后重蹈覆辙，并能在研发尚未投产的系统时辨认出来。简单的来说，<strong>反模式</strong>是指在对经常面对的问题使用低效，不良，或者有待优化的设计模式。</li>
<li>举例：在面向对象设计/编程中，单一责任原则，其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能，有的类里有几千行的代码，有很多功能，但是责任不明确单一。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是有意而为的。久而久之代码累计，符合单一原则类慢慢的变的臃肿起来。</li>
<li>总之，开发过程中，肯定会不幸的陷入反模式中，这就与初衷背道而驰了，所以我们熟练掌握设计模式，并且研究反模式，尽量避免反模式情况的发生，防患于未然！</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---内存管理</title>
    <url>/4128545857/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习计算机操作系统的时候，CPU调度，进程管理，内存管理，是最最重要的，尤其是内存管理，要领悟这其中的理念。对编程来讲，代码实际没有问题了，而且经常要考虑的就是内存了。</p>
<a id="more"></a>

<h2 id="一、小知识"><a href="#一、小知识" class="headerlink" title="一、小知识"></a>一、小知识</h2><ul>
<li><p><code>socket</code>是指套接字，原义是接口。</p>
</li>
<li><p><code>Agent</code>：智能体</p>
</li>
<li><p><code>Architect</code>：架构师</p>
</li>
<li><p>每个进程都有一个系统给定的权限，不能做超出自己权限的事。</p>
</li>
<li><p>cpu，内存，文件：是操作系统最具代表性的资源。</p>
</li>
<li><p><strong>逻辑地址（虚拟地址，偏移地址）</strong> 这个地址都是由cpu发出的地址（程序运行的时候，我们看的到的地址）</p>
</li>
<li><p><strong>物理地址：</strong> 真实存在的，计算机里实实在在的内存，从0开始。</p>
</li>
<li><p><strong>MMU内存管理单元：</strong> (Memory Management Unit)作用：把逻辑地址映射到物理地址，是CPU内部的一个小部件。</p>
</li>
<li><p>cpu只能访问（内存/寄存器）。所以对内存的管理很重要。</p>
</li>
<li><p>内存管理的主要问题：给每个进程分配内存的时候，内存怎么放？放多少？</p>
</li>
</ul>
<h2 id="二、内存分配策略"><a href="#二、内存分配策略" class="headerlink" title="二、内存分配策略"></a>二、内存分配策略</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul>
<li>每个进程的寄存器中都包括<code>Base</code>（基质寄存器和<code>Limit</code>（内存地址上限寄存器）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200328101305708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>当进程发出访问地址请求的时候，就要做两次验证，这就是安全保护的基本策略，限制了访问范围只能在（base-limit）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200328101818474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>但是这样每次访问都要验证，会带来很大速度时间延迟，怎么解决呢？</li>
<li>每一个进程，每个程序的每次运行，被放在内存中的位置是不固定的。这怎么解决呢？<br>这就涉及到一个，指令和数据在内存当中地址绑定的一个问题。</li>
</ul>
<h3 id="加载时刻（Load-time）"><a href="#加载时刻（Load-time）" class="headerlink" title="加载时刻（Load time）"></a>加载时刻（Load time）</h3><ul>
<li><code>Load time</code>（加载时刻）编译器编译运行的时候，并不知道程序会被放在内存的哪个位置。我们可以通过设定一些标记。当程序被加载到内存的时候，这个加载程序（loader）知道要放在哪个位置，放入之后，他就对这个程序里的所有（对地址访问的代码的数值）进行一个完整的修改，修改为目前放的位置。这个策略（由loader做动态的复制）很好的解决了多进程同时存在的问题。</li>
</ul>
<h3 id="执行时处理（Execution-time）"><a href="#执行时处理（Execution-time）" class="headerlink" title="执行时处理（Execution time）"></a>执行时处理（Execution time）</h3><ul>
<li>最好的策略：<code>Execution time</code>（执行时处理）不仅可以在内存中放多个进程。而且这个程序已经在内存的时候，甚至可以挪动他。但需要硬件支持，通过修改base的值，就可以实现挪动进程在内存中的位置。</li>
</ul>
<h2 id="三、内存管理策略"><a href="#三、内存管理策略" class="headerlink" title="三、内存管理策略"></a>三、内存管理策略</h2><ul>
<li>目的是是内存空间利用率最大化，尽量让他放更多的进程，为了做到这一点，设计了很多策略<h3 id="动态加载（Dynamic-Loading）"><a href="#动态加载（Dynamic-Loading）" class="headerlink" title="动态加载（Dynamic Loading）"></a>动态加载（Dynamic Loading）</h3></li>
<li>解决的问题：程序运行到退出，并不会把所有的代码都执行一遍，总有一些用不到的。那为什么要把所有的程序代码都加载到内存呢？<strong>动态加载</strong> 就可以很好的解决这个问题，只加载要用的部分，不用的部分不加载。这样使得内存空间利用率获得很大的提升。</li>
<li>局部性原理</li>
<li>DLL:动态链接库（Dynamic Link Library），可以看到我们下载的许多软件中，有很多后缀名为<code>.dll</code>的文件，这就是动态链接库。使用有很多好处。<br>①需要使用某个功能的时候，就去加载这个<code>.dll</code>文件。这就实现了动态加载。<br>②很好的实现了共享，他在内存中只存在一份，但是很多程序都可以使用他。<br>③很容易更新，windows主要更新的漏洞就是这个<code>.dll</code>文件。</li>
</ul>
<h3 id="交换技术（Swapping）"><a href="#交换技术（Swapping）" class="headerlink" title="交换技术（Swapping）"></a>交换技术（Swapping）</h3><ul>
<li>解决的问题：系统中有好多进程在运行，但是有些时候有的进程已经占据了内存，由于各种原因，这个进程属于休眠状态，好长时间不会运行，但是又有进程要进来，却没有空间。这就形成了内存空间的浪费。怎么解决呢？</li>
<li>将这个占着茅坑不拉屎的进程写到硬盘上去，这个内存空间就腾出来了。过一会儿时间，它又具备了运行条件，就把他写进来。</li>
<li>好处：用硬盘做他的补充，就好像内存变大了一样，可以放更多的进程。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200328140456436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="连续分配（Contiguous-Allocation）"><a href="#连续分配（Contiguous-Allocation）" class="headerlink" title="连续分配（Contiguous Allocation）"></a>连续分配（Contiguous Allocation）</h3><ul>
<li>现在操作系统中已经很少用了</li>
<li>首次适应算法（使用最多），下次适应算法，最佳适应算法，最差适应算法</li>
<li>最大的问题：对内存的申请释放的随机性， 无法很好的适应它，就不能保证用量很好。</li>
<li>对编程人员：对内存的使用可以是随机的，也可以自己来设定，总结出来规律之后，就能更好的管理这块儿空间。但是<strong>你申请到了内存，其实你并没有得到她，当你真正访问它的时候，才得到</strong></li>
<li>碎片（外部碎片&amp;内部碎片）</li>
</ul>
<h2 id="四、页式存储管理（重点）"><a href="#四、页式存储管理（重点）" class="headerlink" title="四、页式存储管理（重点）"></a>四、页式存储管理（重点）</h2><ul>
<li>内部碎片：页式存储管理是产生外部碎片的罪魁祸首。因为计算机分配内存是按照2的指数次幂个字节来分配，比如说，4字节，8字节，16字节，但是进程有的时候用不完这些，比如只需要5字节，就会多出来3字节，这就成了碎片。</li>
<li>特点：<br>①非连续性：（<strong>物理空间非连续</strong>）进程在物理内存中占据哪些内存，是不连续的，会把进程切成小碎片，散落在各个区域，（<strong>逻辑空间非连续</strong>）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200330210147149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>从图中可以看出，进程在内存中保存的位置是散乱的，这样带来的好处就是，每一个页面都会被利用到，不会产生外部碎片，使得物理内存管理起来非常方便。但是这样做还是很麻烦。</li>
<li><strong>为什么页面大小是2的整数次幂？</strong><br>如果不是2的整数次幂，就没有办法计算偏移地址，没办法从中间分隔开， 神奇的二进制。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200330215903204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200330215821402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>页式存储管理：也许这图只有我自己才能看懂吧，口头概述加深记忆，从<strong>逻辑地址</strong> 中拿出编号，写成四位二进制数，因为每页是四个字节（2的2次幂），所以要从第二位切一刀，（如果每页面是八字节，2的3次方，就要从第三位切）前面的是虚页号，后面的是页内偏移地址，根据虚页号，在页表中找到对应的物理页号，在将物理页号写成二进制数，加在虚页号前面，拼接成一个新的二进制数，然后再转化为十进制数，根据得到的数字，就可以找到<strong>物理地址</strong> 中对应的数据<br><img src="https://img-blog.csdnimg.cn/20200330222802562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>这个页面越大越好吗？</strong> （页面的大小是2的整数次幂）<br>①页面小的话，内部碎片越少，但是会增加页表的大小（有多少个页面，页表里就要有多少个项），每一个页表项都是要占空间的，他在内存中。这样的话虚拟地址到物理地址的映射就会慢。<br>②页面大的话，内部碎片就变多了，页表会减少。虚拟地址到物理地址的映射会很快。<br>③折中（4k的页面用的多），所以要看使用情况的不同了，对大进程来说，页表的体积就会缩小，从内部碎片来看，进程也不多，浪费就浪费吧。<br>④在未来开发或者管理过程中，都可以通过改变页面大小调优，从而提高系统效率，内存使用更充分。（调整一定要遵从硬件的架构）<br><img src="https://img-blog.csdnimg.cn/20200331094630441.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>页表是怎么实现的？</strong><br>在内存中，有两个参数，放在寄存器中，一个叫页表基址寄存器（指向页表起始位置），页表长度寄存器（页表的长度），这两个地址都是绝对的物理地址，不跟虚拟进程有任何的瓜葛。</p>
</li>
<li><p><strong>问题：数据，指针每次都要访问两次内存。</strong>（先进内存查页表，得到物理地址，再进内存中查到该数据。）怎么解决？<br>用<strong>TLB（ranslation look-aside buffers）</strong> 快表—相当于硬件的cache，思想也是跟cache一样（加快访问内存的速度）。cache是将当前最热的数据放在里面。TLB也是如此，把你当前用到的，最热的拿过来放入表中，就省去了根据虚页号去查物理页号。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200330230414986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>在快表中，存储的多了，查找起来也费时间，那么怎么加快查找速度呢？</strong><br>使用硬件<strong>并行搜索</strong> （涉及到电路问题），软件实现并行很麻烦，但硬件很简单。只用查找一次。如果一次没找到（未命中），就会去普通的页表查找，并且更新到快表中。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200330231019913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><ul>
<li>如何实现多个进程互相之间不能访问到彼此的内存？<br>对指令严加把控，读，写，执行。<strong>Valid-invalid bit（有效无效位）</strong> 有效V即可访问。无效i触发一个中断，操作系统意识到这个进程执行了一个非法操作，就会杀死该进程。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331102926413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul>
<li>在页式存储管理中，实现内存共享是简单的。该共享的就共享，该私有就私有</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331103841486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Copy-on-write(写时复制)<h3 id="两级-三级页表结构（Two-Level-Page-Table-Scheme）"><a href="#两级-三级页表结构（Two-Level-Page-Table-Scheme）" class="headerlink" title="两级/三级页表结构（Two-Level Page-Table Scheme）"></a>两级/三级页表结构（Two-Level Page-Table Scheme）</h3></li>
<li>由外层页表算出来，对应的是哪个项，再根据这个项，找到对应的内存页表，再根据虚页号，找到物理页号，进而找到对应的实际物理地址。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331105513611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>4k物理页面的页内偏移是12位（因为4k=2的12次方），剩下的20位属于页面号。然后再将这20位页面号分割成两部分。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331110258645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>在根据p1（前面页面号）和p2（内存页面号），查找。<br><img src="https://img-blog.csdnimg.cn/20200331110450735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>64位系统如果采用两级页面的话，就要维护42位的前面页面号。这是一个很大的开销，所以出现了三级页表，再将页面好进行划分。64位系统的开销比32位的大。<strong>现在的64位系统采用的就是三级页表。</strong></p>
</li>
</ul>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul>
<li>页表耗费的时间还是挺大的，出现了哈希表，这样在内存中维护的就不是页表，而是哈希表。但是哈希表存在碰撞。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331113521429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="反表（Inverted-Page-Table）"><a href="#反表（Inverted-Page-Table）" class="headerlink" title="反表（Inverted Page Table）"></a>反表（Inverted Page Table）</h3><ul>
<li><p>这是64位系统使用的方法，因为我们实际上要管理的是物理内存，如果把系统中所有进程的所有列表项放在一起看的话，这些页表项里，有用的，有价值的，只是那些和物理内存相对应的，没有对应关系的页表项是没有存在价值的。如果我们把所有没价值的列表项都扔掉，那么页表的体积就可以得到控制了。控制到：有多少个物理内存，有多少个物理页面，那么就有多少个页表项，一一对应。</p>
</li>
<li><p>全系统中只有一张页表。<strong>但是！！！</strong> 这种方法cpu不支持，我们现在用的方法就是多级页表。因为要兼容32位，64位。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331114757184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="五、段式内存管理（Segmentation）"><a href="#五、段式内存管理（Segmentation）" class="headerlink" title="五、段式内存管理（Segmentation）"></a>五、段式内存管理（Segmentation）</h2><ul>
<li>把程序分成若干段，程序段，代码段，栈，等等等等。在进程的逻辑空间中，自己划分出若干块，每块放不同的东西，执行不同的功能。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200331120344173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="六、段页式管理"><a href="#六、段页式管理" class="headerlink" title="六、段页式管理"></a>六、段页式管理</h2><ul>
<li>inter的cpu做得非常强大，你可以段式管理，页式管理，也可以段页式管理。</li>
<li>这是，我们目前cpu里面的机制，每执行一个指令，就要执行这个过程。<img src="https://img-blog.csdnimg.cn/20200331121145800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>结构型---代理模式</title>
    <url>/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给某一个对象提供一个代理或者占位符，并由代理对象来控制对原对象的访问。</p>
<a id="more"></a>

<h2 id="什么是代理模式？"><a href="#什么是代理模式？" class="headerlink" title="什么是代理模式？"></a>什么是代理模式？</h2><ul>
<li>当无法直接访问某个对象或者访问某个对象有一些困难时，可以通过代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。这就是代理模式。</li>
<li><strong>例如：</strong> 用户执行了某一简单的注册操作，当然在客户端代码中不仅仅只有注册这一功能的方法，还有其他的方法，比如说打印日志：<code>XXX于几月几日注册</code>，当然这些日志是不会返回给用户看到，这些是给开发人员看的，但是用户看到的注册功能和开发人员看到的日志功能要实现同一个接口，这时候就需要一个代理对象来松耦合，真实对象处理业务代码，代理对象处理非业务代码。</li>
<li><strong>定义：</strong> 给某一个对象提供一个代理或者占位符，并由代理对象来控制对原对象的访问。它去掉客户不能看到的内容和服务或者增加客户需要的额外的新服务。</li>
</ul>
<h2 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a>代理模式的结构</h2><ul>
<li>代理模式的核心结构就是代理类，<strong>为了使客户端 可以一致性的对待真实对象和代理对象，引入了抽象层</strong></li>
<li>真实类和代理类都实现了抽象接口，并且在代理类中维持一个真实类的引用<br>①在任何可以使用真实类的地方，都可以使用代理类。<br>②代理类还可以控制真实类的使用，因为代理类中有真实类的引用。<br>③实现了松耦合：真实类处理业务代码，代理类处理非业务代码。</li>
</ul>
<h2 id="代理模式的实现"><a href="#代理模式的实现" class="headerlink" title="代理模式的实现"></a>代理模式的实现</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>在一个商务查询的基础上加<strong>身份验证</strong>和<strong>打印日志</strong>的功能。当然，用户是看不到任何改变的，还是使用之前的用户查询功能。</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><ol>
<li><code>AccessValidator</code>身份验证类（业务类），提供<code>validate()</code>方法实现身份验证。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AccessValidator身份验证类（业务类），提供validate()方法实现身份验证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessValidator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//模拟实现登录验证</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(userId.equals(<span class="string">"代澳旗"</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"欢迎"</span>+userId+<span class="string">"回来！！"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"请重新登录！"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<code>Logger</code>日志记录类，提供<code>log()</code>方法来保存日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Logger:日志记录类，提供log()方法来保存日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		num++;</span><br><span class="line">		System.out.println(userId+<span class="string">"第"</span>+num+<span class="string">"次查询"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.<code>Searcher</code>：抽象查询接口，充当抽象类，声明<code>doSeacrh()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Searcher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">doSearcher</span><span class="params">(String userId,String keyword)</span> </span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.<code>RealSearcher</code>:具体查询类，充当真实类，只实现查询功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RealSearcher:具体查询类，充当真实类，只实现查询功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSearcher</span> <span class="keyword">implements</span> <span class="title">Searcher</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">doSearcher</span><span class="params">(String userId, String keyword)</span> </span>&#123;</span><br><span class="line">		System.out.println(userId+<span class="string">"使用"</span>+keyword+<span class="string">"关键词查询！"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"返回的详细信息"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.<code>ProxySearcher</code>代理查询类，维持了<code>RealSearcher对象</code>，<code>AccessValidator对象</code>，<code>Logger对象</code>的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ProxySearcher：代理查询类，</span></span><br><span class="line"><span class="comment"> * 维持了RealSearcher对象</span></span><br><span class="line"><span class="comment"> * AccessValidator对象</span></span><br><span class="line"><span class="comment"> * Logger对象的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySearcher</span> <span class="keyword">implements</span> <span class="title">Searcher</span></span>&#123;</span><br><span class="line">	<span class="comment">//维持了RealSearcher对象的引用。可以控制真实对象</span></span><br><span class="line">	<span class="keyword">private</span> RealSearcher realcher=<span class="keyword">new</span> RealSearcher();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//维持了AccessValidator对象，Logger对象的引用。</span></span><br><span class="line">    <span class="comment">//如果真实对象挂掉了，代理对象可以顶。</span></span><br><span class="line">	<span class="keyword">private</span> AccessValidator validator;</span><br><span class="line">	<span class="keyword">private</span> Logger logger;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">doSearch</span><span class="params">(String userId, String keyword)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//身份验证成功，执行查询</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.validate(userId)) &#123;</span><br><span class="line">			<span class="comment">//调用真实类对象，执行查询方法</span></span><br><span class="line">			String result=searcher.doSearch(userId,keyword);</span><br><span class="line">			<span class="comment">//记录日志</span></span><br><span class="line">			<span class="keyword">this</span>.log(userId);</span><br><span class="line">			<span class="comment">//返回结果</span></span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建验证访问对象，并调用其validate方法实现身份验证</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		validator=<span class="keyword">new</span> AccessValidator();</span><br><span class="line">		<span class="keyword">return</span> validator.validate(userId);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建日志对象，并调用其log方法实现打印日志</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">		logger=<span class="keyword">new</span> Logger();</span><br><span class="line">		logger.log(userId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.配置<code>config.xml</code>,在配置文件中存储代理主题类的全类名</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">	&lt;className&gt;com.daq.proxy.ProxySearcher&lt;/className&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure>
<p>7.<code>XMLUtil</code>：工具类，提供<code>getBean（）</code>方法，用于从XML配置文件中提取该具体类的名字，并返回一个实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 该方法用于从XML配置文件中提取该具体类的名字，并返回一个实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建DOM文档对象</span></span><br><span class="line">			DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">			DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">			Document doc;</span><br><span class="line">			doc = builder.parse(<span class="keyword">new</span> File(<span class="string">"src//designpatterns//Proxy//conf.xml"</span>));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">			NodeList nl=doc.getElementsByTagName(<span class="string">"className"</span>);</span><br><span class="line">			Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">			String cName=classNode.getNodeValue();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//通过类名生成实例对象并返回</span></span><br><span class="line">			Class c= Class.forName(cName);</span><br><span class="line">			Object obj = c.newInstance();</span><br><span class="line">			<span class="keyword">return</span> obj;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>8.客户端测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Searcher searcher;</span><br><span class="line">		searcher=(Searcher)XMLUtil.getBean();</span><br><span class="line">		String result=searcher.doSearch(<span class="string">"代澳旗"</span>, <span class="string">"https://daqwt.top"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代理类和真实类都是事先存在的，接口和代理方法也明确指定了，每个代理类编译之后都会生成class文件，这叫做<code>静态代理（Static Proxy）</code>新增功能也会增加类的个数，不利于管理，也会增加系统开销。</li>
<li>以上就是静态代理的实现思想了：在代理类中实现对真实类的权限控制，如果想新增功能，只需要增加一个相应的代理类，在修改配置文件，不用修改源码，但是这种静态代理的方式，实现起来，还是比较困难的。Java的动态代理，就可以很好地解决这个问题，在Spring框架的AOP中得以运用，而且整合封装之后使用更加简洁。</li>
</ul>
<h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><ul>
<li>可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实类，并且可以代理不同的方法，动态代理比较高级，在事务管理,AOP，都有着很大的作用。具体的动态代理实现方法，在后续学习AOP的时候去写。</li>
<li>通过动态代理可以实现对多个真实主题类的统一代理和集中控制</li>
<li>JDK中的动态代理只能代理一个或者多个接口，如果要动态代理某些具体类或者是抽象类，可以使用<code>GGLib</code>等工具，它是一款代码生成包。</li>
</ul>
<h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><ul>
<li>它使客户端程序可以访问到远程主机上的对象，远程业务在本地主机有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，客户端无需关心是谁来实现具体业务，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。在Java中通过<code>RMI机制</code>实现远程代理。（就是Java虚拟机中的对象调用另一个java虚拟机中的对象）</li>
</ul>
<h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><ul>
<li>对于一些占用系统资源比较多的或者加载时间长的对象，可以提供虚拟代理，在真实对象创建之前虚拟代理扮演真实对象的替身，而当真实对象创建之后虚拟代理将用户的请求转发给真实对象。</li>
<li><strong>以下两种情况下使用虚拟代理：</strong><br>①由于各种原因，对象的创建时间比较长，在实现是结合多线程，一个对象用于显示代理对象，其他线程用于加载真实对象。在程序启动的时候，用代理对象代替真实对象初始化，加速系统的启动时间，这种方式可以缩短用户等待的时间。<br>②当一个对象加载非常消耗资源的时候，虚拟代理可以让那些占用大量内存或处理起来比较麻烦的对象推迟到使用他们的时候在创建。访问对象时要进行存在性检测，这可能需要消耗系统时间，但是节省了内存空间，以时间换空间。</li>
</ul>
<h2 id="各模式的优缺点"><a href="#各模式的优缺点" class="headerlink" title="各模式的优缺点"></a>各模式的优缺点</h2><ul>
<li><p><strong>优点：</strong>  解耦，可扩展，灵活。</p>
</li>
<li><p><strong>远程代理：</strong> 为两个不同地址空间的对象提供一种实现机制，可以将一些资源消耗比较多的对象和操作移动至性能更好的计算机上，提高系统的整体运行效率。</p>
</li>
<li><p><strong>虚拟代理：</strong> 通过一个消耗资源比较少的对象来替代一个消耗资源比较多的对象，可以在一定程度上节约系统运行开销。</p>
</li>
<li><p><strong>缓冲代理:</strong> 为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这个结果，优化系统性能，缩短执行时间。</p>
</li>
<li><p><strong>保护代理：</strong> 控制一个对象的访问权限，为不同的用户提供不同的使用权限。</p>
</li>
<li><p><strong>缺点：</strong><br>①由于在客户端和真实类之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度慢，例如保护代理。<br>②代理的实现比较复杂。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链简单理解</title>
    <url>/2068677160/</url>
    <content><![CDATA[<p>对近年来很火的区块链的简单了解</p>
<a id="more"></a>
<h2 id="区块链是什么："><a href="#区块链是什么：" class="headerlink" title="区块链是什么："></a>区块链是什么：</h2><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。区块链（Blockchain），是比特币的一个重要概念，它本质上是一个<strong>去中心化的数据库</strong>，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。</p>
<h2 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h2><p>区块链起源于比特币，2008年11月1日，一位自称<strong>中本聪</strong>(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》，阐述了<strong>基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念</strong>，这标志着比特币的诞生。两个月后理论步入实践，2009年1月3日第一个序号为0的创世区块诞生。几天后2009年1月9日出现序号为1的区块，并与序号为0的创世区块相连接形成了链，标志着区块链的诞生。<br>近年来，世界对比特币的态度起起落落，但作为比特币底层技术之一的区块链技术日益受到重视。在比特币形成过程中，区块是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过<strong>随机散列(也称哈希算法)</strong> 实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链 。</p>
<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul>
<li><strong>从科技层面来看：</strong> 区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。</li>
<li><strong>从应用视角来看：</strong> 区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。这些特点保证了区块链的 <strong>“诚实”</strong> 与 <strong>“透明”</strong> ，为区块链创造信任奠定基础。而区块链丰富的应用场景，基本上都基于区块链能够解决信息不对称问题，实现多个主体之间的协作信任与一致行动。</li>
</ul>
<h2 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h2><ol>
<li><strong><em>公有区块链</em></strong>（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上<strong>有且仅有一条</strong>该币种对应的区块链。</li>
<li><strong><em>行业区块链</em></strong>（Consortium Block Chains)：由某个群体<strong>内部指定</strong>多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易，但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。</li>
<li><strong><em>私有区块链</em></strong>（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。</li>
</ol>
<h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ol>
<li>去中心化。区块链技术不依赖额外的第三方管理机构或硬件设施，没有中心管制，除了自成一体的区块链本身，通过分布式核算和存储，各个节点实现了信息自我验证、传递和管理。去中心化是区块链最突出最本质的特征。</li>
<li>开放性。区块链技术基础是<strong>开源的</strong>，除了交易各方的私有信息被加密外，区块链的数据对所有人开放，任何人都可以通过公开的接口查询区块链数据和开发相关应用，因此整个系统信息高度透明。</li>
<li>独立性。基于协商一致的规范和协议(类似比特币采用的哈希算法等各种数学算法)，整个区块链系统不依赖其他第三方，所有节点能够在系统内自动安全地验证、交换数据，不需要任何人为的干预。</li>
<li>安全性。只要不能掌控全部数据节点的51%，就无法肆意操控修改网络数据，这使区块链本身变得相对安全，避免了主观人为的数据变更。</li>
<li>匿名性。除非有法律规范要求，单从技术上来讲，各区块节点的身份信息不需要公开或验证，信息传递可以<strong>匿名进行</strong>。</li>
</ol>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型---单例模式</title>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式（<strong>Singleton Pattern</strong>）：确保一个类只有一个实例，并提供一个全局访问点来访问这一个唯一实例。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><strong>定义：</strong> 某个类只能有一个对象实例，并且这个类只提供一个获取该对象实例的方法（静态方法）。</li>
<li>单例设计模式涉及到的知识点还是特别多的，比如：类加载机制，JVM的指令重排，序列化之类的知识。这就很让人头痛。</li>
<li>核心思想：类内创建，类外获取，使用时创建（懒加载）。</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>①应用中某个实例对象需要频繁的被访问，如线程池，工具类对象，数据源，session工厂。<br>②应用中每次启动只会存在一个实例。如账号系统，数据库系统。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul>
<li>优点：<br>①对于一些需要频繁创建和销毁的对象，（如工具类对象，数据源，session工厂等…）使用单例模式提高新能，节省系统资源。<br>②只new一次即可，这就大大降低了系统内存的使用频率，减轻了GC的压力。<br>③有些核心类，控制着重要流程，如果该类可以创建多个的话，系统就会混乱。只有使用单例模式，才能保证核心服务器独立控制整个流程。</li>
<li>缺点：<br>①由于单例模式没有抽象层，因此单例类的扩展就有很大困难。<br>②单例类职责过重，一定程度上违背了单一职责原则。<br>③在垃圾回收的情况下，如果长时间不用，会被当做是垃圾回收掉。</li>
</ul>
<h1 id="五种写法"><a href="#五种写法" class="headerlink" title="五种写法"></a>五种写法</h1><h2 id="饿汉式（两种写法）"><a href="#饿汉式（两种写法）" class="headerlink" title="饿汉式（两种写法）"></a>饿汉式（两种写法）</h2><h3 id="（一）静态常量"><a href="#（一）静态常量" class="headerlink" title="（一）静态常量"></a>（一）静态常量</h3><ul>
<li><strong>写法步骤</strong></li>
</ul>
<ol>
<li>构造器私有化（防止new）</li>
<li>在类的内部创建对象</li>
<li>向外暴露一个静态的公共方法：getInstance（）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//饿汉式（静态变量）	</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.本地内部创建对象实例</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance1 = Singleton.getInstance();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//结果为true，说明这两个对象是完全一样的</span></span><br><span class="line">		System.out.println(instance==instance1);	</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这两个new出来的对象HashCode值也一样</span></span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance1.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：写法简单，在类装载的时候就完成了实例化（上述第二步），避免了线程同步的问题。</li>
<li>正是由于在类装载的时候就完成了实例化，没有达到懒加载（lazy loading）的效果，那么如果从始至终都未使用这个实例，就会造成内存浪费。</li>
<li>在JDK中有用到，在<code>java.lang.Runtime</code>下。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200419202904706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>总结：<strong>如果你确定能够用到这个实例，那么没问题，但是你不能确定是否会用到，就会造成内存浪费的问题。</strong></li>
</ul>
<h3 id="（二）静态代码块"><a href="#（二）静态代码块" class="headerlink" title="（二）静态代码块"></a>（二）静态代码块</h3><ul>
<li>写法：在静态代码块中创建单例对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式（静态代码块）	</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.本地内部创建对象实例</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中创建单例对象</span></span><br><span class="line">			instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这与静态变量是一样的，也同样是在类装载的时候创建实例。优缺点也一样，可能会造成内存浪费。</li>
</ul>
<h2 id="懒汉式（三种写法）"><a href="#懒汉式（三种写法）" class="headerlink" title="懒汉式（三种写法）"></a>懒汉式（三种写法）</h2><h3 id="（一）线程不安全"><a href="#（一）线程不安全" class="headerlink" title="（一）线程不安全"></a>（一）线程不安全</h3><ul>
<li>起到了懒加载的效果，但是只能在单线程下使用</li>
<li>如果多线程下，一个线程进入<code>if(instance==null)</code>判断语句块，还没来得及往下执行，另一个线程又进来了，这样会产生多个实例，所以多线程情况下，不使用这种方式</li>
<li><strong>在实际开发中，不要使用懒汉式！！！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，当使用该方法时，才去创建instance，即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">			instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（二）线程安全，同步方法"><a href="#（二）线程安全，同步方法" class="headerlink" title="（二）线程安全，同步方法"></a>（二）线程安全，同步方法</h3><ul>
<li>解决了线程不安全的问题，但是同时也带来了效率低下的问题。每个线程想获得类的实例，执行<code>getInstance（）</code>都需要进行同步。</li>
<li><strong>所以实际开发中不使用这种方式！！！</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这个获取实例的公有方法上加一个`synchronized`关键字，就解决了线程安全的问题。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">			instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="（三）线程安全，同步代码块"><a href="#（三）线程安全，同步代码块" class="headerlink" title="（三）线程安全，同步代码块"></a>（三）线程安全，同步代码块</h3><ul>
<li><p>这种方式本意是想通过同步代码块来改善同步方法带来的效率低下的问题。但是并没有什么卵用。</p>
</li>
<li><p>其实也没有太大的意义，还是线程不安全的，<strong>开发中一定不能用！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：延迟加载（需要的时候才去加载）</p>
</li>
<li><p>缺点： 线程不安全，在多线程中很容易出现不同步的情况，如在数据库对象进行的频繁读写操作时。</p>
</li>
</ul>
<h2 id="双重检查-推荐使用"><a href="#双重检查-推荐使用" class="headerlink" title="双重检查(推荐使用)"></a>双重检查(推荐使用)</h2><ul>
<li>使用<code>volatile</code>关键字，这个<code>instance</code>变量就共享了，一旦有改变，就会刷新到内存中，可以理解为轻量级的<code>synchronized</code>，</li>
<li>解决了线程安全和懒加载的问题，同时保留了效率，它或许可以在并发量不多，安全性不太高的情况能完美运行。</li>
<li>但是，问题就是出现在这句 <code>instance = new Singleton();</code> 在JVM编译的过程中会出现指令重排的优化过程，这就会导致当 instance实际上还没初始化，就可能被分配了内存空间，也就是说会出现 instance !=null 但是又没初始化的情况，这样就会导致返回的 instance 不完整。</li>
<li>优点：在并发量不多，安全性不高的情况下或许能很完美运行单例模式</li>
<li>缺点：不同平台编译过程中可能会存在严重安全隐患。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span></span>&#123;</span><br><span class="line"><span class="comment">//使用volatile关键字，这个instance变量就共享了，一旦有改变，就会刷新到内存中</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">			  <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类（推荐使用）"><a href="#静态内部类（推荐使用）" class="headerlink" title="静态内部类（推荐使用）"></a>静态内部类（推荐使用）</h2><ul>
<li>这个主类装载的时候，它里面的内部类不会被装载的，但是如果主类中的方法使用到了这个静态内部类的静态变量的时候，这个类才会装载，（以此实现延迟加载），而且只会装载一次，并且还是线程安全的。</li>
<li>利用了JVM装载类的时候是线程安全的这个特点，因为在类初始化的时候，别的线程是无法进入的。</li>
<li><strong>推荐使用！！！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类实现单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个静态内部类，这个类中有一个静态属性Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTnstance</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法,直接返回这个实例。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Singleton5.instance;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="枚举的方法（强烈推荐）"><a href="#枚举的方法（强烈推荐）" class="headerlink" title="枚举的方法（强烈推荐）"></a>枚举的方法（强烈推荐）</h2><ul>
<li>借助JDK1.5中添加的枚举来实现单例，不仅避免了多线程同步的问题，而且还能够防止反序列化重新创建新的对象。</li>
<li>枚举方式也是JAVA作者推荐使用的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest6</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//测试</span></span><br><span class="line">			Singleton6 instance = Singleton6.INSTANCE;</span><br><span class="line">			Singleton6 instance1 = Singleton6.INSTANCE;</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//结果为true，说明这两个对象是完全一样的</span></span><br><span class="line">			System.out.println(instance==instance1);</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//这两个new出来的对象HashCode值也一样</span></span><br><span class="line">			System.out.println(instance.hashCode());</span><br><span class="line">			System.out.println(instance1.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用枚举，可以实现单例</span></span><br><span class="line">	<span class="keyword">enum</span> Singleton6&#123;</span><br><span class="line">		INSTANCE;<span class="comment">//属性</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>在实际开发中：<br>①<strong>饿汉式</strong>————————–单线程情况下并且知道一定会用到这个实例的时候采用<br>②<strong>懒汉式的</strong>———————–三种写法都不推荐<br>③<strong>双重检查</strong>和<strong>静态内部类</strong>—–多线程情况下推荐使用的写法。<br>④<strong>枚举</strong>—————————–最最推荐的是的方法，写法简单，安全，高效！</li>
<li><strong>注意：</strong> synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术的应用领域</title>
    <url>/undefined/</url>
    <content><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="金融领域"><a href="#金融领域" class="headerlink" title="金融领域"></a>金融领域</h2><p>区块链在<strong>国际汇兑</strong>、<strong>信用证</strong>、<strong>股权登记</strong>和<strong>证券交易所</strong>等金融领域有着潜在的巨大应用价值。将区块链技术应用在金融行业中，能够省去第三方中介环节，实现<strong>点对点</strong>的直接对接，从而在大大降低成本的同时，快速完成交易支付。<br>比如Visa推出基于区块链技术的 Visa B2B Connect，它能为机构提供一种费用更低、更快速和安全的跨境支付方式来处理全球范围的企业对企业的交易。要知道传统的跨境支付需要等3-5天，并为此支付1-3%的交易费用。Visa 还联合 Coinbase 推出了首张比特币借记卡，<strong>花旗银行</strong>则在区块链上测试运行加密货币“<strong>花旗币</strong>”。</p>
<h2 id="物联网和物流领域"><a href="#物联网和物流领域" class="headerlink" title="物联网和物流领域"></a>物联网和物流领域</h2><p>区块链在物联网和物流领域也可以天然结合。通过区块链可以降低物流成本，追溯物品的生产和运送过程，并且提高供应链管理的效率。该领域被认为是区块链一个很有前景的应用方向。<br>区块链通过结点连接的散状网络分层结构，能够在整个网络中实现信息的全面传递，并能够检验信息的准确程度。这种特性一 定程度上提高了物联网交易的便利性和智能化。<strong>区块链</strong>+<strong>大数据</strong>的解决方案就利用了大数据的自动筛选过滤模式，在区块链中建立信用资源，可双重提高交易的安全性，并提高物联网交易便利程度。为智能物流模式应用节约时间成本。区块链结点具有十分自由的进出能力，可独立的参与或离开区块链体系，不对整个区块链体系有任何干扰。区块链 +大数据解决方案就利用了大数据的整合能力，促使物联网基础用户拓展更具有方向性，便于在智能物流的分散用户之间实现用户拓展。</p>
<h2 id="公共服务领域"><a href="#公共服务领域" class="headerlink" title="公共服务领域"></a>公共服务领域</h2><p>区块链在公共管理、能源、交通等领域都与民众的生产生活息息相关，但是这些领域的中心化特质也带来了一些问题，可以用区块链来改造。区块链提供的去中心化的完全分布式DNS服务通过网络中各个节点之间的点对点数据传输服务就能实现域名的查询和解析，可用于确保某个重要的基础设施的操作系统和固件没有被篡改，可以监控软件的状态和完整性，发现不良的篡改，并确保使用了物联网技术的系统所传输的数据没用经过篡改。</p>
<h2 id="数字版权领域"><a href="#数字版权领域" class="headerlink" title="数字版权领域"></a>数字版权领域</h2><p>通过区块链技术，可以对作品进行鉴权，证明文字、视频、音频等作品的存在，保证权属的真实、唯一性。作品在区块链上被确权后，后续交易都会进行实时记录，实现数字版权全生命周期管理，也可作为司法取证中的技术性保障。例如，美国纽约一家创业公司Mine Labs开发了一个基于区块链的元数据协议，这个名为Mediachain的系统利用IPFS文件系统，实现数字作品版权保护，主要是面向数字图片的版权保护应用。</p>
<h2 id="保险领域"><a href="#保险领域" class="headerlink" title="保险领域"></a>保险领域</h2><p>在保险理赔方面，保险机构负责资金归集、投资、理赔，往往管理和运营成本较高。通过智能合约的应用，既无需投保人申请，也无需保险公司批准，只要触发理赔条件，实现保单自动理赔。一个典型的应用案例就是LenderBot, 是 2016 年由区块链企业 Stratumn、德勤与支付服务商 Lemonway 合作推出，它允许人们通过 Facebook Messenger 的聊天功能，注册定制化的微保险产品， 为个人之间交换的高价值物品进行投保，而区块链在贷款合同中代替了第三方角色 。</p>
<h2 id="公益领域"><a href="#公益领域" class="headerlink" title="公益领域"></a>公益领域</h2><p>区块链上存储的数据，高可靠且不可篡改，天然适合用在社会公益场景。公益流程中的相关信息，如捐赠项目、募集明细、资金流向、受助人反馈等，均可以存放于区块链上，并且有条件地进行透明公开公示，方便社会监督。</p>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>各设计模式的应用场景</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅要清楚的知道设计模式的结构还有实现过程，还要熟悉应用场景，在什么时候使用什么设计模式，能够达到更好的效果，使软件复用性更高，性能更好，这才是最重要的。不仅要会用，而且还要知道什么时候用。</p>
<a id="more"></a>

<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul>
<li><strong>抽象工厂模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。<strong>它使得应用程序能够和使用的框架的具体实现进行解耦。</strong> 在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。<code>任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了</code>。该模式可以与策略模式结合使用。</p>
<ul>
<li><strong>建造者模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。这个在业务代码中使用的场景很广泛。比如订单系统大部分项目都有，订单对象就是一个复杂对象，就可以采用建造者模式来做。</p>
<ul>
<li><strong>工厂方法：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只是一个返回实际类型的方法。</p>
<ul>
<li><strong>原型模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，拷贝一个对象并直接修改它就完事儿。这是一个大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。</p>
<ul>
<li><strong>单例模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>用来确保类只有一个实例。</code>还有一种方法就是使用枚举。单例是用得最多的，因为Spring的bean，默认就是单例级别的。单例模式的应用场景太多了，例如：在<code>hibernate</code>操作中，一个项目中一般创建一个<code>sessionFactory</code>对象。创建太多会造成资源的浪费</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul>
<li><strong>适配器模式</strong>：</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用于将一个新接口适配旧接口，在业务代码中经常有新旧接口适配的需求，可以采用该模式。</p>
<ul>
<li><strong>桥接模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>将抽象和抽象的具体实现进行解耦</strong>，这样可以使得抽象和抽象的具体实现可以独立进行变化。其实我们每天都在用到，可能却浑然不知。只要用到面向接口编程，其实都是在用桥接模式。</p>
<ul>
<li><strong>享元模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用缓存来减少对小对象的访问时间，<code>只要用到了缓存，基本都是在使用享元模式</code>。用个map缓存几个对象，基本上都运用了享元的思想。</p>
<ul>
<li><strong>装饰者模式:</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。装饰者模式在JDK中广泛运用，例如我们常用的AOP，既有动态代理，也有装饰者的味道。</p>
<ul>
<li><strong>门面模式：</strong></li>
</ul>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为一组组件，接口，抽象或子系统提供简化的接口。SLFJ日志就是门面日志，比如使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。</p>
<ul>
<li><strong>组合模式:</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。<code>组合模式常用于递归操作的优化上，</code>比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么可以试试这个设计模式。<strong>总之，凡是有级联操作的，都可以尝试这个设计模式。</strong></p>
<ul>
<li><strong>代理模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理模式用于向较简单的对象代替创建复杂或耗时的对象。几乎所有的开源框架，都用到了动态代理。</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul>
<li><strong>中介者模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。业务代码使用的场景太多了。比如MQ，其实就是在用中介者模式。</p>
<ul>
<li><strong>模板方法模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。<code>这个模式是非常高频的模式。</code>业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化。</p>
<ul>
<li><strong>策略模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能，<code>常用于优化大量的if-else</code></p>
<ul>
<li><strong>责任链：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合</strong>，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现，凡是带有Filter关键词的，用到拦截器的地方基本都在用这个设计模式。</p>
<ul>
<li><strong>迭代器模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一个统一的方式来访问集合中的对象，这个模式中间件和基础框架中用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典。</p>
<ul>
<li><strong>命令模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。命令模式使用频率较高，和策略模式比较像，Activiti工作流引擎中很多地方都用到了命令模式。</p>
<ul>
<li><strong>解释器模式：</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常描述为该语言定义语法并使用该语法来解释该格式的语句，比较冷门。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端会话技术：Cookie</title>
    <url>/887317365/</url>
    <content><![CDATA[<p>类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由客户端计算机暂时或永久保存的信息。</p>
<a id="more"></a>
<h2 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h2><ul>
<li><strong>概述：</strong> 一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</li>
<li><strong>应用场景：</strong> 自动登录、浏览记录、购物车。</li>
<li><strong>为什么要有这个Cookie：</strong>  http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 <strong>[自动登录]</strong>，其实从公司层面讲，就是为了更好的收集用户习惯 <strong>[大数据]</strong>。</li>
</ul>
<h2 id="如何使用Cookie"><a href="#如何使用Cookie" class="headerlink" title="如何使用Cookie"></a>如何使用Cookie</h2><h3 id="发送Cookie给客户端"><a href="#发送Cookie给客户端" class="headerlink" title="发送Cookie给客户端"></a>发送Cookie给客户端</h3><ol>
<li>在响应的时候，添加cookie</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cookie cookie = new Cookie(<span class="string">"aa"</span>, <span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">	//给响应，添加一个cookie</span><br><span class="line">	response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200228143218378.png" alt="在这里插入图片描述"></p>
<h3 id="获取客户端带过来的Cookie"><a href="#获取客户端带过来的Cookie" class="headerlink" title="获取客户端带过来的Cookie"></a>获取客户端带过来的Cookie</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取客户端带过来的cookie</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">	<span class="keyword">if</span>(cookies != null)&#123;</span><br><span class="line">		<span class="keyword">for</span> (Cookie c : cookies) &#123;</span><br><span class="line">			String cookieName = c.getName();</span><br><span class="line">			String cookieValue = c.getValue();</span><br><span class="line">			System.out.println(cookieName + <span class="string">" = "</span>+ cookieValue);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。</span><br><span class="line">//	expiry： 有效 以秒计算。</span><br><span class="line">//正值： 表示 在这个数字过后，cookie将会失效。</span><br><span class="line">//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1</span><br><span class="line">cookie.setMaxAge(60 * 60 * 24 * 7);</span><br><span class="line">		</span><br><span class="line">//赋值新的值</span><br><span class="line">cookie.setValue(newValue);</span><br><span class="line">		</span><br><span class="line">//用于指定只有请求了指定的域名，才会带上该cookie</span><br><span class="line">cookie.setDomain(<span class="string">".itheima.com"</span>);</span><br><span class="line">		</span><br><span class="line">//只有访问该域名下的cookieDemo的这个路径地址才会带cookie</span><br><span class="line">cookie.setPath(<span class="string">"/CookieDemo"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="典型案例："><a href="#典型案例：" class="headerlink" title="典型案例："></a>典型案例：</h2><h3 id="显示最近访问的时间"><a href="#显示最近访问的时间" class="headerlink" title="显示最近访问的时间"></a>显示最近访问的时间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 判断账号是否正确</span><br><span class="line">2. 如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。</span><br><span class="line">3. 如果找到的对象为空，表明是第一次登录。那么要添加cookie</span><br><span class="line">4. 如果找到的对象不为空， 表明不是第一次登录。 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="string">"admin"</span>.equals(userName) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">		//获取cookie last-name --- &gt;</span><br><span class="line">		Cookie [] cookies = request.getCookies();</span><br><span class="line">			</span><br><span class="line">		//从数组里面找出我们想要的cookie</span><br><span class="line">		Cookie cookie = CookieUtil.findCookie(cookies, <span class="string">"last"</span>);</span><br><span class="line">			</span><br><span class="line">		//是第一次登录，没有cookie</span><br><span class="line">		<span class="keyword">if</span>(cookie == null)&#123;</span><br><span class="line">				</span><br><span class="line">			Cookie c = new Cookie(<span class="string">"last"</span>, System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line">			c.setMaxAge(60*60); //一个小时</span><br><span class="line">			response.addCookie(c);</span><br><span class="line">				</span><br><span class="line">			response.getWriter().write(<span class="string">"欢迎您, "</span>+userName);</span><br><span class="line">				</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			//1. 去以前的cookie第二次登录，有cookie</span><br><span class="line">			long lastVisitTime = Long.parseLong(cookie.getValue());</span><br><span class="line">				</span><br><span class="line">			//2. 输出到界面，</span><br><span class="line">			response.getWriter().write(<span class="string">"欢迎您, "</span>+userName +<span class="string">",上次来访时间是："</span>+new Date(lastVisitTime));</span><br><span class="line">				</span><br><span class="line">			//3. 重置登录的时间</span><br><span class="line">			cookie.setValue(System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line">			response.addCookie(cookie);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		response.getWriter().write(<span class="string">"登陆失败 "</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显示商品浏览记录"><a href="#显示商品浏览记录" class="headerlink" title="显示商品浏览记录"></a>显示商品浏览记录</h3><p><img src="https://img-blog.csdnimg.cn/20200228173445822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>jsp</strong><br>Java Server Pager —&gt; 最终会翻译成一个类， 就是一个Servlet</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jsp中写java代码：</span><br><span class="line">	&lt;%</span><br><span class="line">		只能写java代码</span><br><span class="line">	%&gt;</span><br><span class="line">定义全局变量:</span><br><span class="line">	&lt;%! int a = 99; %&gt;</span><br><span class="line"></span><br><span class="line">定义局部变量:</span><br><span class="line">	&lt;% int b = 999; %&gt;</span><br><span class="line"></span><br><span class="line">在jsp页面上，显示 a 和 b的值:</span><br><span class="line">	&lt;%=a %&gt; </span><br><span class="line">	&lt;%=b %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>删除浏览记录</strong><br><img src="https://img-blog.csdnimg.cn/2020022818005011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>清除浏览记录</strong></p>
<ul>
<li>其实就是清除Cookie， 删除cookie是没有什么delete方法的。只有设置maxAge 为0 。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cookie cookie = new Cookie(<span class="string">"history"</span>,<span class="string">""</span>);</span><br><span class="line">cookie.setMaxAge(0); //设置立即删除</span><br><span class="line">cookie.setPath(<span class="string">"/CookieDemo02"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p>
<p>2.获取cookie， 添加cookie</p>
<pre><code>request.getCookie();

response.addCookie();</code></pre><p>3.Cookie分类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">会话Cookie</span><br><span class="line">	默认情况下，关闭了浏览器，那么cookie就会消失。</span><br><span class="line"></span><br><span class="line">持久Cookie</span><br><span class="line">	在一定时间内，都有效，并且会保存在客户端上。 </span><br><span class="line">		cookie.setMaxAge(0); //设置立即删除</span><br><span class="line">		cookie.setMaxAge(100); //100 秒</span><br></pre></td></tr></table></figure>
<p>4.Cookie的安全问题。<br>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 —&gt; <strong>Session .</strong></p>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>建站系列之---基于github搭建hexo网站</title>
    <url>/167674660/</url>
    <content><![CDATA[<p>日常在网上找答案的时候，发现了一种干干净净的，类似于个人主页的网站，就很好奇，后来深入了解了一下，原来这是基于hexo博客框架搭建起来的网站，用github的page服务托管博文，于是我也想上手整一个，于是乎，就花了前前后后大概半个月的时间，搭建起来网站，并买了域名部署到了服务器上面，此时怀着欣慰的心情，写下了这个系列！！！！</p>
<a id="more"></a>

<p><strong>概述：</strong> 本文主要讲的是基于github，利用hexo博客框架搭建网站。购买域名（9块）并绑定。实现效果：可以看到网站首页。</p>
<h2 id="一、下载安装Git"><a href="#一、下载安装Git" class="headerlink" title="一、下载安装Git"></a>一、下载安装Git</h2><p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>安装过程就不赘述了！</p>
<h2 id="二、下载安装Node-js"><a href="#二、下载安装Node-js" class="headerlink" title="二、下载安装Node.js"></a>二、下载安装Node.js</h2><p>下载地址：<a href="http://nodejs.org/download/">http://nodejs.org/download/</a><br>安装的时候，选择<code>add to path</code>，他会自动配置环境变量。</p>
<ul>
<li>换镜像（亲身体验，可以省去以后好多麻烦）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><ul>
<li>用cnpm全局安装，在桌面右键打开<code>Git bash here</code>输入：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成后，在命令行里输入<code>hexo -v</code>检查是否安装成功。</li>
</ul>
<p> <img src="https://img-blog.csdnimg.cn/20200305155050299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、配置hexo"><a href="#四、配置hexo" class="headerlink" title="四、配置hexo"></a>四、配置hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基本命令了解：</span><br><span class="line">	1. hexo -v			//查看版本		</span><br><span class="line">	2. hexo init		//初始化一个项目</span><br><span class="line">	3. cnpm install		</span><br><span class="line">	4. hexo clean		//清理生成的文件</span><br><span class="line">	5. hexo g			//生成静态网页文件，g是generate的缩写</span><br><span class="line">	6. hexo s			//运行到服务器端，s是server的缩写</span><br><span class="line">	7. hexo d			//部署到远端GitHub, d是deploy的缩写</span><br><span class="line">	8. hexo s -p 5000	//在4000端口被占用的时候，修改指定端口</span><br><span class="line">	9. cnpm uninstall hexo-cli -g       //卸载hexo</span><br></pre></td></tr></table></figure>

<ul>
<li>在本地新建一个文件夹，我命名它为blog</li>
<li>在这个文件夹下，右键打开<code>Git Bash here</code>，输入<code>hexo init</code>，我在这个地方出现了一个<code>WARN</code>，暂时不用管它。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305135143147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>继续输入<code>cnpm install</code>可以看到blog文件夹里出现：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305155919286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">目录介绍：</span><br><span class="line">	1. node_modules <span class="comment">#本地依赖模块</span></span><br><span class="line">	2. public <span class="comment">#hexo g生成的目录，包含静态网页文件，就是看到的博客</span></span><br><span class="line">	2. <span class="built_in">source</span> <span class="comment">#源文件，用来存放我们的写好的博客源文件</span></span><br><span class="line">	3. themes <span class="comment">#主题文件夹，里面存放主题</span></span><br><span class="line">	4. _config.yml <span class="comment">#站点配置文件，用来配置博客具体的显示内容等</span></span><br><span class="line">	5. db.json <span class="comment">#存储一些用到的数据</span></span><br><span class="line">	6.package.json <span class="comment">#依赖配置</span></span><br><span class="line"></span><br><span class="line">	.deploy_git <span class="comment">#hexo s部署到远端的时候会生成的文件夹，是根据public文件夹生成的，内容是差不多的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入：<code>hexo g</code></li>
<li>输入：<code>hexo s</code> </li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305135917128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>打开浏览器输入<code>localhost：4000</code>，可以看到部署好了，有一篇<code>hello World</code>的博客</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305154439378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>到这一步，本地部署就已经成功了！！</li>
</ul>
<h2 id="五、连接到远端Github"><a href="#五、连接到远端Github" class="headerlink" title="五、连接到远端Github"></a>五、连接到远端Github</h2><ul>
<li>安装 <code>deployer</code> 插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>打开<code>F:\blog\_config.yml</code>,找到 <code>deploy</code>。修改如下，其中<code>repo</code>填写你自己的仓库名字。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305161344694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>生成公私钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"注册git使用的邮箱"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200305161705454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>找到生成的 <code>id_rsa.pub</code> 公钥文件（在<code>C:\Users\pc\.ssh</code>下），复制公钥内容。</li>
<li>到Github你的网站仓库界面：<code>Setting -&gt; Deploy keys -&gt; add deploy key -&gt; Add
key</code>，选择<code>Allow write access</code>（允许推送），这样方便以后推送的时候，不用每次都输入密码。</li>
<li>开始推送</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>这样在博客和github都可以看到推送的内容。</p>
<h2 id="六、购买绑定域名"><a href="#六、购买绑定域名" class="headerlink" title="六、购买绑定域名"></a>六、购买绑定域名</h2><p>阿里云：<a href="https://wanwang.aliyun.com/domain/">https://wanwang.aliyun.com/domain/</a></p>
<ul>
<li>在阿里云或者腾讯云购买一个域名，我买的是阿里云的<code>.top</code>后缀名的，后缀名不同，价格不同，top最便宜，一年只要九块。</li>
<li>如何买域名以及解析域名不做描述，注意要是实名认证，解析域名的意思就是，把ip地址和域名做一个映射，它让你填的<code>ip地址</code>就是你github网站仓库的<code>ip</code>。如何得到这个<code>ip</code>：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305163101123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>填入<code>ip</code>，完成解析。</li>
<li>在<code>F:\blog\source</code>下新建一个<code>CNAME.txt</code>,在里面写入你的域名，不要前缀，如：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305163539152.png" alt="在这里插入图片描述"></p>
<ul>
<li>去掉<code>.txt</code>后缀</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305163544455.png" alt="在这里插入图片描述"></p>
<ul>
<li>绑定域名，到github，找到你的仓库，找到<code>Setting</code>，一直拉到最先面下面。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305164627522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020030516473779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>这样就绑定好了。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">每次部署的执行次序</span><br><span class="line">	1. hexo clean</span><br><span class="line"> 	2. hexo g</span><br><span class="line">	3. hexo d</span><br></pre></td></tr></table></figure>


<ul>
<li>执行一次，查看效果。</li>
</ul>
]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>try-catch-finally总结</title>
    <url>/2774241439/</url>
    <content><![CDATA[<p>在日常编译运行程序出错的时候，编译器就会抛出异常，抛出异常要比终止程序灵活的多，这是因为Java提供了一个”捕获”异常的处理器对异常情况进行处理，如果没有提供处理器机制，程序就会终止，try-catch-finally可以保证程序发生错误的时候继续执行下去。下面就谈一下使用的总结，和注意事项。</p>
<a id="more"></a>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>try，catch，finally语句中，如果try语句有return语句，此后做任何修改，都不影响try中return的返回值。</li>
<li>如果finally块中有return语句，则try或catch中中的返回语句忽略。</li>
<li>如果finally块中抛出异常，则整个try，catch，finally块中抛出异常。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>在使用try- catch-finally的时候，要注意以下问题：<br>①尽量在try或者catch中使用return语句。通过finally块中达到对try或者catch返回值修改是不可行的。<br>②finally块中避免使用return语句，因为finally块中如果使用return语句，会显式的消化掉try，catch块中的异常信息，屏蔽错误的发生。<br>③finally块中避免再次抛出异常，否则整个包含try语句块的方法会抛出异常，并且会消化掉try，catch块中的异常。</li>
</ul>
]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
  </entry>
  <entry>
    <title>区块链的架构模型以及核心技术</title>
    <url>/714656305/</url>
    <content><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="一-架构模型"><a href="#一-架构模型" class="headerlink" title="一.架构模型"></a>一.架构模型</h2><p>一般说来，区块链系统由数据层、网络层、共识层、激励层、合约层，应用层组成。</p>
<ol>
<li><strong>数据层：</strong> 封装了底层数据区块以及相关的数据加密和时间戳等基础数据和基本算法。</li>
<li><strong>网络层：</strong> 则包括分布式组网机制、数据传播机制和数据验证机制等。</li>
<li><strong>共识层：</strong> 主要封装网络节点的各类共识算法。</li>
<li><strong>激励层：</strong> 将经济因素集成到区块链技术体系中来，主要包括经济激励的发行机制和分配机制等。</li>
<li><strong>合约层：</strong> 主要封装各类脚本、算法和智能合约，是区块链可编程特性的基础。</li>
<li><strong>应用层：</strong> 则封装了区块链的各种应用场景和案例。</li>
</ol>
<p><strong>区块链技术最具代表性的创新点：</strong></p>
<ol>
<li>基于时间戳的链式区块结构、分布式节点的共识机制。</li>
<li>基于共识算力的经济激励和灵活可编程的智能合约。</li>
</ol>
<h2 id="二-核心技术"><a href="#二-核心技术" class="headerlink" title="二.核心技术"></a>二.核心技术</h2><p> 1.<strong>分布式账本：</strong>分布式账本指的是交易记账由分布在不同地方的多个节点共同完成，而且每一个节点记录的是完整的账目，因此它们都可以参与监督交易合法性，同时也可以共同为其作证 。跟传统的分布式存储有所不同，区块链的分布式存储的独特性主要体现在两个方面：一是区块链每个节点都按照块链式结构存储完整的数据，传统分布式存储一般是将数据按照一定的规则分成多份进行存储。二是区块链每个节点存储都是独立的、地位等同的，依靠共识机制保证存储的一致性，而传统分布式存储一般是通过中心节点往其他备份节点同步数据。没有任何一个节点可以单独记录账本数据，从而避免了单一记账人被控制或者被贿赂而记假账的可能性。也由记账节点足够多，理论上讲除非所有的节点被破坏，否则账目就不会丢失，从而保证了账目数据的安全性。</p>
<p>2.<strong>非对称加密：</strong>存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的，只有在数据拥有者授权的情况下才能访问到，从而保证了数据的安全和个人的隐私。<br>3.<strong>共识机制</strong>就是所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡 。<br>区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。“人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。<br>4.<strong>智能合约：</strong>基于这些可信的不可篡改的数据，可以自动化的执行一些预先定义好的规则和条款。以保险为例，如果说每个人的信息（包括医疗信息和风险发生的信息）都是真实可信的，那就很容易的在一些标准化的保险产品中，去进行自动化的理赔。在保险公司的日常业务中，虽然交易不像银行和证券行业那样频繁，但是对可信数据的依赖是有增无减。因此，笔者认为利用区块链技术，从数据管理的角度切入，能够有效地帮助保险公司提高风险管理能力。具体来讲主要分投保人风险管理和保险公司的风险监督。</p>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型---工厂方法模式</title>
    <url>/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个用于创建对象的接口，但是让子类决定将哪一个类似类化工厂方法模式，让一个类的实例化延迟到其子类。</p>
<a id="more"></a>
<h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul>
<li>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，弥补了缺陷。他也被称为<code>虚拟构造器模式</code>或者<code>多态工厂模式</code>。</li>
<li>先定义一个<code>抽象工厂类</code>，再定义<code>具体工厂类</code>去实现抽象工厂类的方法，这种抽象化的结果是：可以在不修改具体工厂类的情况下引进新的产品，如果出现新的功能，只需要为这个功能定义一个具体的工厂类。就可以创建出该功能的实例，这种改进方案，就叫做工厂方法模式。</li>
<li>在工厂方法模式中，工厂父类负责定义创建产品对象的<code>公共接口</code>，而工厂子类负责生成<code>具体的产品对象</code>，这样做得目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定久经应该实例化哪一个具体产品类。</li>
<li><strong>总结:定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。</strong></li>
</ul>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ol>
<li>抽象产品（定义产品的接口，产品对象的公共父类）</li>
<li>具体产品（实现产品的接口）</li>
<li>抽象工厂（声明工厂方法，返回一个产品）</li>
<li>具体工厂（抽象工厂的子类，客户端调用，返回一个具体的实例）</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 日志记录器可以通过很多途径保存日志，用户可以修改配置文件，灵活的更换日志记录的方式，为了更好的封装记录器的初始化过程，并保证多种记录器切换的灵活性，使用工厂方法模式设计该系统。</p>
<p>1.<strong>抽象产品接口：</strong> <code>Logger</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<strong>具体产品实现：</strong> <code>DatabaseLogger</code>,<code>FileLogger</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"数据库日志记录"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"文件日志记录"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.<strong>抽象工厂接口：</strong> <code>LoggerFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//抽象工厂方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<strong>具体工厂实现：</strong> <code>DatabaseLoggerFactory</code>，<code>FileLoggerFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Impl.DatabaseLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//连接数据库</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line">		Logger logger = <span class="keyword">new</span> DatabaseLogger();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化数据库日志记录器</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Impl.FileLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建文件日志记录对象</span></span><br><span class="line">		Logger logger = <span class="keyword">new</span> FileLogger();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建文件</span></span><br><span class="line">		<span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.<strong>客户端测试：</strong> <code>Client</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factory.Impl.FileLoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LoggerFactory factory;</span><br><span class="line">		Logger logger;</span><br><span class="line">		<span class="comment">//具体工厂的实例</span></span><br><span class="line">		factory=<span class="keyword">new</span> FileLoggerFactory();</span><br><span class="line">		logger=factory.createLogger();</span><br><span class="line">		logger.writeLog();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.如果要增加新的功能，只需要对应的增加一个新的具体工厂类，然后在客户端代码中修改具体工厂类的类名，原有类库的代码无需修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.通过引入配合文件并使用反射机制可以实现<code>在不修改客户端代码的基础上更换具体共产类</code>，系统更符合开闭原则，具备更好的扩展性。</p>
<h2 id="工厂方法的隐藏"><a href="#工厂方法的隐藏" class="headerlink" title="工厂方法的隐藏"></a>工厂方法的隐藏</h2><ul>
<li>通过把业务方法调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无需使用工厂方法来创建产品对象。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li><p><strong>优点：</strong><br>①用户只需关心所需产品对应的工厂，无需关心创建细节。<br>②基于工厂角色和产品角色的多态性设计是工厂方法模式的关键，工厂方法模式之所以被称为<code>多态工厂模式</code>，正是因为所有的具体工厂类都具有同一抽象父类。<br>③新增功能时，无需修改源码，只增添一个具体工厂和具体产品即可。</p>
</li>
<li><p><strong>缺点：</strong><br>①新增了产品类，意味着系统的复杂度要增加。<br>②代码中引入了抽象层，在客户端中也使用了抽象性进行定义，增加了理解难度。</p>
</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>客户端不知道它所需要使用的类，因为客户端只需要知道所对应的工厂就行了。</li>
<li>抽象工厂类通过使用他的子类来指定创建哪个对象。在工厂方法模式中对于抽象工厂只需要提供一个创建产品的接口，而由其子类来决定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>手写链表</title>
    <url>/3274828756/</url>
    <content><![CDATA[<p>看过很多面经，看得出来，数据结构和算法在面试中是很重要的，在之前也听说过，面试过程中，出现手撕代码的场景，而我刚好又看到链表这一章，顺便对链表做一下巩固，也打个预防针，万一真遇到要手写代码的时候，也有了一手准备。</p>
<a id="more"></a>

<h2 id="一、链表结构"><a href="#一、链表结构" class="headerlink" title="一、链表结构"></a>一、链表结构</h2><p><img src="https://img-blog.csdnimg.cn/20200325114240567.png" alt="在这里插入图片描述"></p>
<ul>
<li>每个节点结构是由数据域和指针域组成，数据域是存放数据的，而指针域存放下一结点的地址。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200325114318953.png" alt="在这里插入图片描述"></p>
<ul>
<li>但是不可能只有一个节点呀，这时候就使用 Class 来声明一个类，为类添加两个属性，一个属性是存放数据的属性data，另一个属性是存放指向下一个结点的指针属性next。这样就可以创造出多个结点实例。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">   constructor(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、插入删除"><a href="#二、插入删除" class="headerlink" title="二、插入删除"></a>二、插入删除</h2><ul>
<li>插入到单链表的头部</li>
<li>插入到中间</li>
<li>插入到尾部</li>
<li>删除头部节点</li>
<li>删除中间节点</li>
<li>删除尾部节点</li>
</ul>
<h2 id="三、边界条件"><a href="#三、边界条件" class="headerlink" title="三、边界条件"></a>三、边界条件</h2><ul>
<li><p><strong>输入边界：</strong><br>先考虑用户输入的参数，比如传入一个链表，我们首先要判断链表是否为空，如果为空我们就不能让它执行下边的程序。再比如插入一个结点到指定结点的后边，那么你也要判断输入的结点是否为空，而且还要判断该结点是否存在该链表中。对于这些输入值的判断，就叫做输入边界。</p>
</li>
<li><p><strong>特殊边界：</strong><br>考虑到一些特殊情况，比如插入数据，我们插入数据一般考虑到插入尾部，但要是插入到头部，插入尾部的代码并不适用于插入到头部，所以呢需要考虑这种情况，删除节点也是同样要考虑这种情况。其实特殊边界最主要考虑到一些逻辑上的特殊情况。</p>
</li>
</ul>
<h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><p><strong>例：在链表中间增加和删除节点</strong></p>
<h3 id="1-定义节点："><a href="#1-定义节点：" class="headerlink" title="1. 定义节点："></a>1. 定义节点：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">       this.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-增加节点："><a href="#2-增加节点：" class="headerlink" title="2. 增加节点："></a>2. 增加节点：</h3><p>①保存临时地址（4结点的地址）,需要进行遍历查找到3结点，也就是下列代码的currentNode 结点。</p>
<p><img src="https://img-blog.csdnimg.cn/20200325115953914.gif" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//先查找该元素</span><br><span class="line"><span class="built_in">let</span> currentNode = this.findByValue(element);</span><br><span class="line">// 保存 3 结点的下一结点地址（4 结点的地址）</span><br><span class="line"><span class="built_in">let</span> pre = currentNode.next</span><br></pre></td></tr></table></figure>

<p>②创建新结点，将新结点（5结点）的指针指向下一结点指针（4结点地址，已经在上一步骤保存下来了）</p>
<p><img src="https://img-blog.csdnimg.cn/20200325120116456.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.next = pre;</span><br></pre></td></tr></table></figure>

<p>③将3 的结点地址指向新结点（5结点）</p>
<p><img src="https://img-blog.csdnimg.cn/20200325120224691.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentNode.next = newNode;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除节点："><a href="#3-删除节点：" class="headerlink" title="3. 删除节点："></a>3. 删除节点：</h3><p>①断开3结点的指针（断开3结点相当于让2结点直接指向4结点）<br><img src="https://img-blog.csdnimg.cn/20200325120407492.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="comment">// 用来记录 3 结点的前一结点</span></span><br><span class="line">  let preNode = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 遍历查找 3 结点</span></span><br><span class="line">  <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">         <span class="comment">// 3 结点的前一结点</span></span><br><span class="line">         preNode = currentNode;</span><br><span class="line">        <span class="comment">// 3 结点</span></span><br><span class="line">         currentNode = currentNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②让结点2的指针指向4结点，完成删除。<br><img src="https://img-blog.csdnimg.cn/20200325120504135.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">preNode.next = currentNode.next;</span><br></pre></td></tr></table></figure>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能：单链表的插入、删除、查找</span></span><br><span class="line"><span class="comment">   * 【插入】：插入到指定元素后方</span></span><br><span class="line"><span class="comment">   * 1、查找该元素是否存在？</span></span><br><span class="line"><span class="comment">   * 2、没有找到返回 -1</span></span><br><span class="line"><span class="comment">   * 3、找到进行创建结点并插入链表。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 【查找】：按值查找/按索引查找</span></span><br><span class="line"><span class="comment">   * 1、判断当前结点是否等于null，且是否等于给定值？</span></span><br><span class="line"><span class="comment">   * 2、判断是否可以找到该值？</span></span><br><span class="line"><span class="comment">   * 3、没有找到返回 -1；</span></span><br><span class="line"><span class="comment">   * 4、找到该值返回结点；</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 【删除】：按值删除</span></span><br><span class="line"><span class="comment">   * 1、判断是否找到该值？</span></span><br><span class="line"><span class="comment">   * 2、找到记录前结点，进行删除；</span></span><br><span class="line"><span class="comment">   * 3、找不到直接返回-1；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="comment">//定义结点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">      constructor(data)&#123;</span><br><span class="line">         <span class="keyword">this</span>.data = data;</span><br><span class="line">         <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">	 <span class="comment">//定义链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span>&#123;</span><br><span class="line">     constructor()&#123;</span><br><span class="line">         <span class="comment">//初始化头结点</span></span><br><span class="line">         <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据 value 查找结点</span></span><br><span class="line">     findByValue = (value) =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断该结点是否找到</span></span><br><span class="line">         console.log(currentNode)</span><br><span class="line">         <span class="keyword">return</span> currentNode === <span class="keyword">null</span> ? -<span class="number">1</span> : currentNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据 index 查找结点</span></span><br><span class="line">     findByIndex = (index) =&gt;&#123;</span><br><span class="line">         let pos = <span class="number">0</span>;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; pos !== index)&#123;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">             pos++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断是否找到该索引</span></span><br><span class="line">         console.log(currentNode)</span><br><span class="line">         <span class="keyword">return</span> currentNode === <span class="keyword">null</span> ? -<span class="number">1</span> : currentNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">     insert = (value,element) =&gt;&#123;</span><br><span class="line">         <span class="comment">//先查找该元素</span></span><br><span class="line">         let currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">         <span class="comment">//如果没有找到</span></span><br><span class="line">         <span class="keyword">if</span>(currentNode == -<span class="number">1</span>)&#123;</span><br><span class="line">             console.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         let newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">         newNode.next = currentNode.next;</span><br><span class="line">         currentNode.next = newNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据值删除结点</span></span><br><span class="line">     delete = (value) =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         let preNode = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">             preNode = currentNode;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(currentNode == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">         preNode.next = currentNode.next;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//遍历所有结点</span></span><br><span class="line">     print = () =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head</span><br><span class="line">         <span class="comment">//如果结点不为空</span></span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span>)&#123;</span><br><span class="line">             console.log(currentNode.data)</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每天一道面试题</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>建站系列之---备份本地站点到github上</title>
    <url>/3220545803/</url>
    <content><![CDATA[<p>试想一下，就你自己的电脑上配置了hexo，平时写博客，部署都是在自己电脑上，那万一有一天，用的不是自己电脑，又想要写博客，那怎么办呢？此时就要用到git了，将你的站点配置等信息备份到github上，要用的时候，用 git clone到本地。而且好处不仅如此，万一哪天出了问题，有个备份，岂不美哉？</p>
<a id="more"></a>
<h2 id="一、本地配置"><a href="#一、本地配置" class="headerlink" title="一、本地配置"></a>一、本地配置</h2><ul>
<li>由于是在个人电脑上配置的<code>hexo</code>，部署也不方便，如果在另外一台机子上写博客，没有<code>hexo</code>的配置也不行，另一方面出于备份项目的目的，最好的办法是将本地<code>hexo</code>站点备份到<code>Github</code>上。</li>
</ul>
<p>1.新建<code>hexo</code>文件夹存放分支工作目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir hexo</span><br></pre></td></tr></table></figure>

<p>2.把你的GitHub的远程仓库克隆到<code>hexo</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/DAQ121/DAQ121.github.io hexo</span><br></pre></td></tr></table></figure>

<p>3.删除除了版本管理的<code>.git</code>之外的所有文件和文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">rm -r *</span><br></pre></td></tr></table></figure>

<p>4.把要备份的文件复制到<code>hexo</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scaffolds/</span><br><span class="line"><span class="built_in">source</span>/</span><br><span class="line">themes/</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure>

<p>5.如果使用的主题是从Github克隆的，那么使用命令删除它的Git文件（以next主题为例）,否则无法将主题文件<code>push</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -R themes/next/.git*</span><br></pre></td></tr></table></figure>

<h2 id="二、github配置"><a href="#二、github配置" class="headerlink" title="二、github配置"></a>二、github配置</h2><p>1.github创建一个<code>hexo</code>分支 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure>
<p>2.保存所有文件到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure>
<p>3.提交变更</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"创建hexo分支"</span></span><br></pre></td></tr></table></figure>
<p>4.推送到github，并用<code>--set-upstream</code>与<code>origin</code>创建关联，将<code>hexo</code>设置为默认分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure>

<h2 id="三、合并管理"><a href="#三、合并管理" class="headerlink" title="三、合并管理"></a>三、合并管理</h2><ul>
<li>现在有两个需要管理的文件夹，一个是<code>blog</code>，一个是<code>hexo</code>，但是每次发布文章的时候如果要提交两次就很失效率，</li>
</ul>
<p>1.将本地<code>hexo</code>分支中的<code>.git</code>文件夹复制到<code>blog</code>根目录中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -a .git ../blog</span><br></pre></td></tr></table></figure>
<p>2.<code>master</code>分支的文件则由<code>hexo</code>管理，编辑<code>hexo</code>配置文件<code>_config.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   <span class="built_in">type</span>: git</span><br><span class="line">   repo: https://github.com/DAQ121/DAQ121.github.io</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>
<h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><p>1.新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>2.将相关更改推送到<code>hexo</code>分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"发表文章test"</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
<p>3.将静态文件推送到<code>master</code>分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<h2 id="五、使用的时候如何迁移"><a href="#五、使用的时候如何迁移" class="headerlink" title="五、使用的时候如何迁移"></a>五、使用的时候如何迁移</h2><p>1.将<code>hexo</code>分支克隆下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo http://github.com/DAQ121/DAQ121.github.io</span><br></pre></td></tr></table></figure>
<p>2.安装<code>hexo</code>依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>
<p>3.只不过每次发文章的时候，要输入用户名和密码。</p>
]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的结构与功能</title>
    <url>/3546768407/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对操作系统的种类和发展历史有了一个基本了解之后，就正式开始学习操作系统了，首先要明白操作系统是做什么的，它的结构是什么样的，我粗略总结出以下知识点。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在此推荐一个B站视频，是哈工大的一位叫孙志岗的老师，讲课很幽默，而且干货很多，他的视频是平时上课时候得一些录播，虽然播放量不是很理想，但我个人觉得，比那些照着PPT念，播放量动辄几十万的老师强太多。课程链接：<a href="https://www.bilibili.com/video/av13169670?from=search&seid=5921511433085032320">点我直达！</a></p>
<h1 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h1><h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul>
<li>系统调用：可以理解为在操作系统内核当中的一个函数，这个函数对应用程序来说，是不可以被直接访问的。应用程序可以访问的是<code>API</code>接口，API有办法进系统内核中去执行相应的程序</li>
<li><code>windows</code>操作系统提供出<code>API</code>应用编程接口，但是<code>linux</code>不一样，<code>linux</code>不需要通过这个接口来调用。</li>
<li>目前世界上有三套<code>API</code>接口，<code>WIN32 API，POSIX API</code>（被<code>unix</code>广泛应用，很多应用程序是针对他编写的，就要提供相应的接口，以及参数），<code>JAVA API(JVM)</code>。</li>
<li>系统中就像是有一条分割线，上面是用户模式（运行的都是应用程序），下面是内核模式（操作系统的内核）。分割起到保护作用，用户态里的应用程序，不可能随便访问内核里的资源。交互就要用到系统调用了。</li>
<li>例如C语言里面的<code>printf（）</code>，它就是调用了系统程序<code>write（）</code>，</li>
<li>应用程序不可以访问内核，但是系统可以访问应用程序的内核。只不过要多一些步骤。</li>
<li>系统程序通常和系统中的功能比较近，帮助我们完成系统里的重要职能。</li>
<li>比较常用的系统程序：复制拷贝文件（属于资源管理器就是系统程序）</li>
<li>一般很少用到的系统程序（磁盘分区，系统快照，磁盘碎片整理）</li>
</ul>
<h2 id="操作系统的设计之道"><a href="#操作系统的设计之道" class="headerlink" title="操作系统的设计之道"></a>操作系统的设计之道</h2><ul>
<li>软件的<strong>体系结构</strong>是根据操作系统来的，操作系统就是早期最大的软件。</li>
<li>而操作系统的体系结构是从<strong>建筑学</strong>中学来的</li>
</ul>
<h2 id="操作系统的结构-1"><a href="#操作系统的结构-1" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><ul>
<li>由于用户应用程序可以直接调用系统程序，所以 <code>DOS</code>系统结构很惧怕病毒。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318224419770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>做到了对内核的保护，应用层和系统层分离，但是在内核中是没有结构的，就造成了内核中错综复杂混乱的局面，牵一发而动全身，有一点出问题，内核全完蛋。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318224549638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>层次结构：上层调用下层的功能，下层向上层返回数据，不允许跨层访问。这种理念也映射到信息封装，隐藏，方方面面都有。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020031822495696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>微内核，相比以前的大内核，有了很多好处，把更多的功能分给了用户空间（磁盘，网络管理都放到了用户空间）。这样的微内核带来了系统的稳定和安全，但是做什么都要经过内核，这样就导致效率低下。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020031823005218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><code>Solaris Modular</code>系统，无可比拟，强大，比<code>uniux，</code>  <code>linux</code>强很多。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318231401137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><code>Macos</code>，混合系统，两个内核<code>BSD</code>（聚内核）+<code>Mach</code>（微内核）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318231729175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>虚拟机结构（在操作系统之上装一个虚拟机，虚拟机中又可以再装不同的操作系统。）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318232414868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>未来的虚拟机结构（在硬件之上直接装一个虚拟机，在虚拟机中装不同的内核），集群系统，大型机房常用。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200318232434438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h2><ul>
<li>最初设计<code>unix</code>的时候，是用汇编语言写的，但是太费劲了，于是找人开发出了C语言，所以<code>uniux</code>和<code>c语言</code>就像鸡和蛋的关系，不知道谁先有，而最初设计<code>uniux</code>就是为了玩游戏。所以说<code>C语言</code>非常适合用来编写操作系统。</li>
<li>跟硬件实打实的打交道的程序，只能用汇编语言来编写，其他语言更别说了，C语言也不行。</li>
</ul>
<h1 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h1><h2 id="一、进程管理（cpu管理）"><a href="#一、进程管理（cpu管理）" class="headerlink" title="一、进程管理（cpu管理）"></a>一、进程管理（cpu管理）</h2><ul>
<li>进程控制：（创建，暂停，唤醒，撤销）</li>
<li>进程调度：调度策略，优先级</li>
<li>进程撤销：进程间通信</li>
</ul>
<h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><ul>
<li>内存分配</li>
<li>内存共享</li>
<li>内存保护</li>
<li>虚拟内存管理</li>
</ul>
<h2 id="三、设备管理"><a href="#三、设备管理" class="headerlink" title="三、设备管理"></a>三、设备管理</h2><ul>
<li>设备的分配和调度</li>
<li>设备的无关性</li>
<li>设备传输控制</li>
<li>设备驱动</li>
</ul>
<h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><ul>
<li>存储空间管理</li>
<li>文件的操作</li>
<li>目录的操作</li>
<li>文件和目录存取权限的管理</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>提供接口供用户使用</li>
<li>分配和管理资源</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>数字货币的种类</title>
    <url>/undefined/</url>
    <content><![CDATA[<p>当前的数字货币大致有以下几种。</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200204160645330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>BTC：</strong> 比特币</li>
<li><strong>ETH：</strong> 以太币</li>
<li><strong>USDT：</strong> 泰达币（与同数量的美元是等值的）</li>
<li><strong>EOS：</strong> 为商用分布式应用设计的一款区块链操作系统。EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0 。</li>
<li><strong>XRP：</strong> 瑞波币。它是基于Ripple协议的虚拟货币，主要功能有二：1.防止恶意攻击；2.桥梁货币。</li>
<li><strong>LTC：</strong> 莱特币。<img src="https://img-blog.csdnimg.cn/20200204161448813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>HT：</strong> 火币<br><img src="https://img-blog.csdnimg.cn/20200204161631662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>HUSD：</strong> 稳定币<img src="https://img-blog.csdnimg.cn/20200204162140418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>BCH：</strong><img src="https://img-blog.csdnimg.cn/20200204162243770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;&lt;小狗钱钱&gt;&gt;</title>
    <url>/read.html/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在B站看了半佛仙人一期关于理财的视频，视频里面也推荐了很多值得一看的书，有《小狗钱钱》，《海龟交易法则》，《经济学原理》，我首先看的是小狗钱钱，写下了这篇读后感。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这本书是美国的一版儿童理财读物，虽然说是儿童读物，但在我看来，实际上就是用孩子能够理解的故事，讲述一些大人都未必清楚的一些道理，这些道理可能直白的说出来，成人都懂，可是又有谁能够贯彻到生活中呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致内容讲的是，小女孩吉娅的爸爸妈妈陷入了财政窘迫的时期，吉娅意外的捡到了一条狗，而这是一条会说话的狗，名字就叫钱钱，机缘巧合，钱钱开始教吉娅理财知识，吉娅一步一步富有了起来，并且也帮助爸爸妈妈摆脱了财政窘境。我看完这本书，并不能说从中学到了什么知识，知识把以前了解到的理财观念加深了，就像那句话：道理咱都懂！！！可他并没有深入你的骨髓，这才是关键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将重要的理念罗列以下：</p>
<h2 id="一-做自己喜欢做的事"><a href="#一-做自己喜欢做的事" class="headerlink" title="(一)做自己喜欢做的事"></a>(一)做自己喜欢做的事</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要为了挣钱而去挣钱，尤其是在我们这个年纪，通过打工，兼职挣来的钱，如果只是满足自己的消费欲望，那将毫无意义，如果将这些钱用在正道上，比如说买书，买课程，提高自己的修养与知识积累，那暂且还花对了地方，对我们这个年纪的学生，真正的意义是提升自己的能力，然后再去赚钱，换句话说，就是用自己的专业技能变现，如果专业技能达不到要求，那就将赚钱一事先放在一边，提升技能放在第一位，毕竟以后还是要靠本事吃饭，当你的专业技能足够好时，就不愁赚不到钱，这个时候就要找渠道了。</p>
<h2 id="二-把钱分成日常开销。梦想目标，和账户三部分"><a href="#二-把钱分成日常开销。梦想目标，和账户三部分" class="headerlink" title="(二)把钱分成日常开销。梦想目标，和账户三部分"></a>(二)把钱分成日常开销。梦想目标，和账户三部分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常开销是刚需，这个必不可少，但也不要追求过高的消费，如果超出了自己经济承担范围，那么将所剩无几，梦想目标是指，心中有一个或者多个明确的目标，并且用小本本将他们记下来，估计达成这个目标需要多少钱，多少时间。单独为他们开一个账户，当然这里的账户是指形式上的，目的就是为了实现这些目标而去存钱。</p>
<h2 id="三-进行明智的投资"><a href="#三-进行明智的投资" class="headerlink" title="(三)进行明智的投资"></a>(三)进行明智的投资</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;投资是一门高深的学问，我觉得入个门还是很有必要的，毕竟等到以后，人到中年了，还是靠着储蓄过日子，并不是理想的生活，我身边有很多长辈有观念上的错误，他们就是将挣到的钱定期存进银行里，一存就是五到十年，吃定期的利息，然而他们并想不清楚，你吃银行的利息，通货膨胀在吃你的本金，对于他们那一代人，这个观念既然不能扭转，那就从我们这一代人做起吧，培养理财意识，学习投资方式，也是一种赚钱的利器，万年亘古不变的道理：投资有风险！！！明智的投资会帮你入账不少，而一旦看错了眼，亏损也是常有的事，这就需要长期的积累经验，形成意识了，投资—得先从韭菜做起。</p>
<h2 id="四-关键在于自信程度"><a href="#四-关键在于自信程度" class="headerlink" title="(四) 关键在于自信程度"></a>(四) 关键在于自信程度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个老生常谈的话题，听过很多道理，喝过很多鸡汤，尝试过很多次，然而至少就我个人而言，我是一个没有自信的人，我顶多算是一个脸皮比较厚的人，自信和自卑是对立的，但是他们同样都是骨子里的东西，我们都活了二十多年了，经历的事也不少了，生活环境等等因素，到底是帮我们养成了自信，还是形成了自卑，只有我们自己清楚，深入骨髓的东西很难完全改变，但未必是坏事，在做任何事情的时候，保持谦逊的同时，也要掌握50%的主动权。</p>
<h2 id="五-你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱"><a href="#五-你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱" class="headerlink" title="(五) 你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱"></a>(五) 你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如上面所说的，不为挣钱而做一些没有意义的事，年轻人，多提升以下自己。花时间花精力修炼内功，学习，比什么都重要。</p>
<h2 id="六-欠债的人应该毁掉所有的信用卡"><a href="#六-欠债的人应该毁掉所有的信用卡" class="headerlink" title="(六)欠债的人应该毁掉所有的信用卡"></a>(六)欠债的人应该毁掉所有的信用卡</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里毁掉信用卡，并不是真正意义上的毁掉，就像那些段子：只要你卸载掉支付宝，你就不用还花呗了，对于花呗这个东西，该怎么去形容你最贴切？拿什么跟你作比较才算特别？还是要看用途的，如果是为了缓解经济压力，（这里的经济压力是指，你做了某些有意义的事后，欠下的债），有短期之内不要利息的钱用，何乐而不为呢？但是如果要是为了用这个花呗满足自己的消费欲望，那我觉得还是大可不必了，个人觉得，这种做法，是最low的，买不起我就不买。又不是必需品。还花呗的时候，也要在不收取利息的时候，还最低还款，但是要保证，最终能还清。</p>
<h2 id="七-真的有必要吗？"><a href="#七-真的有必要吗？" class="headerlink" title="(七)真的有必要吗？"></a>(七)真的有必要吗？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花钱买一样东西的时候，事先考虑有没有必要，你是真的需要他吗？买了之后有什么用？能给你带来你预期的效果吗？能用多久？有更好的替代品吗?一般，扪心自问这些问题之后，你就应该知道，该不该买了。得出买不买的结论之后，就要考虑，买什么样的？现在这个信息错综复杂的互联网时代，各种测评，各种推荐，各种大数据分析，最后到你手里的，也许达不到你的预期，什么性价比乱七八糟的，哪儿有什么性价比，都是些商家搞出来唬人的噱头，你真的能看准东西吗？所谓性价比，大部分就是低价配low货，想买的东西，就别去占便宜。你占的便宜最终都会反映在产品上。</p>
<h2 id="八-当你定下大目标的时候，就意味着你必须付出比别人更多的努力。"><a href="#八-当你定下大目标的时候，就意味着你必须付出比别人更多的努力。" class="headerlink" title="(八)当你定下大目标的时候，就意味着你必须付出比别人更多的努力。"></a>(八)当你定下大目标的时候，就意味着你必须付出比别人更多的努力。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我以前考四级的时候，考教师资格证，都没过，包括这次四级430分险过，是因为我没有努力吗？不是，我努力了，周围也有人裸考过了的，并且分比我高多了，羨慕吗？不羡慕，因为我努力过，我没过的原因是我的方法不对，也是努力的不够，你努力了不一定会成功，但你不努力，一定不会有结果，当然也有幸存者偏差，对于天生聪明，基础好的人，可能有些时候会听到这样说：没那个必要，这个也没什么实际意义。但是我始终会坚持自己的理念：当我定下大目标的时候，就意味着必须付出比别人更多的努力。幸运其实是充分准备加上努力工作的结果。</p>
<h2 id="九-克服畏惧心理"><a href="#九-克服畏惧心理" class="headerlink" title="(九)克服畏惧心理"></a>(九)克服畏惧心理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恐惧总是在我们设想事情会如何不顺利的时候出现，我们对失败的可能性想得越多，就越害怕，当你朝着积极地目标去思考的时候，就不会心生畏惧，我从小一直到现在，都没有真正意义上上台讲演过，我永远都是那个坐在台下为他人喝彩的观众，感叹她们真有魄力啊，就连在班级里做个自我介绍我都会脸红，我害怕面对很多人，害怕出糗，也不是没有过讲演的机会，因为我的畏惧，我也不知道我什么时候能踏出这一步，但是我会尽力克服自己的恐惧，等下次机会到来的时候，我不会拱手让人的。</p>
<h2 id="十-72定理"><a href="#十-72定理" class="headerlink" title="(十)72定理"></a>(十)72定理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72定理：用72除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所需要的年数，用72除以通货膨胀率的百分比，得出的数字就是这笔钱贬值一倍所需要的年数。还补充一点就是挑选基金时注意哪些问题：<br>1.基金至少有十年历史，也就是所谓的老基金<br>2.选择大型的跨国股票基金，以分散投资风险<br>3.了解基金的走势图，合理利用72定理</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实之前说看完这本书，我并没有学到多少知识，这句话太过于自大，文章写到这里，我才发现，原来小狗钱钱教会我的东西并不少。去合理利用自己的<code>money</code>吧！！！</p>
]]></content>
      <categories>
        <category>读后感</category>
      </categories>
  </entry>
  <entry>
    <title>建站系列之---部署网站到云服务器</title>
    <url>/3010328778/</url>
    <content><![CDATA[<p>由于这次的疫情，最爱的马云爸爸的阿里云推出了学生在家上机实践的活动，免费领六个月的ECS云服务器，天呐，2核4G啊，六个月之后还可续费六个月，整整一年呐，市场价780软妹币呢，不过投放量少，而且还是每天早上八点领，连续7:55闹钟起早，终于，在第三个早上，马云爸爸眷顾了我，我领到了。领到了就不能让他吃灰吧，于是先部署个博客再说。因为之前博客是托管在github上面的。而github的服务器又在国外，所以访问速度十分感人，但是有了国内的服务器就不一样了，瞬间嗖嗖嗖。。。</p>
<a id="more"></a>

<p><strong>写在开头的话：</strong> 对于一个刚接触的门外汉来说，搭建博客，到部署到服务器真的让人崩溃，但是在不断地排错过程中，也渐渐弄懂了一些东西。很值得！由于我的域名还在备案中，DNS解析已经停掉了，所以暂时只能用公网IP访问：<a href="https://123.57.60.151">123.57.60.151</a>，后期等备案成功后再做修改，并且进一步优化。还想做一点SEO的东西。</p>
<h1 id="一、云服务器配置"><a href="#一、云服务器配置" class="headerlink" title="一、云服务器配置"></a>一、云服务器配置</h1><h2 id="①建立博客存放的目录"><a href="#①建立博客存放的目录" class="headerlink" title="①建立博客存放的目录"></a>①建立博客存放的目录</h2><ul>
<li>我的目录是：<code>home/www/blog</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> /www</span><br><span class="line">mkdir /blog</span><br></pre></td></tr></table></figure>

<h2 id="②安装nginx"><a href="#②安装nginx" class="headerlink" title="②安装nginx"></a>②安装nginx</h2><ul>
<li><strong>搭建服务器环境，以nginx做服务器。</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.安装</span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line">2.启动服务器</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line">3.在浏览器地址栏中输入你的公网ip，如果打开了有内容网页，说明成功了。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>配置服务器的路由：</strong><br>通过公网ip访问，这个地址指向的是nginx，得让他指向我们的博客，就要修改配置文件，找到配置文件<code>etc/nginx/nginx.conf</code>,并不建议直接修改配置文件，应该先创建一个新的文件，然后采用<code>include</code>的方式，将这个文件包含进<code>nginx.conf</code>中。</li>
</ul>
<p>1.新建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/</span><br><span class="line">mkdir vhost</span><br><span class="line"><span class="built_in">cd</span> vhost</span><br><span class="line">vim blog.conf</span><br></pre></td></tr></table></figure>

<p>2.编写配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">编辑blog.conf 如下：</span><br><span class="line">server&#123;</span><br><span class="line">	listen  80;</span><br><span class="line">	root /home/www/blog;这里填博客目录存放的地址</span><br><span class="line">	server_name 这里填域名如(www.baidu.com) 如果暂时没有域名就填阿里云的公网ip，以后有了再改回来;</span><br><span class="line">	location /&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.用<code>include</code>插入到<code>nginx.conf</code>中</p>
<p><img src="https://img-blog.csdnimg.cn/20200317193028631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>4.如果以后还想添加新的网站，也可以在vhost目录下新建一个conf配置文件。然后再用<code>include</code>装入到<code>nginx.conf</code>中。<br>5.（<strong>先跳过这一步，等到最后有问题了，再回来</strong>）最后可能会出现只能访问centOS的怪相，所以，如果出现那个问题了，请你回到这一步，增加一个操作，就是上图中那个<code>server</code>里面的<code>root</code>后面的路径，替换成你的博客存放位置：例如我的是<code>/home/www/blog</code>（这是我经验所得，可能你就会卡在这一步）。</p>
<h2 id="③安装Nodejs"><a href="#③安装Nodejs" class="headerlink" title="③安装Nodejs"></a>③安装Nodejs</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.换源</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line"></span><br><span class="line">2.安装</span><br><span class="line">yum install -y nodejs</span><br><span class="line"></span><br><span class="line">3.检查版本</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="④安装Git以及配置仓库"><a href="#④安装Git以及配置仓库" class="headerlink" title="④安装Git以及配置仓库"></a>④安装Git以及配置仓库</h2><ul>
<li><strong>目的：</strong> 使本地主机可以通过<code>ssh</code>方式连接到云服务器，我们就可以在本地使用<code>git</code>将我们的博客部署到服务器上。</li>
</ul>
<p>1.安装<code>git</code>并查看版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.安装</span><br><span class="line">yum install git</span><br><span class="line">2.查看版本</span><br><span class="line">git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure>
<p>2.新建<code>git</code>用户，并修改权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.新建git用户</span><br><span class="line">adduser -m  git</span><br><span class="line">2.修改用户权限</span><br><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>3.添加<code>Git  ALL=(ALL)   ALL</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200317200019229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>4.保存退出后，将权限改回去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>5.设置<code>git</code>密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure>

<p>6.切换到<code>git</code>用户，在<code>~</code>目录下，可以看到有一个<code>.ssh</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir .ssh</span><br><span class="line"><span class="built_in">cd</span> /.ssh</span><br></pre></td></tr></table></figure>
<p>7.生成公钥密钥文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">此时在目录下就会有两个文件，分别是id_rsa 和 id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>8.id_rsa.pub 就是公钥文件，将他复制一份。目录下就会多出一个authorized_keys文件，它和id_rsa.pub一模一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure>
<p>9.修改权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>
<p>10.在<strong>本地主机</strong>上打开<code>cmd</code>，使用<code>ssh</code>方式连接云服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -v git@123.57.60.151(这里填的是服务器公网ip)</span><br></pre></td></tr></table></figure>
<p>11.输入密码之后，看到如图，即代表成功！！！！</p>
<p><img src="https://img-blog.csdnimg.cn/20200317202421490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>12.创建一个<code>git</code>的仓库，并且新建一个<code>post-receive</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.创建并初始化Git仓库</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git init --bare blog.git</span><br><span class="line"></span><br><span class="line">2.新建post—receive文件</span><br><span class="line">vi ~/blog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">3.输入以下内容：</span><br><span class="line">git --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f</span><br><span class="line"></span><br><span class="line">4.保存退出之后赋予可执行权限</span><br><span class="line">chmod +x ~/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<p><strong>至此，服务器端的配置完成！！！！！！！！</strong></p>
<h1 id="二、本地主机配置"><a href="#二、本地主机配置" class="headerlink" title="二、本地主机配置"></a>二、本地主机配置</h1><p><strong>说明：</strong> 因为我之前没有云服务器的时候，是把博客部署在<strong>github</strong>仓库中的，所以，在下面的<code>config.yml</code>中会出现两个仓库，这并不影响，他会同时部署到<code>github</code>中和云服务器上，想要了解的话可以去看这篇文章：<a href="https://blog.csdn.net/weixin_44861399/article/details/104673527">https://blog.csdn.net/weixin_44861399/article/details/104673527</a>，下面就是正式的，将本地主机与服务器连接起来的具体步骤了。</p>
<h2 id="①安装git"><a href="#①安装git" class="headerlink" title="①安装git"></a>①安装git</h2><p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<h2 id="②安装Node-js"><a href="#②安装Node-js" class="headerlink" title="②安装Node.js"></a>②安装Node.js</h2><p>下载地址：<a href="http://nodejs.org/download/">http://nodejs.org/download/</a></p>
<ul>
<li>安装的时候，选择<code>add to path</code>，他会自动配置环境变量。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">出现版本号说明安装成功</span><br></pre></td></tr></table></figure>
<ul>
<li>换镜像（亲身体验，可以省去以后好多麻烦）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>


<h2 id="③安装Hexo"><a href="#③安装Hexo" class="headerlink" title="③安装Hexo"></a>③安装Hexo</h2><ul>
<li>用cnpm全局安装，在桌面右键打开<code>Git bash here</code>输入：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<ul>
<li>安装完成后，在命令行里输入<code>hexo -v</code>检查是否安装成功。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305155050299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="④hexo本地部署"><a href="#④hexo本地部署" class="headerlink" title="④hexo本地部署"></a>④hexo本地部署</h2><ul>
<li>在本地新建一个文件夹，我命名它为blog</li>
<li>在这个文件夹下，右键打开<code>Git Bash here</code>，输入<code>hexo init</code>，我在这个地方出现了一个<code>WARN</code>，暂时不用管它。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305135143147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>继续输入<code>cnpm install</code>可以看到blog文件夹里出现：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305155919286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>输入：<code>hexo g</code></li>
<li>输入：<code>hexo s</code> </li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305135917128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>打开浏览器输入<code>localhost：4000</code>，可以看到部署好了，有一篇<code>hello World</code>的博客</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200305154439378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="⑤连接到远端服务器"><a href="#⑤连接到远端服务器" class="headerlink" title="⑤连接到远端服务器"></a>⑤连接到远端服务器</h2><ul>
<li>安装 <code>deployer</code> 插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ul>
<li>打开<code>F:\blog\_config.yml</code>,找到 <code>deploy</code>。填写你自己的仓库名字。不能同时又相同的<code>repo</code>，需要删除一个。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200317204903306.png" alt="在这里插入图片描述"><br><strong>至此，本地主机的配置也完毕了！！！！</strong></p>
<h1 id="三、发布文章"><a href="#三、发布文章" class="headerlink" title="三、发布文章"></a>三、发布文章</h1><ul>
<li>写一篇文章：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.新建文章，并编写，如何编写，百度</span><br><span class="line">hexo new <span class="string">"Hello My First Blog"</span></span><br><span class="line"></span><br><span class="line">2. 发布(要在blog文件夹下打开git)</span><br><span class="line">hexo clean &amp;&amp; hexo generate --deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>重启服务器的nginx</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器地址栏中输入公网ip查看成果。</li>
</ul>
<h1 id="四、美化博客"><a href="#四、美化博客" class="headerlink" title="四、美化博客"></a>四、美化博客</h1><p>请参考我的这篇文章：<a href="https://blog.csdn.net/weixin_44861399/article/details/104646946">https://blog.csdn.net/weixin_44861399/article/details/104646946</a></p>
]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型---抽象工厂模式</title>
    <url>/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一个创建一系列相关和相互依赖对象的接口，而无需指定他们具体的类。</p>
<a id="more"></a>

<h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul>
<li>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题。</li>
<li>但是由于工厂方法模式中每个具体工厂只能产生一个单一的对象，如果需要工厂提供多种产品对象，那么会存在大量的工厂类，加大系统的开销。</li>
<li>可以考虑将一些相关的产品组成一个<code>产品族</code>，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。</li>
<li><strong>例如：</strong> 我需要生产<code>海尔电视机，海尔冰箱，海尔空调，海信冰箱，海信空调，海信电视机，Tcl电视机，TCL冰箱，TCL空调，</code>如果用工厂方法模式的话，就要创建9个具体工厂类，但是如果使用抽象工厂模式的话，只需要按照产品等级结构（海尔，海信，TCL）和产品族（电视机，冰箱，空调，）划分，只需要提供三个具体工厂，极大的减少了系统种类的歌个数。</li>
<li><strong>定义：</strong> <strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类，抽象工厂模式又成为工具模式。</strong></li>
</ul>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul>
<li><code>AbstractFactory</code>(抽象工厂)：我们一组用于创建一<code>族</code>产品的方法，一个方法对应一种产品。</li>
<li><code>ConcreteFactory</code>（具体工厂）：生成一组具体产品，这些产品构成了一个产品族。</li>
<li><code>AbstractProduct</code>(抽象产品)：声明产品所具有的业务方法。</li>
<li><code>ConcreteProduct</code>(具体产品)：具体产品对象。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 设计一款皮肤库，有不同风格，每种风格又分种类。风格就是<strong>等级结构</strong>，后面的就是<strong>产品族</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200503152520604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200503164112458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点：</li>
</ul>
<ol>
<li>隔离了具体类的生成，用户并不需要知道什么被创建，只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统行为。</li>
<li>当一个产品族中多个对象被设计成一起工作时，他能够保证客户端是终止使用同一个产品族中的对象。</li>
<li>增加新的产品族很方便，无需修改已有系统。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来很大的不便，违背了开闭原则。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/1664209794/</url>
    <content><![CDATA[<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<a id="more"></a>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul>
<li><strong>数据库的连接对象创建工作，比较消耗性能。</strong> </li>
<li>一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。  后面需要连接的话，直接从池子里面去。不要去自己创建连接了。  使用完毕， 要记得归还连接。确保连接对象能循环利用。</li>
</ul>
<ul>
<li>连接池指：创建一个池子（容器） ， 专门用来管理连接对象。<br><img src="https://img-blog.csdnimg.cn/20200301155401842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><ul>
<li>创建和管理连接，对数据的操作没有影响。</li>
<li>更快响应速度，连接池里的连接在一开始就已经创建好了，后面如果需要直接拿就可以了，无需创建。</li>
<li>资源的重复利用、避免重复创建对象，连接对象使用完毕后，再归还到池子中进行统一管理即可。</li>
</ul>
<h2 id="三、自定义数据库连接池"><a href="#三、自定义数据库连接池" class="headerlink" title="三、自定义数据库连接池"></a>三、自定义数据库连接池</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这是一个数据库连接池</span><br><span class="line"> * 一开始先往池子里面放十个连接</span><br><span class="line"> */</span><br><span class="line">public class MyDataSource implements DataSource &#123;</span><br><span class="line">//创建一个集合用来存放连接对象</span><br><span class="line">	List&lt;Connection&gt; list=new ArrayList&lt;Connection&gt;();</span><br><span class="line">	//用一个构造方法，刚开始就给这个池子里放入10个连接对象</span><br><span class="line">	public <span class="function"><span class="title">MyDataSource</span></span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			Connection conn = JDBCUtil.getconn();</span><br><span class="line">			list.add(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 该连接池对外公布的获取连接的方法</span><br><span class="line">	@Override</span><br><span class="line">	public Connection getConnection() throws SQLException &#123;</span><br><span class="line">		//来拿连接的时候，先看看，池子里面有没有，没有了就再添加，扩容</span><br><span class="line">		<span class="keyword">if</span>(list.size()==0) &#123;</span><br><span class="line">			<span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">				Connection conn = JDBCUtil.getconn();</span><br><span class="line">				list.add(conn);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Connection conn=list.remove(0);</span><br><span class="line">		<span class="built_in">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//用完之后返回连接对象</span><br><span class="line">	public void addBack(Connection conn) &#123;</span><br><span class="line">		list.add(conn);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用连接池</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TestPool &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void <span class="function"><span class="title">testPool</span></span>() &#123;</span><br><span class="line">		Connection conn=null;</span><br><span class="line">		PreparedStatement ps=null;</span><br><span class="line">		MyDataSource dataSource=new MyDataSource();</span><br><span class="line">		try &#123;</span><br><span class="line">			conn=dataSource.getConnection();</span><br><span class="line">			</span><br><span class="line">			String sql=<span class="string">"insert into category values(null,'lisi',daq)"</span>;</span><br><span class="line">			ps=conn.prepareStatement(sql);</span><br><span class="line">			ps.executeUpdate();</span><br><span class="line">			</span><br><span class="line">		&#125; catch (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			//归还连接对象</span><br><span class="line">			dataSource.addBack(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><ul>
<li>对象没有做成单例。<br>在哪里使用，都需要new MyDataSource().  这就会造成有多个对象的情况出现， 那就不只一个池子了。</li>
<li>需要额外记住 addBack方法。<br>由于sun公司定义的数据库连接池里面并没有这个addBack方法，所以要用这个连接池的时候，需要记住这个方法是用来回收连接对象的。</li>
<li>无法面向接口编程。<br>由于连接池直接定义成了一个类，并且里面还额外添加了一个addBack方法，这就造成了无法面向接口编程。</li>
</ul>
<p><strong>解决思路：</strong><br>由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且不能面向接口编程。</p>
<ol>
<li>修改接口中的close方法。  原来的Connection对象的close方法，是真的关闭连接。 </li>
<li>修改此close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。如何扩展某一个方法?</li>
</ol>
<p>原有的方法逻辑，不是我们想要的。 想修改方法的逻辑，怎么办？</p>
<ol>
<li>直接改源码  无法实现。</li>
<li>继承， 必须得知道这个接口的具体实现是谁。 </li>
<li>使用装饰者模式。 </li>
<li>动态代理</li>
</ol>
<h3 id="解决方式：装饰者模式"><a href="#解决方式：装饰者模式" class="headerlink" title="解决方式：装饰者模式"></a>解决方式：装饰者模式</h3><p>两个不同的人，去实现同一个接口，先把我的方法执行了，再执行你的。</p>
<h2 id="四、开源连接池"><a href="#四、开源连接池" class="headerlink" title="四、开源连接池"></a>四、开源连接池</h2><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><ul>
<li>DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.导入jar包  commons-dbcp.jar和commons-pool.jar</span><br><span class="line">2.不使用配置文件方式（不常用）</span><br><span class="line">		// 1.构建数据源对象</span><br><span class="line">		BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		//Url格式-主协议：子协议：//本地//数据库</span><br><span class="line">		dataSource.setUrl(<span class="string">"jdbc:mysql://localhost/users"</span>);</span><br><span class="line">		dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"daq"</span>);</span><br><span class="line">		// 2.得到连接对象</span><br><span class="line">		conn = dataSource.getConnection();</span><br><span class="line">		String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">		ps.setInt(2,23);</span><br><span class="line">		</span><br><span class="line">		ps.executeUpdate();</span><br><span class="line">		...</span><br><span class="line">3.使用配置文件方式。(常用)</span><br><span class="line">		1. 在 src 下定义配置文件 dbcp.properties. 内容如下： </span><br><span class="line">			//连接设置</span><br><span class="line">			driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">			url=jdbc:mysql://localhost:3306/jdbc</span><br><span class="line">			username=root</span><br><span class="line">			password=daq</span><br><span class="line">			...</span><br><span class="line">		2. 使用代码读取配置文件，即可获取连接池</span><br><span class="line">			BasicDataSourceFactory factory=new BasicDataSourceFactory();</span><br><span class="line">			Properties properties = new Properties();</span><br><span class="line">			properties.load(new FileInputStream(<span class="string">"src/dbcp.properties"</span>));</span><br><span class="line">			DataSource dataSource =factory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">			conn = dataSource.getConnection();</span><br><span class="line">			String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">			ps = conn.prepareStatement(sql);</span><br><span class="line">			ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">			ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">			ps.executeUpdate();</span><br><span class="line">			...</span><br></pre></td></tr></table></figure>

<h3 id="C3P0（重点）"><a href="#C3P0（重点）" class="headerlink" title="C3P0（重点）"></a>C3P0（重点）</h3><ul>
<li>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 拷贝jar 文件   c3p0-0.9.1.2.jar</span><br><span class="line">2. 不使用配置文件方式（开发的时候不会用）</span><br><span class="line">		//默认会找 xml 中的 default-config 分支。 </span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		//2. 设置连接数据的信息</span><br><span class="line">		dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/users"</span>);</span><br><span class="line">		dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"daq"</span>);</span><br><span class="line">		//3. 获取连接对象</span><br><span class="line">		conn = dataSource.getConnection();</span><br><span class="line">		String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">		ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">		ps.executeUpdate();</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">3. 使用配置文件方式。（开发常用）</span><br><span class="line">c3p0的配置文件 支持 properties , 也支持 xml 方式。 不过开发中，一般使用xml方式来配置</span><br><span class="line"></span><br><span class="line">	1.  src下， 创建xml文件，名为：c3p0-config.xml 　注意此处，名字需要固定了。</span><br><span class="line">	&lt;c3p0-config&gt;</span><br><span class="line">  		&lt;default-config&gt;</span><br><span class="line">    		&lt;property name=<span class="string">"driverClass"</span>&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">    		&lt;property name=<span class="string">"jdbcUrl"</span>&gt;jdbc:mysql://localhost/user&lt;/property&gt;</span><br><span class="line">    		&lt;property name=<span class="string">"user"</span>&gt;root&lt;/property&gt;</span><br><span class="line">    		&lt;property name=<span class="string">"password"</span>&gt;daq&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  			&lt;!-- 可选配置 --&gt;</span><br><span class="line">			&lt;property name=<span class="string">"initialPoolSize"</span>&gt;10&lt;/property&gt;   //初始容量</span><br><span class="line">			&lt;property name=<span class="string">"maxIdleTime"</span>&gt;30&lt;/property&gt;		 //</span><br><span class="line">			&lt;property name=<span class="string">"maxPoolSize"</span>&gt;100&lt;/property&gt;		 //最大容量</span><br><span class="line">			&lt;property name=<span class="string">"minPoolSize"</span>&gt;10&lt;/property&gt;		 //最小容量</span><br><span class="line">			&lt;property name=<span class="string">"maxStatement"</span>&gt;200&lt;/property&gt;	 //</span><br><span class="line">  		&lt;/default-config&gt;</span><br><span class="line">	&lt;/c3p0-config&gt;</span><br><span class="line"></span><br><span class="line">		//1. 代码中获取连接dataSource对象</span><br><span class="line">		ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">		//2. 获取连接对象</span><br><span class="line">		conn = dataSource.getConnection();</span><br><span class="line">		String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">		ps.setInt(2,23);</span><br><span class="line">		</span><br><span class="line">		ps.executeUpdate();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql,连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>建站系列之---更换icarus主题</title>
    <url>/hexo/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看惯了next的主题，出现了审美疲劳，在逛知乎的时候，发现了一款很不错的主题<code>icarus</code>，就试着更换了主题，发现还真挺漂亮的，于是就在做一个主题吧，哪天审美又疲劳了，再换回来呗。</p>
<a id="more"></a>

<h2 id="页面点击出现爱心"><a href="#页面点击出现爱心" class="headerlink" title="页面点击出现爱心"></a>页面点击出现爱心</h2><ul>
<li>在<code>F:\blog\themes\icarus\source\js</code>下，新建<code>clicklove.js</code>，写入以下代码。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),</span><br><span class="line">        o(),</span><br><span class="line">        r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)</span><br><span class="line">            d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;</span><br><span class="line">        e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            t&amp;&amp;t(),i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);</span><br><span class="line">            a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(t)&#123;</span><br><span class="line">            a.styleSheet.cssText=e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d=[];</span><br><span class="line">    e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(),</span><br><span class="line">    n()</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>layout.ejs</code>，找到<code>F:\blog\themes\icarus\layout\layout.ejs</code>,添加：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js/clicklove.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="给文章添加目录"><a href="#给文章添加目录" class="headerlink" title="给文章添加目录"></a>给文章添加目录</h2><ul>
<li>在主题配置文件中，添加如下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">	-</span><br><span class="line">    <span class="built_in">type</span>: toc</span><br><span class="line">    position: left</span><br></pre></td></tr></table></figure>
<ul>
<li>在每次写文章的时候都要添加<code>toc： true</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">toc： <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h2><ul>
<li>在<code>_config.yml</code>中开启画廊功能：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugines:</span><br><span class="line">	gallery: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="模块布局"><a href="#模块布局" class="headerlink" title="模块布局"></a>模块布局</h2><ul>
<li>初始的页面有很多模块，例如归档，标签云，最近文章，乱七八糟的，可以选择饿在左侧栏还是右侧栏显示这些模块，当然也可以隐藏这些模块。要在主题的配置文件修改。找到<code>widget</code>字样，例如下面有，分别有：左（<code>lift</code>），右（<code>right</code>），隐藏（<code>false</code>）。左右栏固定，不随着滑轮滑动。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">    <span class="comment"># left sidebar settings</span></span><br><span class="line">    left:</span><br><span class="line">        <span class="comment"># Whether the left sidebar is sticky when page scrolls</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        sticky: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># right sidebar settings</span></span><br><span class="line">    right:</span><br><span class="line">        <span class="comment"># Whether the right sidebar is sticky when page scrolls</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        sticky: <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"> <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: category</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: left</span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: tagcloud</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: recent_posts</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: archive</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: tag</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: lift</span><br></pre></td></tr></table></figure>
<h2 id="开启评论系统"><a href="#开启评论系统" class="headerlink" title="开启评论系统"></a>开启评论系统</h2><ul>
<li>在<a href="https://leancloud.cn/">leancloud官网</a>注册账号，详情请看：<a href="https://valine.js.org/quickstart.html">参考书</a></li>
<li>在主题配置文件中找到<code>comment</code>字样，添加如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comment:</span><br><span class="line">    <span class="built_in">type</span>: valine</span><br><span class="line">    app_id: 你的id</span><br><span class="line">    app_key: 你的key</span><br><span class="line">    notify: <span class="literal">false</span></span><br><span class="line">    verify: <span class="literal">false</span></span><br><span class="line">    placeholder:</span><br></pre></td></tr></table></figure>
<h2 id="valine域名绑定"><a href="#valine域名绑定" class="headerlink" title="valine域名绑定"></a>valine域名绑定</h2><ul>
<li>因为要使用到valine的数据库存储功能，就得在leancloud备案域名。</li>
<li>先给域名创建一个二级域名</li>
</ul>
<h2 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">donate:</span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="built_in">type</span>: alipay</span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        qrcode: <span class="string">'/images/alipay.jpg'</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="built_in">type</span>: wechat</span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        qrcode: <span class="string">'/images/wechatpay.jpg'</span></span><br><span class="line">    <span class="comment">#-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment">#type: paypal</span></span><br><span class="line">        <span class="comment"># Paypal business ID or email address</span></span><br><span class="line">        <span class="comment">#business: ''</span></span><br><span class="line">        <span class="comment"># Currency code</span></span><br><span class="line">        <span class="comment">#currency_code: USD</span></span><br><span class="line">    <span class="comment">#-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment">#type: patreon</span></span><br><span class="line">        <span class="comment"># URL to the Patreon page</span></span><br><span class="line">        <span class="comment">#url: ''</span></span><br></pre></td></tr></table></figure>

<h2 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h2><ul>
<li>找到<code>search</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search</span><br><span class="line">	<span class="built_in">type</span>： insight</span><br></pre></td></tr></table></figure>
<h2 id="首页三栏，阅读两栏"><a href="#首页三栏，阅读两栏" class="headerlink" title="首页三栏，阅读两栏"></a>首页三栏，阅读两栏</h2><ul>
<li>找到<code>F:\blog\themes\icarus\includes\helpers\layout.js</code>，第24行开始修改如下：+代表增加，-代表删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">const</span> widgets = hexo.extend.helper.get(<span class="string">'get_config'</span>).bind(<span class="keyword">this</span>)(<span class="string">'widgets'</span>);</span><br><span class="line">-    <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; widget.position === position);</span><br><span class="line">+    <span class="keyword">if</span> (<span class="keyword">this</span>.page.layout !== <span class="string">'post'</span>) &#123;</span><br><span class="line">+        <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; widget.position === position);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span> (position === <span class="string">'left'</span>) &#123;</span><br><span class="line">+        <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; (widget.type === <span class="string">'toc'</span> || widget.type === <span class="string">'profile'</span>));</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+        <span class="keyword">return</span> []</span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>layout/common/widget.ejs</code>修改第五行如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;% <span class="function"><span class="keyword">function</span> <span class="title">side_column_class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (column_count()) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">-            <span class="keyword">return</span> <span class="string">'is-4-tablet is-4-desktop is-4-widescreen'</span>;</span><br><span class="line">+            <span class="keyword">return</span> <span class="string">'is-4-tablet is-4-desktop is-3-widescreen'</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>layout/layout.ejs</code>修改如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"is-&lt;%= column_count() %&gt;-column"</span>&gt;</span></span></span><br><span class="line">+&lt;body class="is-3-column"&gt;</span><br><span class="line">     &lt;%- partial('common/navbar', &#123; page &#125;) %&gt;</span><br><span class="line">     &lt;% function main_column_class() &#123;</span><br><span class="line">         switch (column_count()) &#123;</span><br><span class="line">             case 1:</span><br><span class="line">                 return 'is-12';</span><br><span class="line">             case 2:</span><br><span class="line">-                return 'is-8-tablet is-8-desktop is-8-widescreen';</span><br><span class="line">+                return 'is-8-tablet is-8-desktop is-9-widescreen';</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>source/css/style/styl</code>,在不同屏幕下的大小</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     .is<span class="number">-2</span>-column .container</span><br><span class="line">         max-width: screen-desktop - <span class="number">2</span> * gap</span><br><span class="line">         width: screen-desktop - <span class="number">2</span> * gap</span><br><span class="line">+    .is<span class="number">-3</span>-column .container</span><br><span class="line">+        max-width: screen-widescreen - gap</span><br><span class="line">+        width: screen-widescreen - gap</span><br><span class="line"> @media screen and (min-width: screen-fullhd)</span><br><span class="line">+    .is<span class="number">-3</span>-column .container</span><br><span class="line">+        max-width: screen-fullhd - <span class="number">2</span> * gap</span><br><span class="line">+        width: screen-fullhd - <span class="number">2</span> * gap</span><br><span class="line">     .is<span class="number">-2</span>-column .container</span><br><span class="line">         max-width: screen-widescreen - <span class="number">2</span> * gap</span><br><span class="line">         width: screen-widescreen - <span class="number">2</span> * gap</span><br></pre></td></tr></table></figure>
<h2 id="目录固定"><a href="#目录固定" class="headerlink" title="目录固定"></a>目录固定</h2><ul>
<li>找到<code>layout/widget/toc.ejs</code>，增加<code>column-left is-sticky</code>类，在第28行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card widget"</span> <span class="attr">id</span>=<span class="string">"toc"</span>&gt;</span></span></span><br><span class="line">+&lt;div class="card widget column-left is-sticky" id="toc"&gt;</span><br></pre></td></tr></table></figure>
<h2 id="默认开启目录"><a href="#默认开启目录" class="headerlink" title="默认开启目录"></a>默认开启目录</h2><ul>
<li>找到<code>includes/helpers/config.js</code>，修改第33行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> property = readProperty(specs, configName);</span><br><span class="line">-       <span class="keyword">return</span> property === <span class="literal">null</span> ? <span class="literal">null</span> : property[descriptors.defaultValue];</span><br><span class="line">+       <span class="keyword">const</span> result = property === <span class="literal">null</span> ? <span class="literal">null</span> : property[descriptors.defaultValue];</span><br><span class="line">+       <span class="keyword">return</span> (configName === <span class="string">'toc'</span> &amp;&amp; <span class="keyword">this</span>.page.layout === <span class="string">'post'</span> &amp;&amp; result === <span class="literal">null</span>) ? <span class="literal">true</span> : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="个人信息布局"><a href="#个人信息布局" class="headerlink" title="个人信息布局"></a>个人信息布局</h2><ul>
<li>找到<code>layout/widget/profile.ejs</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-    <span class="xml"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"level is-mobile"</span>&gt;</span></span></span><br><span class="line">+    &lt;nav class="level menu-list is-mobile" style="margin-bottom:1rem"&gt;</span><br><span class="line">         &lt;div class="level-item has-text-centered is-marginless"&gt;</span><br><span class="line">-            &lt;div&gt;</span><br><span class="line">+            &lt;a href="&lt;%- url_for('/archives/') %&gt;"&gt;</span><br><span class="line">                 &lt;p class="heading"&gt;</span><br></pre></td></tr></table></figure>


<h2 id="移动端优化"><a href="#移动端优化" class="headerlink" title="移动端优化"></a>移动端优化</h2><ul>
<li>在移动端，隐藏<code>archive</code> 和 <code>tagcloud</code>。</li>
<li>找到<code>layout/widget/archive.ejs</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card widget"</span>&gt;</span></span></span><br><span class="line">+&lt;div class="card widget is-hidden-mobile"&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>layout/widget/recent_posts.ejs</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card widget is-hidden-mobile"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-content"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="增加版权说明"><a href="#增加版权说明" class="headerlink" title="增加版权说明"></a>增加版权说明</h2><ul>
<li>找到<code>layout/common/article.ejs</code>，在第50行修改如下：</li>
</ul>
<p>2020/5/6 20:21:35 2020/5/6 20:21:36 2020/5/6 20:21:38 2020/5/6 20:21:39 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">     &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">         &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">+    &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) &#123; %&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;ul class="post-copyright"&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文标题：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文作者：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= theme.url %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.author</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文链接：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.permalink</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;发布时间：&lt;/</span>strong&gt;&lt;%= post.date.format(<span class="string">"YYYY-MM-DD"</span>) %&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;版权声明：&lt;/</span>strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=<span class="string">"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"</span> rel=<span class="string">"external nofollow"</span> target=<span class="string">"_blank"</span>&gt;CC BY-NC-SA <span class="number">4.0</span>&lt;<span class="regexp">/a&gt; 许可协议。转载请注明出处！</span></span><br><span class="line"><span class="regexp">+        &lt;/</span>li&gt;</span><br><span class="line">+        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">+    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">     &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) &#123; %&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>版权说明的样式：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">+.post-copyright</span><br><span class="line">+    font-size: <span class="number">1</span>rem</span><br><span class="line">+    letter-spacing: <span class="number">0.02</span>rem</span><br><span class="line">+    word-<span class="keyword">break</span>: <span class="keyword">break</span>-all</span><br><span class="line">+    margin: <span class="number">2.5</span>rem <span class="number">0</span> <span class="number">0</span></span><br><span class="line">+    padding: <span class="number">1</span>rem <span class="number">1</span>rem</span><br><span class="line">+    border-left: 3px solid #FF1700</span><br><span class="line">+    background-color: #F9F9F9</span><br></pre></td></tr></table></figure>

<h2 id="增加busuanzi统计"><a href="#增加busuanzi统计" class="headerlink" title="增加busuanzi统计"></a>增加busuanzi统计</h2><ul>
<li>在<code>_config.yml</code>中，找到<code>busuanzi</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">busuanzi: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打开<code>layout/common/footer.ejs</code>文件，找到<code>&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</code>，在下方添加：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  &lt;% <span class="keyword">if</span> (busuanzi) &#123; %&gt;</span><br><span class="line">   &lt;br&gt;</span><br><span class="line">-  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">-  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">_p</span>('<span class="attr">plugin.visitor</span>', '&lt;<span class="attr">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>') %&gt;</span></span><br><span class="line"><span class="xml">-  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">+  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span>来访<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>0人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">+  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>总访问<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>0次<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">   &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用阿里巴巴图标库"><a href="#使用阿里巴巴图标库" class="headerlink" title="使用阿里巴巴图标库"></a>使用阿里巴巴图标库</h2><ul>
<li>由于icarus默认使用的图标库是 <code>font Awesome</code>，里面的图标只有600多个，而且都是黑白的，并且有的时候还加载不出来（墙的原因），所以我换做用<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">阿里巴巴矢量图标库</a>。</li>
<li>首先登陆，将喜欢的图标添加到购物车，记得要一次添加完，提前看好你需要哪些图标，然后在右上角购物车里找到最下房<code>下载代码</code>，下载到本地。</li>
<li>在本地打开下载好的文件夹，找到<code>iconfont.css</code>，添加到<code>F:\blog\themes\icarus\source\css</code>。</li>
<li>找到<code>F:\blog\themes\icarus\layout\widget\profile.ejs</code>,添加一行代码，引入<code>iconfont.css</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> socialLinks) &#123;</span><br><span class="line">     <span class="keyword">let</span> link = socialLinks[name]; %&gt;</span><br><span class="line">+    <span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/iconfont.css"</span>&gt;</span></span></span><br><span class="line">     &lt;a class="level-item button is-white is-marginless" target="_blank" title="&lt;%= name %&gt;" href="&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;"&gt;</span><br><span class="line">     &lt;% if (typeof(link) === 'string') &#123; %&gt;</span><br><span class="line">     &lt;%= name %&gt;</span><br><span class="line">     &lt;% &#125; else &#123; %&gt;</span><br><span class="line">     &lt;i class="&lt;%= link.icon %&gt;"&gt;&lt;/i&gt;</span><br><span class="line">     &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改主题配置文件，这次主要改图标名字，图标名字也可以打开<code>iconfont.css</code>查看。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">  Github:</span><br><span class="line">      icon: iconfont icon-git</span><br><span class="line">      url: <span class="string">'https://github.com/DAQ121'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>像有些内嵌的图标，比如说目录啊，标签啊这些。就要找到对应的<code>.js</code>文件，添加代码。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020032720501748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">- 如果使用的是<code>font awesome图标库的话</code>，就添加<code>&lt;i class=&quot;fas fa-guidang&quot;&gt;&lt;/i&gt;</code>,如果使用的是<code>阿里云图标库</code>的话，就添加<code>&lt;i class=&quot;iconfont icon-guidang&quot;&gt;&lt;/i&gt;</code>，注意，要添加在<code>&lt;h3&gt;&lt;/h3&gt;</code>内部。</p>
<p><img src="https://img-blog.csdnimg.cn/20200327205203894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="按钮背景颜色"><a href="#按钮背景颜色" class="headerlink" title="按钮背景颜色"></a>按钮背景颜色</h2><ul>
<li>找到<code>style.styl</code>，添加两行代码。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"> <span class="selector-class">.menu-list</span> <span class="selector-tag">li</span> ul</span><br><span class="line">        <span class="attribute">margin-right</span>: <span class="number">0</span></span><br><span class="line">+    <span class="selector-class">.menu-list</span> a</span><br><span class="line">+       <span class="attribute">transition</span>: background-color <span class="number">0.3s</span> ease-in-out</span><br><span class="line">    <span class="selector-class">.menu-list</span> <span class="selector-tag">a</span>.level</span><br><span class="line">        <span class="attribute">display</span>: flex</span><br><span class="line">    <span class="selector-class">.has-text-centered</span> <span class="selector-tag">figure</span>.image</span><br><span class="line">        <span class="attribute">margin</span>: auto</span><br></pre></td></tr></table></figure>
<h2 id="网站运行时间"><a href="#网站运行时间" class="headerlink" title="网站运行时间"></a>网站运行时间</h2><ul>
<li>找到<code>/themes/icarus/layout/common/footer.ejs</code>，在合适位置添加以下代码</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> Date(); </span><br><span class="line">  <span class="function">function <span class="title">createtime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> grt= <span class="keyword">new</span> Date(<span class="string">"12/28/2018 12:49:00"</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间 </span></span><br><span class="line">  now.setTime(now.getTime()+<span class="number">250</span>); </span><br><span class="line">  days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = Math.floor(days); </span><br><span class="line">  hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = Math.floor(hours); </span><br><span class="line">  <span class="keyword">if</span>(String(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span><br><span class="line">  mnum = Math.floor(minutes); <span class="keyword">if</span>(String(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span><br><span class="line">  seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum); </span><br><span class="line">  snum = Math.round(seconds); <span class="keyword">if</span>(String(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span><br><span class="line">   document.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"本站已安全运行 "</span>+dnum+<span class="string">" 天 "</span>; </span><br><span class="line">  document.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span><br><span class="line">                &#125; </span><br><span class="line">   setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h2><ul>
<li>安装feed插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<ul>
<li>打开站点配置文件,添加如下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line">plugin:</span><br><span class="line">    - hexo-generator-feed</span><br><span class="line">    <span class="comment">#Feed.Atom</span></span><br><span class="line">    feed:</span><br><span class="line">    <span class="built_in">type</span>: atom</span><br><span class="line">    path: rss.xml</span><br><span class="line">    <span class="built_in">limit</span>: 0</span><br><span class="line">    hub:</span><br><span class="line">  	content: <span class="string">'true'</span></span><br><span class="line"> 	order_by: -date</span><br></pre></td></tr></table></figure>
<ul>
<li>打开主题配置文件,找到<code>rss</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RSS:</span><br><span class="line">    icon: fas fa-rss</span><br><span class="line">    url: /rss.xml</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---死锁</title>
    <url>/1179211128/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br><strong>简单理解就是：</strong> 我想要你手里的东西，同时你也想要我手里的资源，我俩同时都不让出来，谁也拿不到。</p>
<a id="more"></a>

<h2 id="为什么会产生死锁？"><a href="#为什么会产生死锁？" class="headerlink" title="为什么会产生死锁？"></a>为什么会产生死锁？</h2><ul>
<li><strong>系统资源的竞争：</strong> 当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。</li>
<li><strong>进程运行推进顺序不当引起死锁：</strong> 　　若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。</li>
</ul>
<h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ol>
<li><p><strong>互斥条件：</strong> 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
</li>
<li><p><strong>请求与保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
</li>
<li><p><strong>不可剥夺条件：</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p>
</li>
<li><p><strong>循环等待条件：</strong> 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
</li>
</ol>
<ul>
<li>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</li>
</ul>
<h2 id="解决策略："><a href="#解决策略：" class="headerlink" title="解决策略："></a>解决策略：</h2><h3 id="死锁的避免与预防"><a href="#死锁的避免与预防" class="headerlink" title="死锁的避免与预防"></a>死锁的避免与预防</h3><p>死锁避免的基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁,则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。只要打破四个必要条件之一就能有效预防死锁的发生：</p>
<ol>
<li><p>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</p>
</li>
<li><p>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</p>
</li>
<li><p>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p>
</li>
<li><p>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</p>
</li>
<li><p>死锁预防和避免的区别</p>
</li>
</ol>
<ul>
<li>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。</li>
<li>死锁避免则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</li>
</ul>
<h3 id="死锁的检测和恢复"><a href="#死锁的检测和恢复" class="headerlink" title="死锁的检测和恢复"></a>死锁的检测和恢复</h3><ul>
<li>并没有实际卵用</li>
</ul>
<h3 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h3><ul>
<li><strong>核心思想：</strong> 装作没看见</li>
<li><strong>为什么会用鸵鸟算法？</strong><br>上面的一些做法，组织啊，恢复啊，无一例外会给系统带来很多沉重的负担。一方面给系统添加，另一方面解决的问题发生的概率不大，吃力还不讨好。而且，死锁发生的原因是由于程序设计人员写出来的问题，操作系统当然不会予以理会。所以死锁的问题都是交给程序设计人员来解决。</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端会话技术：Session</title>
    <url>/3004142873/</url>
    <content><![CDATA[<p>Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。他是用来解决Cookie带来的安全问题。</p>
<a id="more"></a>
<h2 id="一、Session概述"><a href="#一、Session概述" class="headerlink" title="一、Session概述"></a>一、Session概述</h2><ul>
<li>会话 ， Session是基于Cookie的一种会话机制。 </li>
<li>Cookie是服务器返回一小份数据给客户端。并且存放在客户端上。 </li>
<li>Session是，数据存放在服务器端。</li>
</ul>
<h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//得到会话ID</span><br><span class="line">String id = session.getId();</span><br><span class="line"></span><br><span class="line">//存值</span><br><span class="line">session.setAttribute(name, value);</span><br><span class="line">	</span><br><span class="line">//取值</span><br><span class="line">session.getAttribute(name);</span><br><span class="line">	</span><br><span class="line">//移除值</span><br><span class="line">session.removeAttribute(name);</span><br></pre></td></tr></table></figure>
<h2 id="三、Session的创建与销毁。"><a href="#三、Session的创建与销毁。" class="headerlink" title="三、Session的创建与销毁。"></a>三、Session的创建与销毁。</h2><ul>
<li>创建<br>如果有在servlet里面调用了 request.getSession()</li>
<li>销毁<br>session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。</li>
</ul>
<ol>
<li>关闭服务器</li>
<li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li>
</ol>
<h2 id="四、移除Session中的元素"><a href="#四、移除Session中的元素" class="headerlink" title="四、移除Session中的元素"></a>四、移除Session中的元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//强制干掉会话，里面存放的任何数据就都没有了。</span><br><span class="line">session.invalidate();</span><br><span class="line">	</span><br><span class="line">//从session中移除某一个数据</span><br><span class="line">session.removeAttribute(<span class="string">"cart"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>Session： 也是基于cookie的一种会话技术，  数据存放存放在服务器端。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。 </span><br><span class="line">setAttribute 存数据</span><br><span class="line">getAttribute 取数据</span><br><span class="line">removeAttribute  移除数据</span><br><span class="line">getSessionId();  获取会话id</span><br><span class="line">invalidate() 强制让会话失效。</span><br></pre></td></tr></table></figure>
<ul>
<li>创建和销毁<br>  调用<strong>request.getSesion</strong>创建<br>   服务器关闭 ， 会话超时（30分）</li>
</ul>
<ul>
<li>setAttribute 存放的值， 在浏览器关闭后，依然不会丢失！</li>
</ul>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币的两种交易方式</title>
    <url>/2670976354/</url>
    <content><![CDATA[<p>比特币的交易有很多种，本文了解一下</p>
<a id="more"></a>
<h2 id="比特币交易的几种种方式："><a href="#比特币交易的几种种方式：" class="headerlink" title="比特币交易的几种种方式："></a>比特币交易的几种种方式：</h2><p><img src="https://img-blog.csdnimg.cn/20200204170527575.png" alt="在这里插入图片描述"></p>
<ol>
<li><strong>场外交易：</strong> 也称为<strong>法币交易</strong>，法币就是<strong>法定货币</strong>，人民币就是我们国家的法定货币，顾名思义，法币交易就是由法币（人民币）直接与比特币（数字货币）进行交易的行为（购买/出售),可以简单理解为网购。</li>
<li><strong>场内交易：</strong> 也称之为<strong>币币交易</strong>，就是用一种币交易兑换另一种币。</li>
<li><strong>杠杆交易：</strong> 利用小额的资金来进行数倍于原始金额的投资。以期望获取相对投资标的物波动的数倍收益率，抑或亏损。由于保证金（该笔小额资金）的增减不以标的资产的波动比例来运动，<strong>风险很高</strong>。不推荐。</li>
<li><strong>合约交易：</strong> 合约交易是指交易双方，在交易所通过买卖合约，并根据约定在未来某一特定时间和地点，以特定价格买卖规定数量商品的行为。合约交易是在现货远期合约交易基础上发展起来的，在交易所内买卖标准化合约的一种新型交易方式。</li>
</ol>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ol>
<li>法币交易很耗时间，即使交易双方操作熟练，但是还是不排除人为因素造成交易时间拖长，不利于双方观察局势，很有可能在分分钟内错过行情。</li>
<li>币币交易可以在极短时间内成交（按下买入键的瞬间与对手成交）且支持购买的币种更多。</li>
</ol>
<p>，</p>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型---简单工厂模式</title>
    <url>/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个工厂类，它可以根据参数的不同，返回不同类的实例，被创建的实例通常都具有共同的父类。</p>
<a id="more"></a>

<h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul>
<li>工厂方法属于创建型模式，描述如何将对象的创建与使用相分离，目的在于让用户使用对象的同时，无需关心对象的创建细节，从而降低系统的耦合度，让设计方案易于修改和扩展。</li>
<li><strong>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</strong></li>
<li>由于<strong>简单工厂模式中</strong> 用于创建实例的方法是静态的，因此<strong>简单工厂模式</strong>又被称为<code>静态工厂模式</code></li>
<li>简单工厂模式的要点在于：<strong>用户需要什么时，只需要传入一个正确的参数，就可以获取所需要的对象，而无需知道创建细节。</strong></li>
</ul>
<h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul>
<li>工厂类</li>
<li>抽象产品类</li>
<li>具体产品类</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 开发一套图表库，可以向用户提供各种图标，例如柱状图（HistogramChart），饼状图（PieChart），折现图（LineChart），并且后期还可以根据需求添加别的图。<br>1.<strong>抽象产品类:</strong> <code>Chart</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>具体产品类：</strong> <code>HistogramChart</code>，<code>PieChart</code>，<code>LineChart</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistogramChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HistogramChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建柱状图"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"显示柱状图"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建饼状图"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"显示饼状图"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LineChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建折线图"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"显示折线图"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>工厂类：</strong> <code>ChartFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChartFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态工厂方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title">getChart</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		Chart chart=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"histogram"</span>)) &#123;</span><br><span class="line">			chart=<span class="keyword">new</span> HistogramChart();</span><br><span class="line">			System.out.println(<span class="string">"初始化设置柱状图！"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"pie"</span>))&#123;</span><br><span class="line">			chart=<span class="keyword">new</span> PieChart();</span><br><span class="line">			System.out.println(<span class="string">"初始化设置饼状图！"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"line"</span>))&#123;</span><br><span class="line">			chart=<span class="keyword">new</span> LineChart();</span><br><span class="line">			System.out.println(<span class="string">"初始化设置折线图！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> chart;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.<strong>测试类：</strong> <code>client</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.Chart;</span><br><span class="line"><span class="keyword">import</span> com.daq.factory.ChartFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Chart chart;</span><br><span class="line">		chart=ChartFactory.getChart(<span class="string">"pie"</span>);</span><br><span class="line">		chart.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试结果：</span><br><span class="line"></span><br><span class="line">创建饼状图</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>以上就是简单工厂模式的实现，当然也可以将静态工厂方法的参数存储在<code>XML</code>配置文件中，然后通过一个工具类<code>XMLUtil</code>来读取配置文件中的字符串参数。这样就可以实现不用修改源码就可以获取到相应的实例。</li>
<li>简单工厂模式也可以简化：将抽象产品类和工厂类合并，将静态工厂方法移动至抽象产品类中。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>①实现了对象创建和使用相分离<br>②通过引入配置文件，可以不用修改源码，只用修改配置文件，实现更换和增加新的具体产品类。</li>
<li>缺点<br>①工厂类集中了所有产品的创建逻辑，职责过重。一旦不能正常工作，整个系统都会出问题。<br>②会增加类的个数，增加系统的负担。<br>③不利于系统的扩展和维护。<br>④由于是使用静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑过于复杂。</li>
<li>客户端只知道传入工厂类的参数，对如何创建对象不关心。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---虚拟内存</title>
    <url>/1080640073/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是经常听到虚拟内存这个名词，尤其是在玩Linux的时候，其实不然，哪个是交换分区，跟虚拟内存还是有差别的。</p>
<a id="more"></a>
<ul>
<li><p>对一个程序来说，他在某一段时间内，只有某一些部分是需要在内存里面的。（局部性原理），虚拟内存管理，属于一个完全黑盒的封装，我们在使用的时候，几乎不需要考虑他的存在。</p>
</li>
<li><p>虚拟内存的两种实现方式：请求页，请求段。</p>
</li>
<li><p>请求页：如果有一个页面，只有当你真正需要他的时候，才把他加载到内存中来，有很多好处：降低IO操作，</p>
</li>
<li><p><strong>虚拟内存也是一种缓存思想</strong>：虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</p>
</li>
<li><p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘(较低层L5，参见我们上篇文章图4)的数据被分割成块(block)，这些块作为和主存(较高层,L4)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。</p>
</li>
<li><p>虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p>
</li>
<li><p>在任意时刻，虚拟页面都分为三个不相交的部分：<br>①<strong>未分配的(Unallocated)</strong> ：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。<br>②<strong>缓存的(Cached)</strong>： 当前已缓存在物理内存中的已分配页。<br>③<strong>未缓存的(UnCached)</strong> ：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</p>
</li>
</ul>
<h2 id="swap分区的作用"><a href="#swap分区的作用" class="headerlink" title="swap分区的作用"></a>swap分区的作用</h2><ul>
<li><p>linux有一个swap分区。Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间中的信息被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。系统总是在物理内存不够时，才进行Swap交换。</p>
</li>
<li><p>电脑开着一个进程，几天不关机，也一直没关闭这个进程，随着运行的程序越来越多，内存快不够用了，所以操作系统就选择将这个音乐播放器的内存状态(包括堆栈状态等)都写到磁盘上的swap区进行保存。这样就腾出来一部分内存供其他需要运行的程序使用。等你要使用到这个进程了。此时， 系统会从磁盘中的swap区重新读取该进程的相关信息，送回内存接着运行。</p>
</li>
</ul>
<h2 id="补充注意"><a href="#补充注意" class="headerlink" title="补充注意"></a>补充注意</h2><p><strong>在window下也有类作用的硬盘空间，属于对用户不可见的匿名磁盘空间(在C盘)。</strong></p>
<p>特别注意：按照字面意思，swap交换区也可以称为虚拟内存<br>硬盘上的swap交换区，其实就相当于承担了内存的作用(只是速度很慢罢了)。swap交换区起到了扩大内存的作用。所以从某些意义上来讲，swap区也可以叫做虚拟内存，但是这个虚拟内存是字面意思。和我们本文当中站在计算机系统的角度来解释的虚拟内存不是一个概念。所以特别注意这一点。因为有些人理解的虚拟内存，就是swap交互区。此虚拟内存非彼虚拟内存，所以明白各自的概念和作用。</p>
<p><strong>linux环境下叫做swap分区，window下这块区域不叫swap分区，就直接按照字面意思叫做”虚拟内存”了。所以两个含义不同的虚拟内存</strong></p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>股票基本术语</title>
    <url>/undefined/</url>
    <content><![CDATA[<p>股票基本术语了解。</p>
<a id="more"></a>
<h1 id="A-B-H-蓝筹股-amp-债券-amp-基金"><a href="#A-B-H-蓝筹股-amp-债券-amp-基金" class="headerlink" title="A/B/H/蓝筹股&amp;债券&amp;基金"></a>A/B/H/蓝筹股&amp;债券&amp;基金</h1><ul>
<li><strong>A股：</strong> 人民币普通股票，由我国境内的公司发行，供境内机构、组织、或个人(不含台、港、澳投资者)以人民币认购和交易的普通股票。</li>
<li><strong>B股：</strong> 人民币特种股票，以人民币标明面值，<strong>以外币认购和买卖</strong>，在境内(上海、深圳)证券交易所上市交易的。B股公司的注册地和上市地都在境内。</li>
<li><strong>H股：</strong> 港股：即注册地在内地、上市地在香港的<strong>外资股。</strong> 在香港上市外资股就叫做H股，纽约和新加坡上市的股票分别叫做N股和S股。</li>
<li><strong>蓝筹股：</strong> 多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码（蓝，红，白）、其中蓝色筹码最为值钱。</li>
<li><strong>债券：</strong> 政府、企业、银行等债务人为筹集资金,按照法定程序发行并向债权人承诺于指定日期还本付息的有价证券。</li>
<li><strong>开放式基金：</strong>（Open-end Funds）又称共同基金,是指基金发起人在设立基金时，基金单位或者股份总规模不固定，可视投资者的需求，随时向投资者出售基金单位或者股份，并可以应投资者的要求赎回发行在外的基金单位或者股份的一种基金运作方式。投资者既可以通过基金销售机构买基金使得基金资产和规模由此相应的增加，也可以将所持有的基金份额卖给基金并收回现金使得基金资产和规模相应的减少。</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li><p><strong>原始股：</strong> 是公司在上市之前发行的股票。在中国股市初期，在股票一级市场上以发行价向社会公开发行的企业股票。</p>
</li>
<li><p><strong>概念股：</strong> 是指具有某种特别内涵的股票，与业绩股相对而言的。业绩股需要有良好的业绩支撑。而概念股是依靠某一种题材比如资产重组概念，三通概念等支撑价格。而这一内涵通常会被当作一种选股和炒作题材，成为股市的热点。概念股是股市术语，作为一种选股的方式。相较于绩优股必须有良好的营运业绩所支撑，概念股只是以依靠相同话题，将同类型的股票列入选股标的的一种组合。由于概念股的广告效应，因此不具有任何获利的保证。</p>
</li>
<li><p><strong>权重股：</strong>（weighted stock）就是总股本巨大的上市公司股票，它的股票总数占股票市场股票总数的比重很大，权重就很大，权重股的涨跌对股票指数的影响很大。</p>
</li>
<li><p><strong>借壳上市：</strong> 是指一家私人公司（Private Company）通过把资产注入一家市值较低的已上市公司（壳，Shell），得到该公司一定程度的控股权，利用其上市公司地位，使母公司的资产得以上市。通常该壳公司会被改名。</p>
</li>
<li><p><strong>交易时间：</strong> 大多数股票的交易时间是四小时，分两个时段：周一至周五上午9：30-11：30和下午13：00至15：00</p>
</li>
<li><p><strong>交易费用：</strong> 股票的交易费用通常包括印花税，佣金，过户费，其他费用等。</p>
</li>
<li><p><strong>总市值:</strong> 是指在某特定时间内总股本数乘以当时股价得出的股票总价值。</p>
</li>
<li><p><strong>流通市值:</strong> 在某特定时间内当时可交易的流通股股数乘以当时股价得出的流通股票总价值。</p>
</li>
<li><p><strong>总股本：</strong> 包括新股发行前的股份和新发行的股份的数量的总和。</p>
</li>
<li><p><strong>市盈率：</strong> 由股价除以年度每股盈余(EPS)得出(以公司市值除以年度股东应占溢利亦可得出相同结果)。用来<strong>评估股价水平是否合理</strong>的指标之一。</p>
</li>
<li><p><strong>市净率：</strong> 每股股价与每股净资产的比率。市净率可用于<strong>投资分析</strong>，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低。</p>
</li>
<li><p><strong>基准日：</strong> 就是因股票分红或配股，而进行股价调整的那天。相应的，在这天，红利和红股会配到投资者帐号里。而在基准日前，还有股权登记日。在股权登记日前买入该股票的投资者，享有分红或配股的权利。红利和红股会在基准日打到帐号里。</p>
</li>
<li><p><strong>大盘：</strong> 指沪市的“上证综合指数”和深市的“深证成份股指数”的股票。大盘指数是运用统计学中的指数方法编制而成的，反映股市<strong>总体价格</strong>或<strong>某类股价</strong>变动和走势的指标。</p>
</li>
<li><p><strong>个股：</strong> 是一种无偿还期限的有价证券，按股票持有者可分为国家股、法人股、个人股三种。个人股（individual stock）投资资金来自个人，可以自由上市流通。</p>
</li>
<li><p><strong>涨跌幅</strong>=(现价-上一个交易日收盘价）/上一个交易日收盘价*100%</p>
</li>
<li><p><strong>委差</strong> = 委买手数－委卖手数。</p>
</li>
<li><p><strong>委比</strong> = (委买手数-委卖手数)/(委买手数+委卖手数)×100%</p>
</li>
<li><p><strong>换手率：</strong> 也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。成交量/股票总流通量×100%</p>
</li>
<li><p><strong>成交额：</strong> 某只股票在一定时间内成交的股票总金额。</p>
</li>
<li><p><strong>平均成交量：</strong> 每笔交易的平均成交量，成交量/成交笔数。</p>
</li>
<li><p><strong>成交量：</strong> 包括某只股票 当天的成交股数、成交金额、换手率；狭义的也是最常用的是仅指成交股数/手数(1手=100股)；通常人们说的大盘成交量指的是成交金额。</p>
</li>
<li><p><strong>仓位：</strong> 是指投资者买入股票所耗资金占资金总量的比例。当一个投资者的所有资金都已买入股票时就称为<strong>满仓</strong>，若不持有任何股票就称为<strong>空仓</strong>。</p>
</li>
</ul>
<h1 id="股票操作术语"><a href="#股票操作术语" class="headerlink" title="股票操作术语"></a>股票操作术语</h1><h2 id="内盘-amp-外盘"><a href="#内盘-amp-外盘" class="headerlink" title="内盘&amp;外盘"></a>内盘&amp;外盘</h2><ul>
<li>内盘（S）：以买入价成交的交易，成交数量统计后加入内盘。</li>
<li>外盘（B）：以卖出价成交的交易。成交数量统计后加入外盘。</li>
<li>内盘，外盘这两个数据大体可以<strong>用来判断买卖力量的强弱</strong>。若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。</li>
</ul>
<h2 id="洗盘-amp-盯盘"><a href="#洗盘-amp-盯盘" class="headerlink" title="洗盘&amp;盯盘"></a>洗盘&amp;盯盘</h2><ul>
<li>洗盘：投机者先把股价大幅度杀低，使大批小额股票投资者(<strong>散户</strong>)产生恐慌而抛售股票，然后再把股价抬高，以便乘机渔利。</li>
<li>盯盘：俗称看盘，是股票投资者主要的日常工作。股票市场每时每刻都在变化，股票投资者尤其是短期投资者要掌握股票市场的动向，就要观察分析股市行情的变化，即要学会盯盘。</li>
</ul>
<h2 id="做多-amp-做空"><a href="#做多-amp-做空" class="headerlink" title="做多&amp;做空"></a>做多&amp;做空</h2><ul>
<li><strong>做多：</strong> 指的是多仓，也可以叫利多，买入某种货币，看涨。</li>
<li><strong>做空：</strong> 指的是卖仓，也可以叫利空，卖出某种货币，看跌。</li>
</ul>
<h2 id="多头-amp-空头"><a href="#多头-amp-空头" class="headerlink" title="多头&amp;空头"></a>多头&amp;空头</h2><ul>
<li><strong>多头：</strong> 指投资者对股市看好，预计股价将会看涨，于是趁低价时买进股票，待股票上涨至某一价位时再卖出，以获取差额收益。</li>
<li><strong>空头：</strong> 空头是投资者和股票商认为现时股价虽然较高，但对股市前景看坏，预计股价将会下跌，于是把借来的股票或者是原有持仓及时卖出（<strong>补空</strong>），待股价跌至某一价位时再买进，以获取差额收益。</li>
</ul>
<h2 id="涨停-amp-跌停"><a href="#涨停-amp-跌停" class="headerlink" title="涨停&amp;跌停"></a>涨停&amp;跌停</h2><ul>
<li>涨跌停板：是证券管理部门为了<strong>防止过度的投机</strong>而采取的一种措施，是指一只个股每天的最大涨跌幅度不能超过前一交易日的百分比。普通的股票最大涨跌幅为前一交易日的10%。<strong>新股上市首日不设涨跌幅限制</strong>。</li>
</ul>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p> 熔断机制（Circuit Breaker），也叫自动停盘机制，是指当股指波幅达到某设定条件（熔断点）时，交易所为控制风险采取的暂停交易措施，<strong>不同于涨跌停板</strong>；例如，新股上市首日的规定：</p>
<ul>
<li>深交所：新股首日盘中成交价较开盘价首次上涨或下跌达到或超过10%即暂停交易，新股首日换手率超50%触发暂停交易。</li>
<li>上交所：新股首日盘中成交价较开盘价首次上涨或下跌达到10%暂停交易30分钟。达到20%，停牌到14时55分，首日换手率超80%触发暂停交易。</li>
</ul>
<h2 id="回档-amp-反弹"><a href="#回档-amp-反弹" class="headerlink" title="回档&amp;反弹"></a>回档&amp;反弹</h2><ul>
<li>回档：股价呈不断上涨趋势，终因股价上涨速度过快而反转回跌到某一价位，这一调整现象称为回档。一般来说，股票的回档幅度要比上涨幅度小，通常是反转回跌到前一次上涨幅度的三分之一左右时又恢复原来上涨趋势。</li>
<li>反弹：股价呈不断下跌趋势，终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。一般来说，股票的反弹幅度要比下跌幅度小，通常是反弹到前一次下跌幅度的三分之一左右时，又恢复原来的下跌趋势。</li>
</ul>
<h2 id="跳空-amp-补空"><a href="#跳空-amp-补空" class="headerlink" title="跳空&amp;补空"></a>跳空&amp;补空</h2><ul>
<li>跳空：指受强烈利多或利空消息刺激，股价开始大幅度跳动。跳空通常在股价大变动的开始或结束前出现。</li>
<li>补空：是空头买回以前卖出的股票的行为。</li>
</ul>
<h2 id="阻力线-amp-支撑线"><a href="#阻力线-amp-支撑线" class="headerlink" title="阻力线&amp;支撑线"></a>阻力线&amp;支撑线</h2><ul>
<li>阻力线：股市受利多信息的影响，股价上涨至某一价格时，做多头的认为有利可图，但实际却有大量卖出，使股价至此停止上升，甚至出现回跌。股市上一般将这种遇到阻力时的价位称为关卡，股价上升时的关卡称为阻力线。<strong>（大量卖出抑制了价格继续攀升）</strong></li>
<li>支撑线：股市受利空信息的影响，股价跌至某一价位时，做空头的认为有利可图，大量买进股票，使股价不再下跌，甚至出现回升趋势。股价下跌时的关卡称为支撑线。<strong>（大量买入支撑起股价，由跌转升）</strong></li>
</ul>
<h2 id="金叉-amp-死叉"><a href="#金叉-amp-死叉" class="headerlink" title="金叉&amp;死叉"></a>金叉&amp;死叉</h2><ul>
<li>黄金交叉：指短期移动平均线向上穿过中期移动平均线或短期、中期移动平均线同时向上穿过长期移动平均线的走势图形，表示股价将继续上升。</li>
<li>死亡交叉(死叉)：指下降中的短期移动平均线由上而下穿过下降的长期移动平均线，这个时候支撑线被向下跌破，表示股价将继续下落。<br><img src="https://img-blog.csdnimg.cn/20200206150617607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ul>
<li>在股票名称前冠以“ST”的股票表示该上市公司最近两年连续亏损，或亏损一年，但净资产跌破面值、公司经营过程中出现重大违法行为等情况之一，交易所对该公司股票交易进行特别处理。股票交易日涨跌幅限制5%。</li>
<li><strong>F10：</strong> 股票非行情类的基本面资料统称为股票F10。在各种金融行情终端软件中，用户通过键盘上的F10快捷键，可迅速查看上市公司的非行情信息，诸如：公司概况、财务数据、公司公告、公司新闻、经营分析等等信息数据。</li>
</ul>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>火币网--币币交易图解</title>
    <url>/undefined/</url>
    <content><![CDATA[<p>如何在火币网上执行币币交易</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200205111557755.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>BTC/USDT：BTC对USDT的交易对，相当于平均1个BTC当前需要9211.76个USDT来购买，后面的64574.43CNY是说9211.76个USDT约等于64574.43人民币。</p>
</li>
<li><p>涨幅+0.01%是今天此时此刻比特币的价格相对于昨天的这个时候价格涨了0.01%，如果是红色的-0.01%就代表跌了0.01%。</p>
</li>
<li><p>高9320.00 低9100.00是<strong>过去24小时</strong>最高9320.00USDT最低9100.00USDT。</p>
</li>
<li><p>24H量：是过去24小时火币网交易了28878个比特币。这只是在火币网交易的数量。<br><img src="https://img-blog.csdnimg.cn/2020020511252911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>上面一排时间是，选择显示这个时间段的数据，比如我选择的是1min，那么k线图中每一个红色或者绿色的柱就代表这一分钟内的走势。</p>
</li>
<li><p>时间下面的一排：11：24这个时间点的开盘价，最高价，最低价，收盘价，成交量。</p>
</li>
<li><p>MA均线：<strong>（MA）理论是股市最常见的一种技术分析方法，它对股市操作具有神奇的指导作用。</strong></p>
</li>
<li><p>绿色柱状：柱底代表开盘价，柱顶代表收盘价，红色则相反。</p>
</li>
<li><p>柱上下的细线：上影线，下影线，分别代表在这一分钟内的最高价和最低价。</p>
</li>
<li><p>图中标有今日最高，和今日最低。严谨理解为：从今日凌晨到目前为止的最高价与最低价。</p>
<h2 id="均线分析方法："><a href="#均线分析方法：" class="headerlink" title="均线分析方法："></a>均线分析方法：</h2></li>
</ul>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>认识web服务器&amp;Eclipse配置部署Tomcat</title>
    <url>/629938038/</url>
    <content><![CDATA[<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、IIS。</p>
<a id="more"></a>
<h2 id="一、程序架构"><a href="#一、程序架构" class="headerlink" title="一、程序架构"></a>一、程序架构</h2><ul>
<li>C /  S (client / server)<br>如：QQ  微信   LOL<br>优点：有一部分代码写在客户端，用户体验比较好。<br>缺点：占用资源大，比较吃硬盘，服务器更新，客户端也要随之更新。</li>
<li>B / S (browser / server)<br>如：网页QQ，  网页游戏。<br>优点：客户端只要浏览器就可以了，占用资源小，不用更新。<br>缺点：用户体验不佳。</li>
</ul>
<h2 id="二、web服务器"><a href="#二、web服务器" class="headerlink" title="二、web服务器"></a>二、web服务器</h2><ul>
<li><strong>服务器：其实服务器就是一台电脑。 配置比一般的要好。</strong></li>
<li>Web服务器软件 ：客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。 </li>
</ul>
<ul>
<li>处理客户端的请求， 返回资源 | 信息</li>
</ul>
<ul>
<li>Web应用  需要服务器支撑。 index.html</li>
</ul>
<ul>
<li>常用web服务器：<br> Tomcat  —–apache 免费<br> WebLogic —–BEA  收费<br> Websphere —–IBM 收费<br> IIS   —–微软<h2 id="三、安装tomcat"><a href="#三、安装tomcat" class="headerlink" title="三、安装tomcat"></a>三、安装tomcat</h2></li>
<li>直接解压 ，然后找到bin/startup.bat</li>
<li>安装启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： <a href="http://localhost:8080">http://localhost:8080</a> , 如果有看到内容 就表明成功了。在黑窗口开着的同时输入网址。</li>
<li>出现控制台乱码问题，右键控制台，查看是GBK，还是UTF-8。然后在安装目录中找到conf–logging.properties文件，修改里面的编码方式，保持一致即可。</li>
<li>如果双击了startup.bat,  看到一闪而过的情形，一般都是 JDK的环境变量没有配置。<h2 id="四、Tomcat目录介绍"><a href="#四、Tomcat目录介绍" class="headerlink" title="四、Tomcat目录介绍"></a>四、Tomcat目录介绍</h2></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200225115238417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>bin： 包含了一些jar ,  bat文件 。  startup.bat。</p>
</li>
<li><p>conf：tomcat的配置   server.xml ，  web.xml。</p>
</li>
<li><p>lib：tomcat运行所需的jar文件。</p>
</li>
<li><p>logs：运行的日志文件。</p>
</li>
<li><p>temp：临时文件。</p>
</li>
<li><p>webapps：发布到tomcat服务器上的项目，就存放在这个目录。</p>
</li>
<li><p>work：jsp翻译成class文件存放地。</p>
</li>
</ul>
<h2 id="五、Eclipse配置Tomcat"><a href="#五、Eclipse配置Tomcat" class="headerlink" title="五、Eclipse配置Tomcat"></a>五、Eclipse配置Tomcat</h2><ol>
<li>Java EE 的视图下，在server里面，右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。</li>
<li>配置完毕后， 在server 里面， 右键刚才的服务器，然后open  ， 找到上面的Server Location , 选择中间的 Use Tomcat installation…</li>
<li>创建web工程， 在WebContent下新建html文件， 右击工程， run as server<br><img src="https://img-blog.csdnimg.cn/20200225140218529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>至此成功！！！</li>
</ol>
]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币的价格是怎么算出来的</title>
    <url>/2526071924/</url>
    <content><![CDATA[<p>-</p>
<a id="more"></a>
<h2 id="首先了解一下拍卖"><a href="#首先了解一下拍卖" class="headerlink" title="首先了解一下拍卖"></a>首先了解一下拍卖</h2><ul>
<li><strong>英式拍卖：</strong> 如果拍卖方（卖方）要卖一个商品，那么买方则通过集体竞价的方式进行拍卖，价高者得，最后和卖方成交的一定只有一个买家，而这个买家一定是出价最高的那位。</li>
<li><strong>荷兰式拍卖：</strong> 假如有一个买家想要买一个商品，但是卖方有很多，那么卖方递减报出新的价位，最终和买方成交的一定是卖价最低的那位。</li>
</ul>
<h2 id="实际定价方式"><a href="#实际定价方式" class="headerlink" title="实际定价方式"></a>实际定价方式</h2><p>在交易所看到的一排排红色的数字和一排排绿色的数字其实就是许多的买方和许多的卖方不断报出的<strong>买进价</strong>和<strong>卖出价</strong>，价格随供求变化而不断变动。买者和卖者彼此竞争，<strong>双向拍卖</strong>，买者对想要买进的出价，通过竞争以最低价买入;卖者也互相竞争，试图以最高价格出售，然而最新成交价一定是买卖双方达成一致的那个价格。买卖双方不断成交，最新一笔的成交价就是我们看到的不断变化的价格，这就是为什么价格在一直变化的原因。报价后面的数量，即代表当前的买方或者卖方想要购买或者卖出的币的数量。买卖一旦成交，则不得反悔。在未成交以前，也可以撤单，撤单程序与买卖委托的过程基本相同。</p>
<h2 id="限价，市价，止盈止损"><a href="#限价，市价，止盈止损" class="headerlink" title="限价，市价，止盈止损"></a>限价，市价，止盈止损</h2><ul>
<li>限价：是<strong>自己设定</strong>价格进行挂单，需价格波动到设定价格并有对手愿意交易才可以成交。</li>
<li>市价：市价是以<strong>当前最新</strong>成交价挂单，一般马上成交。</li>
<li>止盈止损：止盈止损即是<strong>带有预期</strong>的未来买入或者卖出行为，比如当价格跌破某一价位时进行止损（你预期跌破此价格可能还会继续跌），或者当价格突破某一价位时进行买入（你预期价格一旦突破该价位时将会继续上涨）。</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你是买方，想要<strong>尽快</strong>购入比特币，当然是设置买入价格与当前最低卖出价格一致，这样双方就可以达成交易了，想要尽快卖出比特币，那就设置卖出价格与当前最高买入价格一致。但是市场上的人并不是都急切的想要卖出或者买入，会带有预期的进行买入卖出报价。</p>
]]></content>
      <categories>
        <category>区块链+比特币</category>
      </categories>
      <tags>
        <tag>区块链，比特币</tag>
      </tags>
  </entry>
  <entry>
    <title>建站系列之---网站安全配置</title>
    <url>/hexo/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建站并没有那么容易，搭建起来之后，还要考虑各种问题，例如网站安全，加载速度，资源压缩，用户体验之类的，虽然只是一个静态网站，但是能够做好一点也是挺不错的。</p>
<a id="more"></a>


<h2 id="一、添加备案号"><a href="#一、添加备案号" class="headerlink" title="一、添加备案号"></a>一、添加备案号</h2><ul>
<li>我是在阿里云APP上备案成功的，等的时间也不长，六天左右，最后短信收到了工信局发来的备案号，需要把这个备案号添加在网站底部，并且指向工信局官网。</li>
<li>找到<code>F:\blog\themes\next\layout\_partials</code>下的<code>footer.swig</code>文件，添加如下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.beian.miit.gov.cn/"</span>&gt;备案号&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200321110819179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="二、安装SSL证书"><a href="#二、安装SSL证书" class="headerlink" title="二、安装SSL证书"></a>二、安装SSL证书</h2><p>① <strong>购买证书：</strong> 阿里云提供的免费证书服务，购买页面：<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.2.15a156a7lzZrki&commodityCode=cas#/buy">阿里云ssl证书购买</a>选择免费的。足够个人博客用了。购买好了之后，按步骤申请验证</p>
<p><img src="https://img-blog.csdnimg.cn/20200321184319504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>②  <strong>下载证书：</strong> 进入阿里云证书控制台，选择下载证书<code>for nginx</code> ，下载好之后可以看到有两个文件夹，分别是：<code>.key</code>和<code>.pem</code>文件。</p>
<p><img src="https://img-blog.csdnimg.cn/20200321184329138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>③<strong>安装证书：</strong></p>
<ul>
<li><p>服务器放置证书：创建目录:  <code>/etc/nginx/cert</code>,用于存放证书文件。我用的软件是<code>finalshell</code>。<br><img src="https://img-blog.csdnimg.cn/20200321185907359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>修改<code>nginx</code>配置，在<code>/etc/nginx/nginx.conf</code>在里面添加443端口，443端口用于https协议。不建议直接修改<code>nginx.conf</code>,可以在<code>nginx</code>目录下新建一个文件夹<code>vhost</code>，里面用来编写新加的修改，在<code>vhost</code>中新建<code>SSL.conf</code>写入以下内容：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name staunchkai.com;     <span class="comment"># 填写绑定证书的域名</span></span><br><span class="line">    ssl_certificate /home/SSL/1_bundle.crt;<span class="comment">#这里填写你.pem文件的路径。</span></span><br><span class="line">    ssl_certificate_key /home/SSL/2_key.key;<span class="comment">#这里填写.key文件的路径。</span></span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    <span class="comment"># 按照这个协议配置</span></span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;     <span class="comment"># 按照这个套件配置</span></span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /home/www/blog;    <span class="comment"># 站点目录</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后用一句代码将<code>SSL.conf</code>链入到<code>nginx.conf</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/vhost/*.conf;</span><br></pre></td></tr></table></figure>
<p>这里的vhost是我自己创建的用来存放修改的参数，这句话的意思就是，将vhost中所有的配置文件加入进来。所以我的修改，一般都是在这个文件里面添加之后再链入。</p>
<p><img src="https://img-blog.csdnimg.cn/20200321193156899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>如果用户使用<code>http协议</code>访问网站，要进行301跳转，以https协议访问，所以要修改原有端口80的监听位置。我是采用链入的方法。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200321194946704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">return</span> 301 https://daqwt.top<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置完成后，使用 <code>nginx -t</code> 命令检测是否有误，正确无误后，使用 <code>systemctl restart nginx.service</code> 重启 Nignx。再使用带 https 的域名进行访问即可。</li>
</ul>
<h2 id="三、站点地图"><a href="#三、站点地图" class="headerlink" title="三、站点地图"></a>三、站点地图</h2><ul>
<li>站点地图是一种文件，可以通过该文件列出您网站上的网页，从而将网站组织内容，高速其他浏览器。以便更加智能的抓取您的网站。</li>
<li>安装插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-sitemap --save</span><br><span class="line">cnpm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<ul>
<li>在站点配置文件中添加以下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自动生成sitemap</span></span><br><span class="line">sitemap: </span><br><span class="line">    path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<ul>
<li>编译博客</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在<code>public</code>文件夹下发现了<code>sitemap.xml</code>就代表成功了。</li>
</ul>
<h2 id="四、谷歌收录"><a href="#四、谷歌收录" class="headerlink" title="四、谷歌收录"></a>四、谷歌收录</h2><ul>
<li>注册<a href="https://search.google.com/search-console">google站长工具</a></li>
<li>验证通过后，点击抓取–&gt;站点地图–&gt;添加新的站点题图–&gt;填入<code>https://daqwt.top/sitemap.xml</code>,很快谷歌就会收录。</li>
</ul>
<h2 id="五、百度收录"><a href="#五、百度收录" class="headerlink" title="五、百度收录"></a>五、百度收录</h2><ul>
<li>注册<a href="https://ziyuan.baidu.com/">百度站长统计</a></li>
<li>登录之后，找到用户中心，添加站点，按照提示完成验证，推荐使用<code>CNAME</code>验证。</li>
<li>完成之后进入站点管理，找到网页抓取的<code>链接提交图</code>，点击详情</li>
</ul>
]]></content>
      <categories>
        <category>Hexo建站系列</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---进程管理</title>
    <url>/853277148/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程，也就是任务，这里有必要说一下进程和线程的区别：进程是资源分配的最小单位，线程是程序执行的最小单位，通俗来讲，一个爹可以有很多儿子，但儿子之后一个爹，并且还遗传这个爹，爹能做大事，而儿子，做一些杂七杂八的给爹打下手，你细细品。这篇文章主要讲进程管理的策略。</p>
<a id="more"></a>

<h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ul>
<li>进程：打开任务管理器，里面正在执行的任务，一个程序运行起来了，它就是一个进程。</li>
<li><code>jobs</code>是最早的进程原型，也就是单道批处理系统，cpu一次只运行一个程序，其他的程序要事先放在内存中，等待上一个程序执行完了，他再去执行。</li>
<li>后来出现了分时操作系统，大家轮着执行。使用cpu，称之为任务。</li>
</ul>
<h2 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h2><p><img src="https://img-blog.csdnimg.cn/20200319160008644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>程序计数器（pc）和各种寄存器</li>
<li>数据段</li>
<li>代码段</li>
<li>栈</li>
<li>堆</li>
<li>栈内存，堆内存慢慢增长，到一定程度，会导致内存不足的情况。</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>操作系统就是通过切换进程的状态，达到进程控制的目的。也实现了很多进程同时运行，周而复始。有条不紊</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200319161707691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>new（新建）</li>
<li>ready（就绪态）：一个进程是完全可以运行的，万事俱备，只差cpu。</li>
<li>running（运行态）：拥有cpu的进程，一个cpu上只能运行一个进程，什么时候它会把cpu交出去？<br>①中断interrupt：她本可以继续运行下去的，但是操作系统觉得它运行的太久了。或者是有更重要的要做，所以就把他给中断了，打回到就绪态。<br>②主动让出cpu：这个进程要去做一个io操作，或者是等待一个事件（等不到这个指令，他就不知道要做什么），这个时候就会让出cpu。进入就绪状态。</li>
<li>waiting（等待态）：被唤醒（有响应了，知道自己该做什么了）之后进入就绪态。</li>
<li>terminated（结束）</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><ul>
<li>进程控制块PCB（Process Control  Block）是一个结构体，通过它来控制进程。每个进程都有一个PCB。通过PCB能找到这个进程的位置，状态，信息。</li>
<li>进程1切换的时候，将这个进程的所有信息保存到PCB寄存器中，以保证下次在运行的时候，就是上次停止的状态。</li>
<li>如何挑选下一个进程来执行呢，这就涉及到内核的调度算法了。</li>
<li>所有的PCB结构体，在一起构成了一个队列。</li>
<li>进程是在不同的队列之间，来回迁移。例如：就绪队列，I/O等待队列。</li>
<li>用一个大数组来装所有的PCB结构体，用一个指针来指向PCB数组中的这个进程。</li>
<li>软件做不了的事，硬件可以做。</li>
</ul>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><ul>
<li>一开机就会发现有进程，这些都是系统级的进程 ，如shell，资源管理器，一些应用程序设置的开机自启动就是通过shell来启动的，相当于捆绑销售一样 。</li>
<li>打开应用程序，双击，这个命令给了资源管理器，或者命令行下，是把指令给了shell</li>
<li>父进程与子进程</li>
<li>unix创建进程：fork（）生成一个子进程 </li>
<li>top 命令，监视现在所有进程的状态，每隔一秒种刷新一次。</li>
<li>windows创建进程：create process </li>
<li>msdn—微软的百科全书。 </li>
<li>杀死进程：kill</li>
</ul>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>多进程模式模块化</p>
<ul>
<li><strong>消息传递（Mwssage passing）</strong> ：A进程把消息从自己的内存空间复制一份到内核中，然后内核再把消息复制一份给进程B。用系统调用进行信息传递。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200319194014153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>共享内存（Shared memory）：</strong> 每个进程都有自己独立的地址空间，但是两个进程，甚至更多的进程通过协商（也是系统调用来协商）划分出来一块儿共享内存。在每个进程的地址空间都有。A在这块儿空间里一写数据，B马上就可以读取到。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200319194244682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>共享内存在协商的时候，要经过一系列的系统调用。而且还要约定好，过程很麻烦。如果进程之间共享内存，就要负责任，实现同步，不要同时写在同一个地方。</li>
<li><strong>消息传递</strong> 很方便。经常用到。分为两种：<br>①阻塞型：（更好用）<br>当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么你当前这个进程就会被挂起，被放到等待状态，被阻塞。<br>②非阻塞型：（考虑的比较多 ）<br>当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么这个请求会在后台去操作，同时这个系统调用会返回，空闲时候会回到你的进程，这个系统调用的返回值会告诉你，这个操作没有完成，进程根据这个返回值来判断是否完成操作，并做其他操作。</li>
</ul>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><ul>
<li>父进程会把所有的信息复制一份给子进程，自此变成两个独立的进程，互相不影响。</li>
<li>以我们的角度来看，这样的子进程，父进程是不是太浪费内存了，但是，操作系统只是表面上让你看到它是把父进程复制给了子进程，但其实，他可以做到父进程和子进程之间完全相同的部分之间共享内存。所以大可不必担心这个问题。</li>
<li>多进程编程最重要的一个特性，也是我们首先要了解到的，独立性，直观上来看，他们两个进程之间互相不干扰。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li><p>进程的特点是分离，而线程就是不分离。 互相协作的关系</p>
</li>
<li><p>线程有： 线程ID，PC寄存器，栈 。。。 </p>
</li>
<li><p>引入进程的目的就是让一个进程里面同时有多条执行路线，同时发挥作用。</p>
</li>
<li><p>多线程优点：<br>①快速的响应能力：有比较耗时的操作是，创建线程去做，主线程用来和用户 交互。<br>②资源共享：协作更方便，数据传递更方便<br>③经济实惠：线程更加节约资源。 </p>
</li>
<li><p>用户级线程：<br>①优点：效率高，可定制性好，。<br>②缺点：用户线程中任何一个线程，如果调用了阻塞性的系统调用，那么所有用户线程就全被阻塞。因为在操作系统看来，这么这个线程就是同一个线程，就会被阻塞掉。用户线程不能在多个处理器上并行运行。</p>
</li>
<li><p>内核级线程：操作系统提供的线程。</p>
</li>
<li><p>线程池：先创建多少个线程，要用的时候 就去拿，但是也有缺点。 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统---文件系统</title>
    <url>/2892727560/</url>
    <content><![CDATA[<p>正在更新中。。。。</p>
<a id="more"></a>
<h1 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h1><ul>
<li><p>常见的文件系统有：：FAT、NTFS、ExtFAT、ext2、ext3、reiserFS、VFAT、APFS</p>
</li>
<li><p><strong>FAT:</strong> FAt12、FAT16、FAT32均是Fat文件系统，最初是为软盘设计的文件系统，但是后来随着微软推出dos和win 9x系统，FAT文件系统经过适配被逐渐用到了硬盘上。</p>
</li>
<li><p><strong>NTFS：</strong> 对FAT和HPFS作了若干改进，例如，支持元数据，并且使用了高级数据结构，以便于改善性能、可靠性和磁盘空间利用率，并提供了若干附加扩展功能。NTFS是一个<strong>日志文件系统</strong>，这意味着除了向磁盘中写入信息，该文件系统还会为所发生的所有改变保留一份日志。这一功能让NTFS文件系统在发生错误的时候（比如系统崩溃或电源供应中断）更容易恢复，也让这一系统更加强壮。在这些情况下，NTFS能够很快恢复正常，而且不会丢失任何数据。在很少出错情况下，微软表示你需要运行CHKDSK修复程序来对磁盘卷进行维护的概率特别低，其概率不到1%。</p>
</li>
<li><p><strong>ExFAT：</strong> 也是微软开发的文件系统，它是专门为闪存盘设计的文件系统，单个文件突破了4G的限制，而且分区的最大容量可达64ZB，建议512TB。 ExFAT在windows，Linux以及Mac系统上，都可以读写，<strong>作为U盘或者是移动硬盘的格式还是比较合适的。</strong></p>
</li>
</ul>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><strong>EFI 系统分区：</strong> 通常指数据存储介质中的一个分区，通常用于硬盘或固态硬盘。它通常应用于 Unified Extensible Firmware Interface (UEFI)。当电脑通电启动时，UEFI会读取ESP 用来安装操作系统和各种实用工具。ESP需要格式化成FAT文件系统并且挂载至UEFI指定的位置。<br><strong>UEFI：</strong> <strong>统一可扩展固件接口</strong>（Unified Extensible Firmware Interface）是一种个人<strong>电脑系统规格</strong>，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个设计模式都符合某一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一，通过在软件开发中使用这些原则，可以提高软件的可维护性和可复用性，以便设计出兼具良好的软件系统，实现可维护性服用的目标。</p>
<h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul>
<li>单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小。</li>
<li><strong>定义：</strong> 一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。它是高内聚低耦合的指导方针 。</li>
</ul>
<h2 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
<h2 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h2><p>任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><p>这个是开闭原则的基础，<strong>针对接口编程，依赖于抽象而不依赖于具体</strong>。</p>
<h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>使用多个隔离的接口，比使用单个接口要好。旨在降低类之间的耦合度，<strong>由此可以看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。需要降低依赖，降低耦合。</strong></p>
<h2 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h2><p>简单来讲：个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也是解耦的一部分思想。</p>
<h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p>原则是<strong>尽量使用合成/聚合的方式，而不是使用继承。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
