<!DOCTYPE html>
<script src="js/clicklove.js"></script>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>HashMap源码分析 - DAQ&#39;s Blog - 一个简简单单的博客</title>


    <meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码分析">
<meta property="og:url" content="http://daqwt.top/HashMap/index.html">
<meta property="og:site_name" content="DAQ&#39;s Blog - 一个简简单单的博客">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://daqwt.top/images/og_image.png">
<meta property="article:published_time" content="2020-04-20T03:27:37.000Z">
<meta property="article:modified_time" content="2020-04-20T01:35:09.824Z">
<meta property="article:author" content="黑心市民">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://daqwt.top/images/og_image.png">





<link rel="alternative" href="/rss.xml" title="HashMap源码分析" type="application/atom+xml">



<link rel="icon" href="http://qiniu.daqwt.top/wangzhantubiao-32.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="http://qiniu.daqwt.top/logoo.png" alt="HashMap源码分析" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/photo">相册</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
                <a class="navbar-item"
                href="/share">分享</a>
                
                <a class="navbar-item"
                href="/friends">友链</a>
                
                <a class="navbar-item"
                href="/games">游戏</a>
                
                <a class="navbar-item"
                href="/books">书单</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="RSS" href="/rss.xml">
                        
                        <i class="fas fa-rss"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-content article ">
        
       
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal" align="center">
            
                HashMap源码分析
            
        </h1>
         <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-04-20T03:27:37.000Z">2020-04-20</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/">每天一道面试题</a>
                </div>
                
                                                            
                <span class="level-item has-text-grey">                    
                    
                    
                    35 分钟 读完 (大约 5323 个字)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span>次访问
                </span>
                
            </div>
        </div>
        
        <div class="content">
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。</p>
<a id="more"></a>
<ul>
<li><strong>全文概要</strong></li>
</ul>
<table>
<thead>
<tr>
<th>版本</th>
<th>1.7</th>
<th>1.8</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>数组+链表</td>
<td>数组+链表/红黑树</td>
</tr>
<tr>
<td>存值</td>
<td>Entry&lt;key，value&gt;对象</td>
<td>Node（key，value）节点</td>
</tr>
<tr>
<td>初始容量</td>
<td>小于传入数的2的幂次方数（移位运算）</td>
<td>大于传入数的2的幂次方数</td>
</tr>
<tr>
<td>哈希值</td>
<td>高低位混合运算（异或和移位）</td>
<td>高低位混合运算</td>
</tr>
<tr>
<td>扩容机制</td>
<td>头插法</td>
<td>尾插法/链表长度大于8时转化为红黑树</td>
</tr>
<tr>
<td>缺点</td>
<td>链表反转，形成循环链表，线程不安全</td>
<td>高度依赖hash算法，如果key是自定义类害得重写hashcode（），线程不安全</td>
</tr>
</tbody></table>
<h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h3><ul>
<li><code>JDK1.7</code>：数组+链表</li>
<li><code>key</code>和<code>value</code>组合成一个<code>entry</code>对象，将这个对象的引用地址存放在数组中。</li>
<li><code>table</code>数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.根据key先算出来一个hash值</span><br><span class="line"><span class="keyword">int</span> hash = key.hashcode();</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.用这个hash值去跟数组长度(table.length)做与操作</span><br><span class="line"><span class="keyword">int</span> i = hash &amp; (length-<span class="number">1</span>); <span class="comment">//得到的这个i就是数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.就把这个key对应的value放入数组下标i对应的位置</span><br><span class="line">table[i]=value;</span><br></pre></td></tr></table></figure>
<ul>
<li>那为什么要用链表呢？</li>
</ul>
<ol>
<li>再传进来一个<code>value</code>值,万一这个值对应的<code>key</code>算出来的<code>hash</code>值跟之前的重复了怎么办？这就要用到链表了。</li>
<li>将这个<code>key</code>对应的<code>value</code>值放在数组的同一个位置，只不过是以链表的形式。</li>
<li>那怎么放呢？是把这个元素放在链表的头部还是尾部呢？当然是采用<strong>头插法</strong>，因为尾插法效率低（他要遍历整个链表，要知道尾结点是谁，才能放入。）而放在头部只需要将<code>next</code>指向链表的头结点。</li>
<li>那么用<code>put（）</code>存进去了，用<code>get()</code>怎么取呢？，因为<code>get()</code>也是通过计算<code>hash</code>值，得到数组下标，但是这个下标上，有一个链表呀，怎么知道取的是哪个值呢？<strong>所以说：</strong> 一个新的结点插入到头部之后，要往下移动一个位置，（虽然说是移动一个位置，实际上是将这个新元素的值赋值给<code>table[i]</code>,这样，头结点在哪里，链表就在那里）那么取链表上的元素就好取了。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>先分析一下<code>put()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">         inflateTable(threshold);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             e.value = value;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     addEntry(hash, key, value, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过查看源码第一行的<code>if语句</code>可以看出，只有当要往里面存放元素的时候，才去初始化这个桶，懒加载（延迟初始化），在初始化数组的时候，调用了<code>inflateTable(threshold)</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在其中又调用了<code>roundUpToPowerOf2(toSize)</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>highestOneBit（）</code>方法,通过移位和或运算计算出小于<code>i</code>的<code>2的幂次方数capacity</code>（这就是庶族的初始化容量），比如说，传入10，计算得出8，传入19，计算得出16。这个方法里面的运算是先把传入的数转化为二进制，然后在进行移位位运算和或运算，就像这个方法名字一样：得到最高位的那一位，自然而然的得出来的数就是2次幂的数了。得出来的这个数就是<code>table数组</code>的长度，jdk的作者对于位运算的使用已经达到出神入化的境界。</li>
<li>这样做的目的是，如果你修改了这个<code>number值</code>，他也会在加载的时候将这个值转化小于<code>number</code>的2的幂次方数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">       i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">       <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>再看<code>indexFor()</code>方法，是通过将算出来的<code>hash值</code>与数组长度进行一个与运算，得到这个数组下标<code>i</code>。这个<code>table[i]</code>就是要存的位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">思考为什么要length-<span class="number">1</span>？</span><br><span class="line">因为length是<span class="number">2</span>的幂次方数</span><br><span class="line">经过与运算之后，只得到低四位有效，有效的低四位取值范围就是<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">就得出了下标在<span class="number">0</span>-<span class="number">15</span>这个范围之内。</span><br></pre></td></tr></table></figure>
<ul>
<li>这就可以解决以上的一个问题了，为什么hashmap在初始化一个数组的容量的时候，要是一个2的幂次方数，因为要配合<code>indexFor()</code>计算出数组下标，对应存储。但是这样算出来的<code>hash值</code>会覆盖掉很多种情况，这就导致了很多元素算出来的下标值一样，存储在同一链表上，链表就会很长，进而影响到<code>get()</code>的效率，因为<code>get()</code>要循环链表嘛，所以回到上一步，可以看到<code>hash()方法</code>。</li>
<li>再看<code>hash()</code>方法（并不是<code>hashcode()方法哦</code>），它里面有异或和移位运算（这样高位就参与到运算了–高低位混合运算），可以理解为<code>再次哈希</code>，这样就增加了散列性。解决了的单条链表很长的问题。如果我们要改写<code>hashcode（）</code>，但是我们水平不行，改了之后导致返回的<code>hashcode值</code>非常不均匀，那么这个<code>hash()方法</code>就会帮我们容错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再看<code>for循环</code>，它要做的事就是遍历链表，看看有没有key值相同的，比如说<code>put(1,2);</code>和<code>put(1,3)</code>，可以看到，两个key值是相等的，for循环判断之后，就会用新的值覆盖老的值，再返回老的值<code>oldValue</code>。</li>
<li><code>modCount++</code>跟多线程并发有关。</li>
<li><code>addEntry(hash,key,value,i)</code>这才是真正的将<code>key和value</code>放到数组上面去。<code>if</code>里面的语句就是涉及到扩容了，<code>threshold</code>是通过阈值<code>capacity</code>乘加载因子<code>DEFAULT_LOAD_FACTOR</code>得到的，如16<em>0.75=12，可以看到扩容要满足两个条件。这里的<code>size</code>是指当前数组占用了多少，而不是指链表的长度。后面那个条件是指数组中没有位置为空了，*</em>大于阈值，并且发生过一次碰撞之后就扩容！！！**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容的目的就是为了提高效率，因为链表上元素太多了，就会影响<code>get()</code>的效率。点开<code>resize()</code>方法可以看到，先<code>new</code>出来一个新的数组，长度是原先的两倍，然后在调用<code>transfer()</code>方法将老元素移动到新数组中。在转移的时候，将一个长链表拆成两个个短链表，减轻了压力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容是怎么来实现的呢？看这个<code>transfer()</code>方法中显示，有需要进行<code>rehash</code>的情况，也有不需要<code>rehash</code>的情况。看到<code>for()循环</code>是遍历这个数组上有没有空，而嵌套的<code>while()</code>循环是遍历这个链表上的元素。</li>
</ul>
<ol>
<li>先看不需要<code>rehash</code>的情况（<strong>适用于单线程</strong>）此时<code>rehash=false</code>，可以看到下面又使用了<code>indexFor</code>方法，传入的是被遍历的这个元素的hash值，和新数组的长度，计算得出一个值<code>i</code>，这就是新数组的下标，把老元素放到<code>newTable[i]</code>上。事实上，根据运算得到的<code>i</code>值和原先是一样的，因为原本的hash值没有变，只是拿过来用，而变化的是数组长度，但是并不会影响算出来的<code>i</code>值，所以说，传到新数组后，下标还是没有变。但是这样引发了扩容之后的一个问题：<strong>链表上的元素全部倒过来了，意思就是新链表的顺序和之前的完全颠倒了。</strong></li>
<li>多线程情况下，如果有两个线程同时调用haspmap的这个对象，都会使用到<code>put()</code>方法，如果最终同时走到了<code>resize()</code>方法中，各种混乱的走法之后，<strong>最终会产生一个循环链表，最终耗尽CPU的资源。</strong>–这就是haspmap扩容带来的第二个问题</li>
<li>再看需要<code>rehash</code>的情况，其实很少会走到<code>rehash()</code>中，在<code>rehash（）</code>中打了一个断点，测试的时候无限<code>put()</code>,却发现，始终不会执行<code>rehash（）</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h3><ul>
<li><strong>HashMap底层是怎么实现的呢？</strong><br>答：在jdk1.7的时候，底层是由数组+链表实现的，由key和value组成一个entry对象，用put方法将key和value传入，当调用这个put方法的时候，就会初始化一个数组（也就是所说的延迟初始化），这个数组的初始容量给的是16，负载因子是0.75，根据这个key值使用hash方法算出hash值，再用这个hash值跟数组的长度做模运算，得到一个数组下标，就将这个元素的值放入到对应下标的位置，那如果再传入的另一个元素算出来的hash值也是一样的（这就叫hash冲突），那么进而算出来的下标也是一样的，这就要用到链表了，使用头插法，并保证最新插入的这个元素是整个链表的头结点，就实现了存储的过程。</li>
<li><strong>扩容的机制？</strong><br>在put的时候，有一个方法是<code>addEntry</code>，先判断当前的size是不是大于阈值，这里的阈值就是（数组初始长度<em>加载因子），默认的就是12，大于这个阈值，并且发生了hash碰撞的时候，就要进行扩容了，就是执行<code>resize()</code>方法，扩容的方法就是，new一个新数组，长度是原数组长度的两倍，然后在用<code>transfer</code>方法将老数组中的元素转移过去，还重新算一下扩容之后的阈值，这样做出现的问题就是：在单线程情况下还好，只不过转移过去的链表会反转，*</em>但是在多线程的情况下**，就会出现一个闭环，会把cpu的资源耗尽。这里面还有一个<code>rehash()</code>方法，但是这个方法我并没有具体研究，涉及到一个哈希种子，其实这个rehash方法并不会用到。在源码rehash中打个断点，测试代码中无限put操作，发现程序并不会停止。</li>
<li><strong>HashMap为什么是线程不安全的？</strong><br>HashMap在put的时候，超过的阈值就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</li>
</ul>
<h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="大致了解-1"><a href="#大致了解-1" class="headerlink" title="大致了解"></a>大致了解</h3><ul>
<li>在1.7中叫entry对象，在1.8中叫node结点。</li>
<li><strong>在1.8中加入了红黑树，为什么加红黑树？</strong><br>虽然在1.7中实行了很多措施，如扩容，去增加元素的散列性，使链表的长度更短一些，但是还是会出现一些极端情况，某些地方链表还是会很长，所以加入了红黑树，当链表达到一定长度大于8的时候，就要先看数组，决定是否要扩容，然后在不行就要换用红黑树了。当红黑树结点小于6的时候，又变为链表了。</li>
<li><strong>为什么链表上限设置为8，为红黑树下限设置为6呢？为什么不设置为8？</strong><br>这样是为了防止平凡的插入和删除，打个比方，当我插入第9个元素的时候，这就要变为红黑树了，可是我马上又删除了一个元素，红黑树又要变成链表，这样不停的来回转换，会拉低效率，所以将红黑树结点下限设置为6。</li>
</ul>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>分析put（）方法。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416091904314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200416094525420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>在1.8中初始化容量的时候，和1.7有不同，如果你传入的一个数字，会调用<code>tableSizeFor()</code>方法进行移位运算，最终得到一个大于你传入的这个数字的数（这个数依旧是2的次幂），而1.7中得到的这个数字是小于你传入的这个数。这个数用来作为数组的初始容量。</p>
</li>
<li><p>在1.8中采用尾插法加入元素，这是因为，每次加入元素的时候，本来就要遍历一下链表，看有没有超过八个结点，超过了就变成红黑树，总之是要遍历的，直接用尾插法，一举两得。</p>
</li>
<li><p>在遍历的过程中，还要看有没有与老元素key值相同的，相同则覆盖掉，除此之外还要判断是否为红黑树。</p>
</li>
<li><p><strong>关于树化:</strong> 点开treeifyBin方法发现：在链表上的结点大于八个的时候，不会第一时间去树化，而是先判断是否需要扩容，然后再去决定要不要树化，其实扩容大概率能减少链表的长度了。一举两得，扩容比树化优点好多了。基于对内存的一个节省，不能扩容的太大，就用红黑树。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020041609544419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>1.8里的扩容只要满足一个条件，而1.7中需要满足两个。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416094609702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>扩容详解，条件只有一个，但是代码却长了很多，核心思想就是：使用2次幂的扩展（长度变两倍）所以，要么元素的位置是在原位置，要么是在原位置基础上移动2次幂的位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到里面的算hash值的方法。跟1.7的差不多。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200416092054872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><ul>
<li>JDK1.8中，HashMap是怎么实现的？<br>在JDK1.8中，底层是由数组+链表/红黑树实现的，将key和value封装成一个node结点，计算hash值和1.7是差不多的，在put的时候，有两点要注意，一个是判断新元素key值是否与老元素相等，相等则覆盖掉，不相等就直接插入，另一点就是判断是链表还是红黑树，选择遍历的方式，采用尾插法来插入元素，也不用担心需要遍历整个链表，因为判断链表上结点个数的时候总是要遍历的，这里值得注意的是，在判断是否需要变为红黑树的时候，（也就是链表结点大于等于8的时候）首先要考虑的是扩容，因为扩容大概率能够解决链表长度的问题，而且还增大了空间，但是不能一味的扩容，这样会导致内存浪费，所以就转换成红黑树了。</li>
</ul>
<h2 id="对比JDK1-7和1-8"><a href="#对比JDK1-7和1-8" class="headerlink" title="对比JDK1.7和1.8"></a>对比JDK1.7和1.8</h2><table>
<thead>
<tr>
<th></th>
<th>1.7</th>
<th>1.8</th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层实现</strong></td>
<td>数组+链表</td>
<td>数组+链表/红黑树</td>
</tr>
<tr>
<td><strong>形式</strong></td>
<td>Entry&lt;key，value&gt;对象</td>
<td>Node&lt;key,value&gt;结点</td>
</tr>
<tr>
<td><strong>下标值</strong></td>
<td>hash &amp;（length-1）</td>
<td>（n-1）&amp; hash</td>
</tr>
<tr>
<td><strong>元素插入</strong></td>
<td>头插法</td>
<td>尾插法</td>
</tr>
<tr>
<td><strong>扩容机制</strong></td>
<td>resize（链表反转，循环链表）</td>
<td>解决了链表反转的问题</td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>链表：n</td>
<td>红黑树：log（n）</td>
</tr>
<tr>
<td><strong>扩容</strong></td>
<td>transfor（）方法，新数组两倍长度</td>
<td>resize（）方法</td>
</tr>
</tbody></table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li><p><strong>HashMap线程不安全，为什么还要用它？</strong><br>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。但综合各种因素，首要推荐使用ConcurrentHashMap。</p>
</li>
<li><p><strong>ConcurrentHashMap实现</strong><br>ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</p>
</li>
<li><p><strong>ConcurrentHashMap有哪些优点？</strong></p>
</li>
</ul>
<ol>
<li>线程安全的，在多线程下效率更高。</li>
<li>ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有。</li>
<li>ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 </li>
</ol>
<ul>
<li><strong>ConcourrentHashMap和Hashtable都是线程安全的，为什么不用Hashtable？</strong></li>
</ul>
<ol>
<li>hashtable:使用一把锁处理并发问题，当有多个线程访问时，需要多个线程竞争一把锁，导致阻塞。</li>
<li>concurrentHashMap则使用分段，相当于把一个hashmap分成多个，然后每个部分分配一把锁，这样就可以支持多线程访问。</li>
</ol>

        </div>
        
        <ul class="post-copyright">
        <li><strong>本文标题：</strong><a href="http://daqwt.top/HashMap/">HashMap源码分析</a></li>
        <li><strong>本文作者：</strong><a href="http://daqwt.top">黑心市民</a></li>
        <li><strong>本文链接：</strong><a href="http://daqwt.top/HashMap/">http://daqwt.top/HashMap/</a></li>
        <li><strong>发布时间：</strong>2020-04-20</li>
        <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </li>
        </ul>
    
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7"><i class="fa fa-tag"></i></span>
                    <a class="has-link-grey -link" href="/tags/HashMap/" rel="tag">HashMap</a>
                </div>
            </div>
        </div>
        
        
        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">乞人不受嗟来之食,哎嘛，真香~</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="http://qiniu.daqwt.top/alipay.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="http://qiniu.daqwt.top/wechatpay.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/String,StringBuffer,StringBuilder%E8%AF%A6%E8%A7%A3/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">String,StringBuffer,StringBuilder详解</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/%E6%B3%A8%E8%A7%A3/">
                <span class="level-item">JavaSE---注解</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
<div id="valine-thread" class="content"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: true,
        verify: true,
        app_id: 'AGGG1bgO42sEaVaFqWL1IWdu-gzGzoHsz',
        app_key: 'IdOMlYlWz8QYnB5YDBSWuTBi',
        placeholder: '请不要出现虎狼之词...否则我将代表网络正义重拳出击'
    });
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="http://qiniu.daqwt.top/touxiang.jpg" alt="彭鱼晏">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        彭鱼晏
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        no pain , no gain
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>武汉 中国</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            93
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            13
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            32
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://blog.csdn.net/weixin_44861399" target="_blank" rel="noopener">
                别犹豫,关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
                <link rel="stylesheet" href="/css/iconfont.css">
            <a class="level-item button is-white is-marginless" target="_blank" 
                title="Github" href="https://github.com/DAQ121">
                
                <i class="iconfont icon-git"></i>
                
            </a>
            
                <link rel="stylesheet" href="/css/iconfont.css">
            <a class="level-item button is-white is-marginless" target="_blank" 
                title="QQ" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2829025551&amp;site=qq&amp;menu=yes">
                
                <i class="fab fa-qq"></i>
                
            </a>
            
                <link rel="stylesheet" href="/css/iconfont.css">
            <a class="level-item button is-white is-marginless" target="_blank" 
                title="网易云" href="https://music.163.com/#/djradio?id=791862420">
                
                <i class="iconfont icon-wangyiyun"></i>
                
            </a>
            
                <link rel="stylesheet" href="/css/iconfont.css">
            <a class="level-item button is-white is-marginless" target="_blank" 
                title="CSDN" href="https://blog.csdn.net/weixin_44861399">
                
                <i class="iconfont icon-csdn"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        

    <div class="card widget column-left is-sticky" id="toc">
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    <i class="iconfont icon-mulu"></i>
                    目录
                </h3>
                <ul class="menu-list"><li>
        <a class="is-flex" href="#JDK1-7">
        <span class="has-mr-6">1</span>
        <span>JDK1.7</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#大致了解">
        <span class="has-mr-6">1.1</span>
        <span>大致了解</span>
        </a></li><li>
        <a class="is-flex" href="#源码分析">
        <span class="has-mr-6">1.2</span>
        <span>源码分析</span>
        </a></li><li>
        <a class="is-flex" href="#归纳总结">
        <span class="has-mr-6">1.3</span>
        <span>归纳总结</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#JDK1-8">
        <span class="has-mr-6">2</span>
        <span>JDK1.8</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#大致了解-1">
        <span class="has-mr-6">2.1</span>
        <span>大致了解</span>
        </a></li><li>
        <a class="is-flex" href="#源码分析-1">
        <span class="has-mr-6">2.2</span>
        <span>源码分析</span>
        </a></li><li>
        <a class="is-flex" href="#总结归纳">
        <span class="has-mr-6">2.3</span>
        <span>总结归纳</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#对比JDK1-7和1-8">
        <span class="has-mr-6">3</span>
        <span>对比JDK1.7和1.8</span>
        </a></li><li>
        <a class="is-flex" href="#常见问题">
        <span class="has-mr-6">4</span>
        <span>常见问题</span>
        </a></li></ul>
            </div>
        </div>
    </div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile" align="center" style="margin:auto">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="http://qiniu.daqwt.top/logoo.png" alt="HashMap源码分析" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 黑心市民&nbsp;
                <i class="fas fa-balance-scale"></i>
                <a href="http://www.beian.miit.gov.cn/" target="_blank">鄂ICP备20003594</a>
                
                <br>
                <span id="busuanzi_container_site_uv">本站访客<span id="busuanzi_value_site_uv"></span>人</span>
                <span><i class="fas fa-globe-asia"></i></span>
				<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
                
                </p>
            <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
            <script>
                var now = new Date(); 
                function createtime() { 
                    var grt= new Date("02/14/2020 12:49:00");//此处修改你的建站时间或者网站上线时间 
                    now.setTime(now.getTime()+250); 
                    days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
                    hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
                    if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
                    mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
                    seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
                    snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
                    document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
                } 
                setInterval("createtime()",250);
            </script>
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://daqwt.top',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>