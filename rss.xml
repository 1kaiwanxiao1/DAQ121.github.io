<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DAQ&#39;s Blog - 一个简简单单的博客</title>
  
  <subtitle>小朋友，你是不是有很多的问号？？？</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://daqwt.top/"/>
  <updated>2020-07-16T02:43:18.781Z</updated>
  <id>http://daqwt.top/</id>
  
  <author>
    <name>黑心市民</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot集成Swagger</title>
    <link href="http://daqwt.top/SpringBoot%E9%9B%86%E6%88%90Swagger/"/>
    <id>http://daqwt.top/SpringBoot%E9%9B%86%E6%88%90Swagger/</id>
    <published>2020-07-13T02:33:34.000Z</published>
    <updated>2020-07-16T02:43:18.781Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前后端程序员的沟通是通过接口文档来实现的，前端经常抱怨后端给的接口文档与实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。而且接口文档往往很容易就跟不上代码了。所以像swagger这种工具就是前后端程序员的福音，自动生成接口API，更有助于实现前后端分离。</p><a id="more"></a><h2 id="为什么要学swagger"><a href="#为什么要学swagger" class="headerlink" title="为什么要学swagger"></a>为什么要学swagger</h2><ol><li><strong>自动生成API接口文档！！！</strong></li><li>由于前后端无法做到<code>及时协商，尽早解决</code>，沟通不便，开发迟缓</li><li><code>swagger</code>号称世界上最流行的<code>API</code>框架</li><li><code>Restful Api</code> 文档在线自动生成器，可以直接运行，在线测试API</li></ol><h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>1.添加<code>maven</code>依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--swagger依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--ui界面，可选有多种--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.编写一个<code>Controller</code>，并确保运行成功。<br>3.编写配置类<code>SwaggerConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2<span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;  </span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.通过<code>apiInfo()</code>属性配置文档信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2<span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;  </span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置文档信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Contact contact = <span class="keyword">new</span> Contact(<span class="string">"联系人名字"</span>, <span class="string">"http://xxx.xxx.com/联系人访问链接"</span>, <span class="string">"联系人邮箱"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">           <span class="string">"Swagger学习"</span>, <span class="comment">// 标题</span></span><br><span class="line">           <span class="string">"学习演示如何配置Swagger"</span>, <span class="comment">// 描述</span></span><br><span class="line">           <span class="string">"v1.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">           <span class="string">"http://terms.service.url/组织链接"</span>, <span class="comment">// 组织链接</span></span><br><span class="line">           contact, <span class="comment">// 联系人信息</span></span><br><span class="line">           <span class="string">"Apach 2.0 许可"</span>, <span class="comment">// 许可</span></span><br><span class="line">           <span class="string">"许可链接"</span>, <span class="comment">// 许可连接</span></span><br><span class="line">           <span class="keyword">new</span> ArrayList&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.<code>Docket</code> 实例关联上 <code>apiInfo()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.启动，访问 <code>http://localhost:8080/swagger-ui.html</code> ，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200714221824549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h3><p>1.构建<code>Docket</code>时用<code>select()</code>方法，通过包路径配置扫描接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.daq.controller"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.还可以通过配置其他方式扫描接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">any() </span><br><span class="line"><span class="comment">// 不扫描接口</span></span><br><span class="line">none() </span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line"><span class="comment">// 根据包路径扫描接口</span></span><br><span class="line">basePackage(<span class="keyword">final</span> String basePackage)</span><br></pre></td></tr></table></figure><p>3.还可以配置接口扫描过滤，不扫描哪些包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.daq.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/daq开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/daq/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.包扫描过滤还有以下可选值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br></pre></td></tr></table></figure><h3 id="Swagger开关"><a href="#Swagger开关" class="headerlink" title="Swagger开关"></a>Swagger开关</h3><p>1.通过<code>enable()</code>方法配置是否启用<code>swagger</code>，如果是<code>false</code>，<code>swagger</code>将不能在浏览器中访问了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(<span class="keyword">false</span>) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.daq.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/daq开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/daq/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.当项目处于<code>test、dev</code>环境时显示<code>swagger</code>，处于<code>prod</code>时不显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   Profiles of = Profiles.of(<span class="string">"dev"</span>, <span class="string">"test"</span>);<span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   <span class="keyword">boolean</span> b = environment.acceptsProfiles(of);<span class="comment">// 判断当前是否处于该环境,通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(b) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.daq.controller"</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/daq开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">"/daq/**"</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API分组配置"><a href="#API分组配置" class="headerlink" title="API分组配置"></a>API分组配置</h3><p><img src="https://img-blog.csdnimg.cn/2020071422202716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1.如果没有配置分组，默认是<code>default</code>，通过<code>groupName()</code>方法即可配置分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">      .groupName(<span class="string">"hello"</span>) <span class="comment">// 配置分组</span></span><br><span class="line">       <span class="comment">// 省略配置....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.配置多个分组只需要配置多个<code>docket</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">"group3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h3><p>1.新建一个实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"用户名"</span>)</span><br><span class="line">   <span class="keyword">public</span> String username;</span><br><span class="line">   <span class="meta">@ApiModelProperty</span>(<span class="string">"密码"</span>)</span><br><span class="line">   <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在<code>controller</code>中编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.注意：</p><ul><li>并不是因为<code>@ApiModel</code>这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而<code>@ApiModel</code>和<code>@ApiModelProperty</code>这两个注解只是为实体添加注释的。</li><li><code>@ApiModel</code>为类添加注释</li><li><code>java@ApiModelProperty</code>为类属性添加注释</li></ul><p>4.访问如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200714222734612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><h2 id="其他皮肤"><a href="#其他皮肤" class="headerlink" title="其他皮肤"></a>其他皮肤</h2><ul><li>我们可以导入不同的包实现不同的皮肤定义：</li></ul><p>1.<code>swagger-ui</code>， 访问 <code>http://localhost:8080/swagger-ui.html</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.<code>bootstrap-ui</code> ，访问 <code>http://localhost:8080/doc.html</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3.<code>Layui-ui</code>   访问 <code>http://localhost:8080/docs.html</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>4.<code>mg-ui</code>   访问 <code>http://localhost:8080/document.html</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swagger是个优秀的工具，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发。但是出于安全考虑以及节约运行时内存，在正式环境要记得关闭Swagger。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前后端程序员的沟通是通过接口文档来实现的，前端经常抱怨后端给的接口文档与实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。而且接口文档往往很容易就跟不上代码了。所以像swagger这种工具就是前后端程序员的福音，自动生成接口API，更有助于实现前后端分离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Shiro</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88Shiro/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88Shiro/</id>
    <published>2020-07-12T03:59:04.000Z</published>
    <updated>2020-07-17T15:42:14.182Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shiro</code> 就是用来解决安全管理的系统化框架。它是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。</p><a id="more"></a><h2 id="shiro是什么？"><a href="#shiro是什么？" class="headerlink" title="shiro是什么？"></a>shiro是什么？</h2><ul><li>官网：<a href="http://shiro.apache.org/">http://shiro.apache.org/</a></li><li><code>Shiro</code> 就是用来解决安全管理的系统化框架。</li><li>它是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。</li></ul><h2 id="Shiro-核心组件"><a href="#Shiro-核心组件" class="headerlink" title="Shiro 核心组件"></a>Shiro 核心组件</h2><ul><li>用户、角色、权限</li><li>给用户赋予角色，会给角色赋予权限。</li></ul><ol><li><code>UsernamePasswordToken:</code> 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token。</li><li><code>SecurityManager:</code>核心部分，负责安全认证和授权。</li><li><code>Suject: Shiro</code> 的一个抽象概念，包含了用户信息。</li><li><code>Realm:</code> 开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 <code>Realm</code> 中。</li><li><code>AuthenticationInfo:</code><strong>用户的角色信息集合，认证时使用</strong>。</li><li><code>AuthorzationInfo:</code><strong>角色的权限信息集合，授权时使用</strong>。</li><li><code>DefaultWebSecurityManager:</code> 安全管理器，开发者自定义的 <code>Realm</code> 需要注入到 <code>DefaultWebSecurityManager</code> 进行管理才能生效。</li><li><code>ShiroFilterFactoryBean:</code>过滤器工厂，<code>Shiro</code> 的基本运行机制是开发者定制规则，<code>Shiro</code> 去执行，具体的执行操作就是由 <code>ShiroFilterFactoryBean</code> 创建的一个个 Filter 对象来完成。</li><li><code>shiro</code>工作流程<br><img src="https://img-blog.csdnimg.cn/20200717140425752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><ol><li>导入依赖</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--shiro--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义<code>Realm</code>过滤器，继承自<code>AuthorizingRealm</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccoutRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//做认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端传过来的对象和密码，自动封装在token中，</span></span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        <span class="comment">//根据用户名进行查询，并且判断</span></span><br><span class="line">        Account account = accountService.findByUsername(token.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (account != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//用户名不为空，继续验证密码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(account,account.getPassword(),getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用户名为空，直接跳出验证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//再授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户邓登陆的信息</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        Account account = (Account) subject.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置角色</span></span><br><span class="line">        Set&lt;String&gt; roles = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        roles.add(account.getRole());</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置权限</span></span><br><span class="line">        info.addStringPermission(account.getPerms());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置视图解析器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thymeleaf:</span><br><span class="line">  prefix: classpath:/templates/shiro/</span><br><span class="line">  suffix: .html</span><br></pre></td></tr></table></figure><ol start="4"><li>编写<code>ShiroConfig</code>配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRealm <span class="title">accountRealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">(@Qualifier(<span class="string">"accountRealm"</span>)</span> AccountRealm accountRealm)</span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(accountRealm);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入工厂</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(@Qualifier(<span class="string">"securityManager"</span>)</span> DefaultWebSecurityManager securityManager)</span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//权限设置，根据自己需要设置相应的权限组</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"/main"</span>,<span class="string">"authc"</span>);</span><br><span class="line">        map.put(<span class="string">"/manage"</span>,<span class="string">"perms[manage]"</span>);</span><br><span class="line">        map.put(<span class="string">"/administrator"</span>,<span class="string">"roles[administrator]"</span>);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置登陆页面</span></span><br><span class="line">        factoryBean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置未授权页面</span></span><br><span class="line">        factoryBean.setUnauthorizedUrl(<span class="string">"/unauth"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写认证和授权规则，<code>shiro</code>帮我们写好了，我们只需要选择就可以。</li><li>如果不想使用<code>shiro</code>，直接将<code>ShiroConfig</code>上的<code>@Configuration</code>注释就可以了</li></ol><p><strong>认证过滤器</strong></p><ul><li><code>anon：</code>无需认证。</li><li><code>authc：</code>必须认证。</li><li><code>authcBasic：</code>需要通过 <code>HTTPBasic</code> 认证。</li><li><code>user：</code>不一定通过认证，只要曾经被 <code>Shiro</code> 记录即可，比如：记住我。</li></ul><p><strong>授权过滤器</strong></p><ul><li><code>perms：</code>必须拥有某个权限才能访问。</li><li><code>role：</code>必须拥有某个角色才能访问。</li><li><code>port：</code>请求的端口必须是指定值才可以。</li><li><code>rest：</code>请求必须基于 RESTful，POST、PUT、GET、DELETE。</li><li><code>ssl：</code>必须是安全的 URL 请求，协议 HTTPS。</li></ul><h2 id="thymeleaf整合shiro"><a href="#thymeleaf整合shiro" class="headerlink" title="thymeleaf整合shiro"></a>thymeleaf整合shiro</h2><ol><li>导入依赖</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>shiro&#39;Config</code>中配置<code>thymeleaf</code>方言</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shiro整合thymeleaf,引进方言</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">shiroDialect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>html</code>代码中引入命名空间，就可以使用shiro的标签了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">"en"</span> xmlns:th=<span class="string">"http://www.thymeleaf.org"</span> xmlns:shiro=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-shiro"</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Shiro&lt;/code&gt; 就是用来解决安全管理的系统化框架。它是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合MybatisPlus</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88MybatisPlus/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88MybatisPlus/</id>
    <published>2020-07-12T03:59:04.000Z</published>
    <updated>2020-07-16T15:13:11.435Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工作中少不了很多重复的工作，好的解决办法就是，将这些重复的代码，写成一个模版，也就是造轮子，然而已经有了mybatis-plus这么好的轮子，就大大节省了我们的工作时间，提升了工作效率。它可以根据表自动生成代码，简单的增删改查语句都不用我们写，只需要配置，以及写一些复杂的语句即可。当然，配合easycode这个插件，就更加简单便捷了。</p><a id="more"></a><h2 id="整合MybatisPlus"><a href="#整合MybatisPlus" class="headerlink" title="整合MybatisPlus"></a>整合MybatisPlus</h2><p>1.导入<code>MybatisPlus</code>依赖和<code>Velocity</code>模版引擎</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis-plus--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.3.1.tmp&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Velocity模版引擎--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.自定义代码生成模版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码自动生成器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要构建一个代码自动生成器对象</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        <span class="comment">// 配置策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1、全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">"/src/main/java"</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">"daq"</span>); <span class="comment">//作者名称</span></span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        gc.setFileOverride(<span class="keyword">false</span>); <span class="comment">// 是否覆盖</span></span><br><span class="line">        gc.setServiceName(<span class="string">"%sService"</span>); <span class="comment">// 去Service的I前缀</span></span><br><span class="line">        gc.setIdType(IdType.ID_WORKER);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、设置数据源</span></span><br><span class="line">        DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">        dsc.setUrl(<span class="string">"jdbc:mysql://localhost:3306/dbName?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8"</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、包的配置</span></span><br><span class="line">        PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">        pc.setModuleName(<span class="string">"demo"</span>); <span class="comment">//你想要生成在哪个包中</span></span><br><span class="line">        pc.setParent(<span class="string">"com.daq"</span>); <span class="comment">//父包</span></span><br><span class="line">        pc.setEntity(<span class="string">"entity"</span>);</span><br><span class="line">        pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">        pc.setService(<span class="string">"service"</span>);</span><br><span class="line">        pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        strategy.setInclude(<span class="string">"admin"</span>); <span class="comment">// 设置要映射的表名，可以同时写多个表，用逗号隔开。</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// 自动lombok；</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>);</span><br><span class="line">        <span class="comment">// 自动填充配置</span></span><br><span class="line">        TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">"gmt_create"</span>, FieldFill.INSERT);</span><br><span class="line">        TableFill gmtModified = <span class="keyword">new</span> TableFill(<span class="string">"gmt_modified"</span>, FieldFill.INSERT_UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tableFills.add(gmtCreate);</span><br><span class="line">        tableFills.add(gmtModified);</span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">// 乐观锁</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line">        strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);<span class="comment">//localhost:8080/hello_id_2</span></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line">        mpg.execute(); <span class="comment">//执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.根据自己的需要，修改在哪个包下生成代码，填写表名，就可以得到相应的映射，运行这个类，即可生成相应的代码。</p><p>4.配置日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>5.在 <code>Spring Boot</code> 启动类中添加 <code>@MapperScan</code> 注解，扫描 <code>Mapper</code> 文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.daq.demo.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(QuickStartApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.在测试类中编写测试方法，可以看到，一句sql都没写，就能正常查询出来，这就是<code>mybatisplus</code>的便利性，当然，一些复杂的查询语句当然还是要我们自己写出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AdminMapper adminMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;Admin&gt; admins = adminMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">admins.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.一些进阶的操作，例如 <strong>主键生成策略，更新操作，自动填充，乐观锁，分页查询，逻辑删除，性能分析插件，条件构造器，</strong> 都可以在<code>mybatisPlus</code>的官方文档中查看<a href="https://mp.baomidou.com/guide/">https://mp.baomidou.com/guide/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;工作中少不了很多重复的工作，好的解决办法就是，将这些重复的代码，写成一个模版，也就是造轮子，然而已经有了mybatis-plus这么好的轮子，就大大节省了我们的工作时间，提升了工作效率。它可以根据表自动生成代码，简单的增删改查语句都不用我们写，只需要配置，以及写一些复杂的语句即可。当然，配合easycode这个插件，就更加简单便捷了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>java的对象命名说明</title>
    <link href="http://daqwt.top/java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%AF%B4%E6%98%8E/"/>
    <id>http://daqwt.top/java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%AF%B4%E6%98%8E/</id>
    <published>2020-07-11T04:17:43.000Z</published>
    <updated>2020-07-16T05:51:28.506Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j2ee中，经常提到几种对象(object)，如：<code>POJO</code>,<code>PO</code>,<code>DTO</code>,<code>DAO</code>,<code>BO</code>,<code>VO</code>。理解他们的含义有助于我们更好的理解面向对象的设计思维。</p><a id="more"></a><ul><li><strong>POJO(plain old java object)</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>普通的java对象</code>，有别于特殊的java对象(含继承约束等)和EJB。POJO一般只有一系列的属性和相应的get、set方法。</p><ul><li><strong>PO(persistant object)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>持久化对象</code>，有别于POJO,必须对应数据库中的实体。一个PO对应数据库的一条记录。持久化对象的生命周期与数据库密切相关，只能存在于connection之中，连接关闭后，PO就消失了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PO相对于POJO有诸多不同，比如PO中会有保存数据库entity状态的属性和方法。但是ORM(object-relation mapping)追求的目标是PO和POJO的一致，所以在程序员的日常开发中，都是将POJO作为PO使用，而将POJO转化为PO的功能交给hibernate等框架来实现。</li><li><strong>DTO(data transfer object)</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>数据传输对象</code>，以前被称为值对象(VO,value object)，作用仅在于在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO并不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。</p><ul><li><strong>DAO(data access object)</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>数据访问对象</code>。提供访问数据库的抽象接口，或者持久化机制，而不暴露数据库的内部详细信息。DAO提供从程序调用到持久层的匹配。</p><ul><li>** BO(business object)**</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>业务对象</code>。主要是将业务逻辑封装为一个对象，该对象可以包含一个或多个其他对象。如，”Principal”(委托人)，有”Name”,”Age”等属性，同时和”Employee”(雇员)有1对多的关系，这个”Principal”就可以作为一个与业务相关的PO。 </p><ul><li><strong>VO（Value Object）</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>值对象</code>，其实和 BO、DTO 、PO差不多，只是更形象化了， VO更简单，没有任何思想，就是一个传输对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;j2ee中，经常提到几种对象(object)，如：&lt;code&gt;POJO&lt;/code&gt;,&lt;code&gt;PO&lt;/code&gt;,&lt;code&gt;DTO&lt;/code&gt;,&lt;code&gt;DAO&lt;/code&gt;,&lt;code&gt;BO&lt;/code&gt;,&lt;code&gt;VO&lt;/code&gt;。理解他们的含义有助于我们更好的理解面向对象的设计思维。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合redis</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88redis/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88redis/</id>
    <published>2020-07-11T03:59:04.000Z</published>
    <updated>2020-07-16T04:16:55.020Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目中必不可少的<code>redis</code>，它是非关系型数据库，通过key-value键值对存储数据，有很多应用场景，如存储个人信息，最近浏览，评论等等，更重要的是，用<code>redis</code>当做缓存，可以大大减轻数据库访问的压力，提高访问效率。</p><a id="more"></a><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li>SpringBoot 操作数据的有：<code>spring-data jpa</code>,<code>jdbc</code> ,<code>mongodb</code> ,<code>redis</code>！</li><li>项目中必不可少<code>redis</code>，它是非关系型数据库，有很多应用场景，如存储个人信息，最近浏览，评论等等，更重要的是，用<code>redis</code>当做缓存，可以大大减轻数据库访问的压力，提高访问效率。<code>java</code>操作<code>redis</code>， 在 <code>SpringBoot2.x</code> 之后，原来使用的<code>jedis</code> 被替换为了 <code>lettuce</code>。</li></ul><ol><li><code>jedis :</code> 底层采用的直连，如果多个线程操作的话是不安全的，如果想要避免不安全的，使用 <code>jedis pool</code> 连接池，这就更像 <code>BIO</code> 模式。</li><li><code>lettuce :</code> 采用<code>netty</code>，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 <code>NIO</code>模式</li></ol><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>1.引入依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在<code>application.yml</code>中配置连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  #配置redis</span><br><span class="line">  redis:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>3.将本地的<code>reids</code>服务端打开之后，就可以在java代码中使用<code>jedis</code>来操作了，如下简单的<code>set/get</code>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testReids</span><span class="params">()</span></span>&#123;</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">redisTemplate.opsForValue().get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.我们需要注意的一个问题是： 默认的序列化方式是JDK序列化，我们会使用json来序列化，关于对象的保存：所有的对象，都需要序列化，所以我们需要自己定义了一个 RedisTemplate,用的时候就用自己定义的模版就好了，不用担心对象序列化的问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.Springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template=<span class="keyword">new</span> RedisTemplate&lt;String,Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=<span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om=<span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer=<span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;项目中必不可少的&lt;code&gt;redis&lt;/code&gt;，它是非关系型数据库，通过key-value键值对存储数据，有很多应用场景，如存储个人信息，最近浏览，评论等等，更重要的是，用&lt;code&gt;redis&lt;/code&gt;当做缓存，可以大大减轻数据库访问的压力，提高访问效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置Druid数据源</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88MybatisPlus%E5%92%8CDruid%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88MybatisPlus%E5%92%8CDruid%E6%95%B0%E6%8D%AE%E6%BA%90/</id>
    <published>2020-07-10T02:33:34.000Z</published>
    <updated>2020-07-16T03:56:14.184Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时还加入了日志监控。可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><a id="more"></a><p>1.导入<code>Druid</code>数据源</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Druid 数据源--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--文件引入依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在<code>application.yml</code>中配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/db_name?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源</span><br></pre></td></tr></table></figure><p>3.导入<code>Log4j</code> 的依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--log4j--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>4.配置<code>DruidConfig</code>，获取数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span></span><br><span class="line"><span class="comment">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span></span><br><span class="line"><span class="comment">       @ConfigurationProperties(prefix = "spring.datasource")：作用就是将 全局配置文件中</span></span><br><span class="line"><span class="comment">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>5.配置<code>Druid</code>数据源监控，登录密码，访问页面<code>http://localhost:8080/druid/login.html</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Druid 监控管理后台的Servlet；</span></span><br><span class="line">    <span class="comment">//由于内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet</span></span><br><span class="line">        <span class="comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span></span><br><span class="line">        Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>); <span class="comment">//后台管理界面的登录账号</span></span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>, <span class="string">"123456"</span>); <span class="comment">//后台管理界面的登录密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//后台允许谁可以访问</span></span><br><span class="line">        <span class="comment">//initParams.put("allow", "localhost")：表示只有本机可以访问</span></span><br><span class="line">        <span class="comment">//initParams.put("allow", "")：为空或者为null时，表示允许所有访问</span></span><br><span class="line">        initParams.put(<span class="string">"allow"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">//deny：Druid 后台拒绝谁访问</span></span><br><span class="line">        <span class="comment">//initParams.put("kuangshen", "192.168.1.20");表示禁止此ip访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始化参数</span></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.配置 <code>Druid web</code> 监控 <code>filter</code> 过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Druid 监控 之  web 监控的 filter</span></span><br><span class="line">    <span class="comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span></span><br><span class="line">        Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>, <span class="string">"*.js,*.css,/druid/*,/jdbc/*"</span>);</span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//"/*" 表示过滤所有请求</span></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.项目启动之后，访问<code>http://localhost:8080/druid/login.html</code>就可以看到数据监控的画面了。功能很强大。如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200716115411190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时还加入了日志监控。可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句优化</title>
    <link href="http://daqwt.top/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    <id>http://daqwt.top/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-04T09:14:06.000Z</published>
    <updated>2020-06-12T09:16:03.098Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库最常用的优化方式有：SQL语句和索引、数据库表结构、系统配置、硬件。优化效果：SQL语句和索引 &lt; 数据库表结构 &lt; 系统配置 &lt; 硬件，成本也是递增的。</p><a id="more"></a><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>设计符合范式的数据库。</p><ol><li>设计符合范式的数据库。</li><li>选择合适的存储引擎。</li><li>SQL语句优化；</li><li>索引优化：高分离字段建立索引。</li><li>SQL表结构、字段优化。</li><li>数据库参数优化：IO参数、CPU参数。</li><li>延迟加载、设置缓存与缓存参数优化。</li><li>分库分表：垂直切分与水平切分。</li><li>分区：将表的数据按照特定的规则放在不同的分区，提高磁盘的IO效率，提高数据库的性能。</li><li>主从复制与读写分离：三个主要线程与bin-log文件、relay_log文件，主数据库负责写操作，从数据库负责读操作。</li><li>负载均衡。</li><li>数据库集群。</li><li>硬件。</li></ol><h2 id="sql语句优化"><a href="#sql语句优化" class="headerlink" title="sql语句优化"></a>sql语句优化</h2><p><strong>原则：</strong></p><ul><li>避免全表扫描，尽量用索引。 </li></ul><p><strong>1. 写出统一的SQL语句：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然只是大小写不同，但是查询分析器认为是两句不同的SQL语句，就会进行两次解析，生成2个执行计划。所以应该保证相同的查询语句在任何地方都一致，多一个空格都不行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dual</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">From</span> dual</span><br></pre></td></tr></table></figure><p><strong>2. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</strong></p><p><strong>3. 对查询进行优化，应尽量避免全表扫描，首先考虑在 where 及 order by 涉及的列上建立索引。</strong></p><p><strong>4. 尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</strong> 如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>5. 避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</strong></p><p><strong>6. 前导模糊查询将导致全表扫描：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%c%'</span></span><br></pre></td></tr></table></figure><p>使用索引的情况下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'c%'</span></span><br></pre></td></tr></table></figure><p><strong>7. not in 也要慎用</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会导致全表扫描。对于连续的数值，能用 <code>between</code> 就不要用 <code>in</code> 了，尽量使用<code>exists</code>代替<code>in</code>。</p><p><strong>8. 如果在 where 子句中使用参数，也会导致全表扫描。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure><p>可以改为强制查询使用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span></span><br></pre></td></tr></table></figure><p><strong>7. 应尽量避免在 where 子句中对字段进行表达式与函数或其他表达式运算操作，这将导致引擎放弃使用索引而进行全表扫描。</strong> 如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line">应改为：<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’ –<span class="keyword">name</span>以abc开头的<span class="keyword">id</span></span><br><span class="line">应改为：<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="keyword">day</span>,createdate,<span class="string">'2005-11-30'</span>)=<span class="number">0</span> –<span class="string">'2005-11-30'</span>生成的<span class="keyword">id</span></span><br><span class="line">应改为：<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> createdate&gt;=<span class="string">'2005-11-30'</span> <span class="keyword">and</span> createdate&lt;<span class="string">'2005-12-1'</span></span><br></pre></td></tr></table></figure><p><strong>8. Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</strong></p><p><strong>9. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</strong></p><p><strong>10. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引。如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</strong></p><p><strong>11. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。一个表的索引数较好不要超过6个。</strong></p><p><strong>12. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源</strong>。</p><p><strong>13. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</strong></p><p>14、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>15、任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替<code>*</code>，不要返回用不到的任何字段。</p><p>16、对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p><p>17、尽量使用表变量来代替临时表。</p><p>18、考虑使用“临时表”暂存中间结果。临时表并不是不可使用，适当地使用它们可以使某些查询更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。将临时结果暂存在临时表，后面的查询就在tempdb中查询了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是，对于一次性事件，较好使用导出表。</p><p>19、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>20、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22、尽量避免使用游标，因为游标的效率较差。与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。</p><p>23、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。</p><p>24、尽量避免向客户端返回大数据量。</p><p>25、尽量避免大事务操作，提高系统并发能力。</p><p>26、用where子句替换Having子句：</p><p>避免使用having子句，having只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序，如果能通过where子句限制记录的数目，就可以减少这方面的开销。on、where、having这三个都可以加条件的子句，on是最先执行，where次之，having最后。</p><p>27、使用Truncate替代delete：</p><p>当需要删除全表的记录时使用Truncate替代delete。在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短。</p><p>28、使用表的别名:</p><p>当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p><p>29、使用union all 替换 union：</p><p>当SQL语句需要union两个查询结果集合时，这两个结果集合会以union all的方式被合并，然后再输出最终结果前进行排序。如果用union all替代料union，这样排序就不是不要了，效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。</p><p>30、用where替代order by：</p><p>ORDER BY 子句只在两种严格的条件下使用索引：<br>（1）ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序；<br>（2）ORDER BY中所有的列必须定义为非空； </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">低效: (索引不被使用) </span><br><span class="line"><span class="keyword">SELECT</span> DEPT_CODE <span class="keyword">FROM</span>  DEPT  <span class="keyword">ORDER</span> <span class="keyword">BY</span>  DEPT_TYPE </span><br><span class="line">高效: (使用索引) </span><br><span class="line"><span class="keyword">SELECT</span> DEPT_CODE <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span>  DEPT_TYPE &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>31、避免索引列的类型转换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设EMP_TYPE是一个字符类型的索引列. </span><br><span class="line">  <span class="keyword">SELECT</span> …  <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span> EMP_TYPE = <span class="number">123</span> </span><br><span class="line">  这个语句被转换为: </span><br><span class="line">  <span class="keyword">SELECT</span> …  <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span> EMP_TYPE=‘<span class="number">123</span>’ </span><br><span class="line">  因为内部发生的类型转换, 这个索引将不会被用到! </span><br><span class="line">  为了避免<span class="keyword">ORACLE</span>对你的<span class="keyword">SQL</span>进行隐式的类型转换, 最好把类型转换用显式表现出来.</span><br><span class="line">  注意当字符和数值比较时, <span class="keyword">ORACLE</span>会优先转换数值类型到字符类型。</span><br></pre></td></tr></table></figure><p>32、优化Group by：</p><p>提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">低效: </span><br><span class="line"><span class="keyword">SELECT</span> JOB , <span class="keyword">AVG</span>(SAL) </span><br><span class="line"><span class="keyword">FROM</span> EMP </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> JOB </span><br><span class="line"><span class="keyword">HAVING</span> JOB = <span class="string">'PRESIDENT'</span> </span><br><span class="line"><span class="keyword">OR</span> JOB = <span class="string">'MANAGER'</span></span><br><span class="line"></span><br><span class="line">高效: </span><br><span class="line"><span class="keyword">SELECT</span> JOB , <span class="keyword">AVG</span>(SAL) </span><br><span class="line"><span class="keyword">FROM</span> EMP </span><br><span class="line"><span class="keyword">WHERE</span> JOB = <span class="string">'PRESIDENT'</span> </span><br><span class="line"><span class="keyword">OR</span> JOB = <span class="string">'MANAGER'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> JOB</span><br></pre></td></tr></table></figure><p>33、避免使用耗费资源的操作：</p><p>带有<code>DISTINCT,UNION,MINUS,INTERSECT,ORDER BY</code>的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强。</p><p><strong>34、在运行代码中，尽量使用PreparedStatement来查询，不要用Statement。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据库最常用的优化方式有：SQL语句和索引、数据库表结构、系统配置、硬件。优化效果：SQL语句和索引 &amp;lt; 数据库表结构 &amp;lt; 系统配置 &amp;lt; 硬件，成本也是递增的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL优化" scheme="http://daqwt.top/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎</title>
    <link href="http://daqwt.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
    <id>http://daqwt.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/</id>
    <published>2020-06-03T09:10:29.000Z</published>
    <updated>2020-06-12T09:13:39.544Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用的数据库引擎有两种，<strong>Innodb引擎</strong>和 <strong>MyIASM引擎</strong>，然而在不同的需求下，选取何种数据库引擎也是个问题。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>常用的数据库有两种引擎</li></ul><ol><li><strong>Innodb引擎</strong></li><li><strong>MyIASM引擎</strong></li></ol><ul><li>两种引擎所使用的索引的数据结构</li></ul><ol><li><strong>都是 B+ 树</strong></li><li>MyIASM引擎，B+ 树的数据结构中存储的内容实际上是<code>实际数据的地址值</code>。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为<code>非聚集索引</code>。</li><li>Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是<code>实际的数据</code>，这种索引有被称为<code>聚集索引</code>。</li></ol><h2 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h2><p>1、Innodb引擎提供了对数据库ACID事务的支持。 </p><p>2、并且还提供了行级锁和外键的约束。</p><p>3、它的设计的目标就是处理大数据容量的数据库系统。</p><p>4、它本身实际上是基于Mysql后台的完整的系统。</p><p>5、Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。</p><p>6、但是，该引擎是不支持全文搜索的。</p><p>7、同时，启动也比较的慢，它是不会保存表的行数的。</p><p>8、当进行<code>Select count(*) from table</code>指令的时候，需要进行扫描全表。</p><p>9、所以当需要使用数据库的事务时，该引擎就是首选。</p><p>10、由于锁的粒度小，写操作是不会锁定全表的。</p><p>11、所以在并发度较高的场景下使用会提升效率的。</p><h2 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h2><p>1、在5.1之前，MySql的默认引擎是MyIASM，之后是Innodb，MyIASM但不提供事务的支持，也不支持行级锁和外键。</p><p>2、因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。</p><p>3、所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。</p><p>4、所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将MyIASM作为数据库引擎的首先。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。</p></li><li><p>大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;常用的数据库引擎有两种，&lt;strong&gt;Innodb引擎&lt;/strong&gt;和 &lt;strong&gt;MyIASM引擎&lt;/strong&gt;，然而在不同的需求下，选取何种数据库引擎也是个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://daqwt.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>GC常见问题</title>
    <link href="http://daqwt.top/GC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://daqwt.top/GC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-02T09:07:31.000Z</published>
    <updated>2020-06-12T09:09:40.346Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于GC垃圾回收，有这些常见问题。</p><a id="more"></a><h2 id="（一）强引用、软引用、弱引用、虚引用"><a href="#（一）强引用、软引用、弱引用、虚引用" class="headerlink" title="（一）强引用、软引用、弱引用、虚引用"></a>（一）强引用、软引用、弱引用、虚引用</h2><ul><li><strong>强引用（Strong Reference）</strong></li></ul><ol><li>最普遍的引用：Object obj = new Object();</li><li>抛出OutOfMemoryError 终止程序也不会回收具有强引用的对象；</li><li>通过将对象设置为null来弱化引用，让它被回收</li></ol><ul><li><strong>软引用（soft reference）</strong></li></ul><ol><li>对象处在有用但非必须的状态</li><li>只有当内存空间不足时，GC会回收该引用的对象的内存</li><li>可实现高速缓存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(“abc”);</span><br><span class="line">SoftReference softRef = <span class="keyword">new</span> SoftReference(Str); <span class="comment">//软引用</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>弱引用WeakReference</strong></li></ul><p>1.非必须对象，比软引用更弱一些<br> 2.GC时会被回收<br> 3.被回收的概率也不大，因为GC线程优先级较低<br> 4.适用于引用偶尔被使用且不影响垃圾收集的对象       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(“abc”);</span><br><span class="line">WeakReference weakRefer = <span class="keyword">new</span> WeakReference(str);</span><br></pre></td></tr></table></figure><ul><li>虚引用PhantomReference</li></ul><ol><li>不会决定对象的生命周期</li><li>任何时候都可能被垃圾收集器回收</li><li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li><li>必须和引用队列ReferenceQueue联合使用    </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference ref = <span class="keyword">new</span> PhantoReference(“abc”,queue);</span><br></pre></td></tr></table></figure><h2 id="（二）GC的算法有哪些？怎么使用"><a href="#（二）GC的算法有哪些？怎么使用" class="headerlink" title="（二）GC的算法有哪些？怎么使用"></a>（二）GC的算法有哪些？怎么使用</h2><ul><li>常见的垃圾回收算法有：复制算法，标记清除算法，标记压缩算法。</li></ul><ol><li>因为新生代中对象存活率低，复制算法主要在新生代，在from区和to区之间的拷贝。因为是将内存划分为两部分，内存回收的时候，将存活下来的对象复制到另一半内存，这样只用一半内存，就会导致内存的浪费。</li><li>标记清除算法：是直接将标记的垃圾清除掉，并没有发生内存位置的移动，也就是没有整理内存，就会导致内存位置不连续，产生很多的内存碎片，利用不起来，就会导致内存利用率低下。</li><li>标记压缩算法：它是把后面存活的区域拷贝到垃圾区和空闲区，没有碎片，但是标记清除的过程中做了一次整理和压缩，导致效率偏低。对于拷贝来说，内存的拷贝是非常快的（就是一个线性地址的拷贝），但是压缩就不是那么容易了，因为任何一块内存在移动的时候，如果是多线程，就要进行线程同步，如果是单线程，那么效率就更低了。</li></ol><ul><li>所以，可以得出结论，没有好的算法，只有合适的算法，于是就有了内存分代模型，针对各个分区的特性，采用分代回收垃圾，现在的jvm采用的算法就是分代收集算法。</li></ul><ol start="4"><li>新生代：朝生夕灭的对象（例如：方法的局部变量等）。</li><li>老年代：存活得比较久，但还是要死的对象（例如：缓存对象、单例对象等）。</li><li>永久代：对象生成后几乎不灭的对象（例如：加载过的类信息）。</li></ol><ul><li>分代垃圾回收<br>堆大小=新生代+老年代，新生代与老年代的比例为1：2，新生代细分为一块较大的Eden空间和两块较小的Survivor空间，分别被命名为from和to。（<code>Edan：from：to=8:1:1</code>）</li></ul><h2 id="（三）轻GC和重GC什么时候会发生？"><a href="#（三）轻GC和重GC什么时候会发生？" class="headerlink" title="（三）轻GC和重GC什么时候会发生？"></a>（三）轻GC和重GC什么时候会发生？</h2><ul><li>轻GC（<code>Minor GC</code>）</li></ul><ol><li>Eden 空间占满， 触发 轻GC（<code>minor GC</code>），仍然存活的对象会被复制到 <code>S0 （survivor 0）</code>中去，这样 Eden 就被清空可以分配给新的对象。</li><li>又触发了一次 Minor GC ，S0 和 Eden 中存活的对象被复制到 S1 中，清空S0和 Eden区。默认情况下如果复制发生超过 16.次，JVM 会停止复制并把他们移到老年代中去。</li></ol><ul><li>重GC（<code>Full GC</code>）</li></ul><ol><li>老年代的空间被占满会触发老年代的Full GC。</li><li>Full GC 是一个压缩处理过程， 所以它比 Minor GC 要慢很多。</li><li>有如下原因可能导致Full GC：<br>年老代（Tenured）被写满；<br>持久代（Perm）被写满；<br>System.gc()被显示调用；<br>上一次GC之后Heap的各域分配策略动态变化</li></ol><h2 id="（四）常见的垃圾收集器有哪些？"><a href="#（四）常见的垃圾收集器有哪些？" class="headerlink" title="（四）常见的垃圾收集器有哪些？"></a>（四）常见的垃圾收集器有哪些？</h2><ul><li>新生代收集器</li></ul><p><strong>1. Serial</strong><br><strong>2. ParNew</strong><br><strong>3. Parallel Scavenge</strong></p><ul><li>老年代收集器</li></ul><p><strong>1. Serial Old</strong><br><strong>2. CMS</strong><br><strong>3. Parallel Old</strong></p><ul><li>堆内存垃圾收集器：G1</li></ul><p><strong>CMS(Concurrent Mark Sweep) 收集器</strong></p><ul><li>CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤：</li></ul><p>① 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。<br>② 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。<br>③ 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。<br>④ 并发清除：用标记-清除算法清除垃圾对象，耗时较长。</p><p>整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。</p><ul><li><strong>CMS 收集器也存在一些缺点：</strong></li></ul><ol><li>对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小</li><li>无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。</li><li>因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC。</li></ol><ul><li>适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关于GC垃圾回收，有这些常见问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="GC" scheme="http://daqwt.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC垃圾回收</title>
    <link href="http://daqwt.top/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://daqwt.top/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-06-01T09:04:00.000Z</published>
    <updated>2020-06-12T09:08:15.227Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于GC垃圾回收，有很多算法。复制算法，标记清除算法，标记整理算法，以及最终的分代垃圾回收算法。</p><a id="more"></a><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ul><li>没有任何引用指向的一个对象或者多个对象（循环引用）</li><li>各语言的垃圾回收机制：</li></ul><ol><li>C语言中：malloc - free</li><li>C++中：new - delete</li><li>Java中： 自动内存回收，编程上简单，系统不容易出错。</li></ol><ul><li>JVM在进行GC时，并不是对这三个区域进行统一回收，大部分时候，回收的都是新生代</li><li>GC两种：轻GC（普通的GC），重GC（全局GC）</li></ul><ul><li><strong>如何定位垃圾</strong></li></ul><ol start="4"><li><code>引用计数算法（reference count）</code><br>在一个对象上记录一个数字，记录到底有多少引用指向他，记录值为0的时候，这个对象就变成垃圾了。但是如果三个垃圾对象互相引用，这就形成了循环引用，他们的记录值都是1，用这种算法就找不出这三个垃圾，就会造成内存泄漏。</li><li><code>根可达算法（Root Searching）</code>——-常用<br>通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li></ol><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>1.<strong>标记清除 - 位置不连续 产生碎片</strong></p><p><img src="https://img-blog.csdnimg.cn/20200416165038212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><p>2.<strong>拷贝算法 - 没有碎片，浪费空间</strong></p><p><img src="https://img-blog.csdnimg.cn/20200416165729984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h3><p>3.<strong>标记压缩 - 没有碎片，标记清除的过程中做了一次整理和压缩，但是效率偏低、</strong></p><p><img src="https://img-blog.csdnimg.cn/20200416170336371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4.<strong>为什么效率不高呢？</strong><br>因为对于拷贝来说，内存的拷贝是非常快的（就是一个线性地址的拷贝），但是压缩就不是那么容易了，因为任何一块内存在移动的时候，如果是多线程，就要进行线程同步，如果是单线程，那么效率就更低了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法<br>内存整齐度：复制算法&gt;标记压缩算法&gt;标记清除算法<br>内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p><ul><li>有最优的算法吗？<br>没有最好的算法，只有最合适的算法—&gt;GC分代收集算法</li><li><strong>年轻代</strong>：存活率低，复制算法</li><li><strong>老年代</strong>：区域大，标记清除（内存碎片不是太多）+标记压缩混合算法实现</li></ul><h2 id="JVM内存分代模型（用于分代垃圾回收算法"><a href="#JVM内存分代模型（用于分代垃圾回收算法" class="headerlink" title="JVM内存分代模型（用于分代垃圾回收算法)"></a>JVM内存分代模型（用于分代垃圾回收算法)</h2><ol><li>新生代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace</li><li>永久代 元数据 中装各种各样的Class对象</li><li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li><li>字符串常量 在1.7中存在于永久代，在1.8中存于堆。</li><li>MethodArea就是一个逻辑概念 - 就是永久代或者元数据。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关于GC垃圾回收，有很多算法。复制算法，标记清除算法，标记整理算法，以及最终的分代垃圾回收算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="GC" scheme="http://daqwt.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM常见问题</title>
    <link href="http://daqwt.top/JVM%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://daqwt.top/JVM%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-29T08:59:30.000Z</published>
    <updated>2020-06-12T09:03:23.058Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM常见的问题</p><a id="more"></a><h2 id="一-JVM内存模型和分区，每个分区放什么？"><a href="#一-JVM内存模型和分区，每个分区放什么？" class="headerlink" title="(一)JVM内存模型和分区，每个分区放什么？"></a>(一)JVM内存模型和分区，每个分区放什么？</h2><ul><li>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念。java内存模型中分为<code>主内存</code>和<code>工作内存</code>，<code>主内存</code>可粗略认为是<code>堆</code>，<code>工作内存</code>认为是<code>栈</code>。</li><li>主内存里面存储着所有变量，属于共享内存区域，所有线程都可以访问。</li><li>每一个线程都私有一个<code>工作内存</code>，保存着主内存里面变量值的副本，线程对变量的操作都是在工作内存中完成，操作结束后再放回主内存。</li><li>操作系统中，一般CPU都会从内存取数据到寄存器，然后进行处理，但由于内存的处理速度远远低于CPU，导致CPU在处理指令时往往花费很多时间在等待内存做准备工作，于是在寄存器和主内存间添加了CPU缓存，CPU缓存比较小，但访问速度比主内存快得多。所以Java虚拟机在程序执行过程会把jvm的内存分为若干个不同的数据区域。有：堆，栈，方法区，程序计数器，本地方法栈</li></ul><ol><li><strong>堆：</strong> 类，方法，常量，变量，保存我们所有引用类型的真实对象。</li><li><strong>栈：</strong> 八种基本类型变量+对象的引用变量，栈操作，栈帧数据。</li><li><strong>方法区：</strong> 静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。方法区存储了每一个类的结构信息，就是模板的意思。</li><li><strong>程序计数器：</strong> 可以简单理解为一个指针，里面存的就是下一个将要执行的的方法的指针。</li><li><strong>本地方法栈：</strong> 装native方法专用的栈，这是一个特殊的栈<code>JNI</code></li></ol><ul><li>补充：常量池在1.7中处于永久代，但在1.8中，处于堆中，因为1.8中，永久代变成了元空间，但是元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，所以可以通过参数调优来指定元空间的大小。</li></ul><h2 id="二-堆里面的分区以及特点。"><a href="#二-堆里面的分区以及特点。" class="headerlink" title="(二)堆里面的分区以及特点。"></a>(二)堆里面的分区以及特点。</h2><ul><li><p>堆里面分为新生代和老生代（java8取消了永久代，采用了元空间<code>Metaspace</code>），新生代包含伊甸园区和幸存区<code>Eden+Survivor</code>区，survivor区里面分为from和to区，内存回收时，在新生代使用的是复制算法，从from复制到to，当经过一次或者多次GC之后，存活下来的对象会被移动到老年区，当JVM内存不够用的时候，会触发重GC（Full GC），清理JVM老年区。</p></li><li><p>当新生区满了之后会触发YGC,先把存活的对象放到其中一个Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden 进行完全的清理，然后整理内存。那么下次GC 的时候，就会使用下一个Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为JVM 认为，一般大对象的存活时间一般比较久远。</p></li><li><p><strong>补充：</strong> 1.7之前新生代和老年代都在java堆，永久代在方法区，1.8之后变换为元空间，元空间使用本地内存。</p></li></ul><h2 id="三-如何解决OOM问题？"><a href="#三-如何解决OOM问题？" class="headerlink" title="(三)如何解决OOM问题？"></a>(三)如何解决OOM问题？</h2><ul><li><p><strong>内存泄露：</strong> 申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人使用。</p></li><li><p><strong>内存溢出：</strong> 申请的内存超出了JVM能提供的内存大小，此时称之为溢出。</p></li><li><p>用来存放JDK自身携带的Class对象，Interface元数据，存储的是java运行时的一些环境或者类信息，这个区域不存在垃圾回收，关闭JVM虚拟机会释放这个区域的内存。<br>例如：一个启动类，加载了大量的第三方jar包，Tomcat部署了太多的应用，大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM</p></li><li><p><code>OutOfMemory</code>出现的原因：</p></li></ul><ol><li>分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</li><li>应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。</li></ol><ul><li>如何解决?</li></ul><ol start="3"><li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler工具</li><li>Dubug，一行行分析代码。(效率低下)</li></ol><ul><li><strong>MAT，JProfiler</strong> 的作用：</li></ul><p>1.分析Dump文件，快速定位内存泄漏</p><p><code>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms 设置初始化内存分配大小</span><br><span class="line">-Xmx 设置最大分配内存，默认<span class="number">1</span>/<span class="number">4</span></span><br><span class="line">-XX：+PrintGCDetails  打印GC垃圾回收信息</span><br><span class="line">-XX：+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p>2.获得堆中的数据<br>3.获得大的对象</p><h2 id="四-堆内存调优"><a href="#四-堆内存调优" class="headerlink" title="(四)堆内存调优"></a>(四)堆内存调优</h2><ul><li>默认情况下，分配的总内存，是电脑的1/4，而初始化的内存是1/16</li></ul><p><img src="https://img-blog.csdnimg.cn/20200604220521514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在配置中修改参数语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200604222150449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="五-元空间调优"><a href="#五-元空间调优" class="headerlink" title="(五)元空间调优"></a>(五)元空间调优</h2><ul><li>元空间虚拟机控制元空间的增长。但是有些时候我们想限制其增长，比如通过显式在命令行中设置-XX:MaxMetaspaceSize。默认情况下，-XX:MaxMetaspaceSize的值没有限制，因此元空间甚至可以延伸到交换区，但是这时候当我们进行本地内存分配时将会失败。</li><li>对于一个64位的服务器端JVM来说，其默认的<code>–XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线。一旦触及到这个水位线，Full GC将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。如果初始化的高水位线设置过低， 上述高水位线调整情况会发生很多次。通过垃圾回收器的日志我们可以观察到Full GC多次调用。为了避免频繁的GC，可以将<code>–XX:MetaspaceSize</code>设置为一个相对较高的值。</li><li>经过多次GC之后，元空间虚拟机自动调节高水位线，以此来推迟下一次垃圾回收到来。有这样两个选项 <code>XX:MinMetaspaceFreeRatio</code>和<code>XX:MaxMetaspaceFreeRatio</code>，他们类似于GC的FreeRatio选项，用来设置元空间空闲比例的最大值和最小值。我们可以通过命令行对这两个选项设置对应的值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JVM常见的问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="JVM" scheme="http://daqwt.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>类的加载过程详解</title>
    <link href="http://daqwt.top/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://daqwt.top/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-28T08:56:01.000Z</published>
    <updated>2020-06-12T08:58:55.383Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载过程可以分为：加载，验证，准备，解析，初始化。</p><a id="more"></a><h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><p><img src="https://img-blog.csdnimg.cn/20200516134009962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="https://img-blog.csdnimg.cn/20200516134537454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>加载：</strong> 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，<strong>并通过反射生成一个代表这个类的Class对象</strong>。</li><li><strong>链接：</strong> 将java类的二进制代码合并到JVM的运行状态之中</li></ul><ol><li>验证：确保加载的类信息符合jvm规范，没有安全方面的问题。</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ol><ul><li><strong>初始化：</strong></li></ul><ol><li>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,类构造器<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（<strong>类构造器是构造类信息的，不是构造该对象的构造器</strong>）</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁和同步</li></ol><p><img src="https://img-blog.csdnimg.cn/20200516142155751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器有哪些？</li></ul><ol><li><strong>引导类加载器</strong>：C++编写，是JVM自带的类加载器，负责加载java平台核心库<code>rt.jar</code>,<strong>该加载器无法直接获取</strong>。</li><li><strong>扩展类加载器（EXT）</strong>：负责<code>jre/lib/ext</code>目录下的jar包，以及我们引进的jar包。</li><li><strong>系统类加载器（APP）</strong>： 负责<code>java-classpath</code>或<code>java.class.path</code>所指的目录下的类与jar包装入，是最常用的加载器。</li></ol><ul><li>获取：<code>类.getClassLoader();</code></li><li>作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的class对象，作为方法中类访问数据的入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些class对象<br><img src="https://img-blog.csdnimg.cn/20200516144741630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2></li><li>类的主动引用（<strong>一定会发生类的初始化</strong>）</li></ul><ol><li>虚拟机启动，先初始化main方法所在的类。</li><li>new一个类的对象</li><li>调用类的静态成员和静态方法。</li><li>使用反射调用</li><li>初始化一个类，要先初始化其父类。</li></ol><ul><li>类的被动引用（<strong>不会发生类的初始化</strong>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;类的加载过程可以分为：加载，验证，准备，解析，初始化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="JVM" scheme="http://daqwt.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM---体系结构（二）</title>
    <link href="http://daqwt.top/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://daqwt.top/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-27T08:48:23.000Z</published>
    <updated>2020-06-12T08:55:22.085Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于对象生命周期的问题，以及常见的对内存调优的问题。以及分析问题原因。</p><a id="more"></a><h2 id="HotSpot和堆"><a href="#HotSpot和堆" class="headerlink" title="HotSpot和堆"></a>HotSpot和堆</h2><ul><li>堆<br>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的<br>类加载器读取了类文件之后，一般会把什么放到堆中？<br>类，方法，常量，变量，保存我们所有引用类型的真实对象。</li><li>堆内存还要细分为三个区域</li></ul><ol><li>新生区（伊甸园区）</li><li>养老区</li><li>永久区</li></ol><ul><li><p>GC垃圾回收，主要是在伊甸园区和养老区<br>假设内存满了，OOM，堆内存不够，<code>java.lang.OutOfMemoryError: java heap space</code><br>在jdk8之后，永久存储区改了个名字（元空间）。</p></li><li><p><strong>新生区</strong><br>类诞生，成长，甚至死亡的地方</p></li></ul><ol><li>伊甸园区 所有的对象都是在伊甸园区new出来的</li><li>幸存者区（0，1）</li><li>真理，经过研究，99%的对象就是临时对象。</li></ol><ul><li><strong>永久区</strong><br>这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据，存储的是java运行时的一些环境或者类信息，这个区域不存在垃圾回收，关闭JVM虚拟机会释放这个区域的内存。<br>一个启动类，加载了大量的第三方jar包，Tomcat部署了太多的应用，大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM</li></ul><h2 id="对象生命周期和GC"><a href="#对象生命周期和GC" class="headerlink" title="对象生命周期和GC"></a>对象生命周期和GC</h2><p><img src="https://img-blog.csdnimg.cn/20200218164154897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>幸存区0–S0—from<br>幸存区1–S1—to<br>from区和to区，他们的位置和名分不是固定的（都只占新生代区的1/10），每次GC后会交换<br>也就是说：<strong>GC之后有交换，谁空谁是to</strong></p><ul><li>只要产生GC，伊甸园区必须全部清空</li></ul><h2 id="堆内存调优"><a href="#堆内存调优" class="headerlink" title="堆内存调优"></a>堆内存调优</h2><ul><li>默认情况下，分配的总内存，是电脑的1/4，而初始化的内存是1/16</li></ul><p><img src="https://img-blog.csdnimg.cn/20200604220521514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">- 在配置中修改参数语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200604222150449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="使用Jprofiler工具分析OOM原因"><a href="#使用Jprofiler工具分析OOM原因" class="headerlink" title="使用Jprofiler工具分析OOM原因"></a>使用Jprofiler工具分析OOM原因</h2><ul><li>在一个项目中，突然出现OOM故障，那么该如何排查错误？</li></ul><ol><li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler工具</li><li>Dubug，一行行分析代码。</li></ol><p><strong>MAT，Jprofiler</strong>作用</p><ul><li>分析Dump文件，快速定位内存泄漏<br><code>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms 设置初始化内存分配大小</span><br><span class="line">-Xmx 设置最大分配内存，默认<span class="number">1</span>/<span class="number">4</span></span><br><span class="line">-XX：+PrintGCDetails  打印GC垃圾回收信息</span><br><span class="line">-XX：+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><ul><li>获得堆中的数据</li><li>获得大的对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关于对象生命周期的问题，以及常见的对内存调优的问题。以及分析问题原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="JVM" scheme="http://daqwt.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM---体系结构（一）</title>
    <link href="http://daqwt.top/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://daqwt.top/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-26T08:48:23.000Z</published>
    <updated>2020-06-12T08:53:16.462Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。这也就是一次编写，到处执行的原因。</p><a id="more"></a><h2 id="体系结构概览"><a href="#体系结构概览" class="headerlink" title="体系结构概览"></a>体系结构概览</h2><p><img src="https://img-blog.csdnimg.cn/2020060415501136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><ul><li>java源文件通过javac编译成java字节码文件.class</li><li>.class文件打开，他的开头是cafe babe，所以虚拟机才能识别</li><li>通过类加载器ClassLoader加载.class文件，将class文件放入内存中各个区域</li><li>程序计数器、JAVA栈、本地方法栈是线程独有的，不受GC管理。栈中是没有垃圾的因为栈用完自动释放。</li><li>堆里面垃圾最多、方法区中有少量垃圾。受GC管理</li><li>所谓的JVM调优，就是针对堆和方法区。</li><li>方法区里面并不是方法，而是类的模版。</li><li>java8 方法区又称为非堆区，在内存结构中称为“元数据”。</li><li>灰色部分，是线程私有的，占用内存非常少，几乎不存在GC垃圾回收。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="https://img-blog.csdnimg.cn/20200215203005783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>问：什么是类加载器？</strong></p><ul><li>类加载器是用来加载类（class文件）的</li><li>类加载器也是一个类：ClassLoader</li><li>类加载器可以被加载到内存，也是通过类加载器完成的</li></ul><p><strong>问：类加载器有哪几种？</strong></p><ul><li><input disabled="" type="checkbox"> 系统自带的有三种：</li><li>启动类（根）加载器（BootStrap） C++写的，java程序获取不到</li><li>扩展类加载器（Extension） Java写的</li><li>应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类。</li><li><input disabled="" type="checkbox"> 用户自定义加载器：</li><li>Java.lang.ClassLoader的子类，用户可以定制类的加载方式。</li></ul><p><strong>问：什么叫双亲委派机制？</strong></p><ul><li>浅显理解：我爸是李刚，有事儿找我爹，要用到某个类，先去根加载器中找，找的到就用，如果找不到，再去扩展类加载器中找，还是没有，就去应用程序类加载器中找。</li><li>步骤：<ol><li>类加载器收到类加载的请求</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，知道启动类加载器</li><li>启动加载器检查是否能加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子类进行加载。（ClassNotFound）</li><li>重复步骤3</li></ol></li></ul><p><img src="https://img-blog.csdnimg.cn/20200604155105326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> <strong>问：沙箱安全机制是什么？</strong></p><ul><li>java安全的核心就是沙箱，沙箱就是限程序运行的环境，只能在jvm限定范围内运行，并且严格控制代码对本地系统资源的访问。</li><li>沙箱安全机制是由基于双亲委派机制上 采取的一种JVM的自我保护机制,假设你要写一个java.lang.String 的类,由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类,因此就保证了java的运行机制不会被破坏.</li></ul><p><strong>问：为什么有沙箱安全机制？</strong></p><ul><li>防止恶性代码污染源代码</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p><img src="https://img-blog.csdnimg.cn/20200604194302355.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><ul><li>进程线程这种概念是<strong>系统级的</strong>，不是语言级的。</li><li>看源码后，只要方法前加上了<strong>native</strong>，说明这是一个跟java无关的<strong>要调底层操作系统或者是第三方C语言函数库的方法</strong>，java搞不定，需要别的系统和语言提供方法来介入，需要求助于外援。</li><li>本地方法栈（Native Method Stack）：装native方法专用的栈，这是一个特殊的栈—（Native栈）</li><li><code>JNI（java native interface）</code>：扩展java的使用，融合不同的编程语言为java所用。</li></ul><p> 问： 为什么源码中会有native方法的声明，却没有实现呢（实现交给了底层的第三方函数库来实现）？</p><ul><li><strong>因为Java诞生初期，1995年10月，那个时候最盛行的语言是C语言，相当于老大，每个语言需要向他交保护费（Java要留出一个接口向C语言妥协），所以有了native。</strong></li></ul><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>程序计数器（<code>Program Counter Register</code>）</p><ul><li>简单理解：就是一个指针，一个方法运行完了，指向下一个方法。</li><li>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中方法字节码（用来存储指向一条指令的地址，也就是即将要执行的指令代码）,在执行引擎读取下一条指令的时候，是一个非常小的空间，几乎可以忽略不计，</li><li>PC寄存器：里面存的就是下一个将要执行的的方法的指针。<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2></li><li>方法区就是被所有的线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在这个区域，<strong>此区域属于共享空间</strong>。</li><li><strong>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。</strong></li><li>static ，final，Class，常量池。<ul><li>方法区存储了每一个类的结构信息，就是模板的意思。</li><li>就是一套规范，在不同的虚拟机里头实现是不一样的，最典型的就是永久代（PermGen space）和元空间（Metaspace）</li></ul></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>栈也叫栈内存，主管java程序的运行，是在线程创建的时候创建，他的生命周期也就是线程的生命周期，线程结束，栈内存释放，对于栈来说，不存在垃圾回收问题，线程一结束，栈就释放了，</li><li><strong>栈中存储的有</strong>：</li></ul><ol><li>本地变量：八种基本类型变量+对象的引用变量。</li><li>栈操作：记录出栈，入栈的操作。</li><li>栈帧数据：包含类文件，方法等。。。</li></ol><p><strong>栈帧结构：</strong></p><ul><li>方法索引</li><li>输入输出参数</li><li>本地变量</li><li>Class File引用</li><li>父帧</li><li>子帧</li></ul><p><img src="https://img-blog.csdnimg.cn/2020021612202191.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><ul><li>java方法进入虚拟机之后，就成为了<strong>栈帧</strong></li><li>Main方法是一切程序的入口，它永远被压在栈底。</li><li>递归调用：不断地往栈中压自身的方法，由于栈内存有限，会导致栈溢出，出现StackOverflowError，它是Error错误，不是异常。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="https://img-blog.csdnimg.cn/20200216155647942.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200216155717632.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：</strong></p><ul><li>java 7之前堆内存：新生代，老年代，永久区</li><li>java 8以后堆内存：新生代，老年代，元空间</li><li>一个堆空间物理上分为新生代，老年代两部分，逻辑上分为新生代，老年代，元空间三部分。</li></ul><h2 id="栈-堆-方法区的交互关系"><a href="#栈-堆-方法区的交互关系" class="headerlink" title="栈+堆+方法区的交互关系"></a>栈+堆+方法区的交互关系</h2><p><img src="https://img-blog.csdnimg.cn/20200604203823961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>HotSpot是使用指针的方式来访问对象，java堆中会存放<code>类元数据</code>的地址，reference存储的就直接是对象的地址。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。这也就是一次编写，到处执行的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM虚拟机和GC垃圾回收" scheme="http://daqwt.top/categories/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="JVM" scheme="http://daqwt.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>多线程常见问题</title>
    <link href="http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-25T08:45:21.000Z</published>
    <updated>2020-06-12T08:52:44.102Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录多线程出现的常见问题。</p><a id="more"></a><h2 id="并发编程三概念"><a href="#并发编程三概念" class="headerlink" title="并发编程三概念"></a>并发编程三概念</h2><ul><li><strong>原子性：</strong> 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li><strong>可见性：</strong>  当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li><strong>有序性：</strong> 程序执行的顺序按照代码的先后顺序执行。（指令优化，指令重排是指互不依赖的指令会进行重排，优化计算）</li><li><strong>补充：</strong> Java内存模型具备一些先天的<code>有序性</code>，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 <code>happens-before</code> 原则（先行发生原则）。如果两个操作的执行次序无法从<code>happens-before</code>原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。—–出自《深入理解Java虚拟机》</li></ul><h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><ul><li>保证线程安全以是否需要同步手段分类，分为<code>同步方案</code>和<code>无需同步方案</code>。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200607103910621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><ul><li><p>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p></li><li><p><code>synchronized</code>关键字：最基本的互斥同步手段，<code>synchronized</code>关键字编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。</p></li><li><p><code>ReentrantLock</code>：在基本用法上，<code>ReentrantLock</code>与<code>synchronized</code>很相似，他们都具备一样的线程重入特性。</p></li><li><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p></li></ul><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><ul><li><p>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p></li><li><p>非阻塞的实现<code>CAS（compareandswap）</code>：CAS指令需要有3个操作数，分别是<code>内存地址</code>（在java中理解为变量的内存地址，用V表示）、<code>旧的预期值</code>（用A表示）和<code>新值</code>（用B表示）。CAS指令执行时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p></li><li><p>CAS缺点：<br><strong>ABA问题：</strong> 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p> <strong>使用版本号解决ABA问题：</strong> 在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p> <strong>性能消耗大：</strong> 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p>JUC对原子类有一个优化，<code>LongAdder</code>，热点分散，类似于分治。是CAS优化的地方。</p></li></ul><h3 id="无需同步方案"><a href="#无需同步方案" class="headerlink" title="无需同步方案"></a>无需同步方案</h3><ul><li><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。</p><p><strong>1. 可重入代码</strong></p></li><li><p>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p></li><li><p>可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。</p><ul><li>（类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）</li></ul></li></ul><p><strong>2. 线程本地存储</strong></p><ul><li><p>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。</p></li><li><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。</p></li></ul><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><ul><li>synchronized能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。以此可以保证可见性。</li><li>对象在内存中的布局包括三部分：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充数据</strong>。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020060711403170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>其中，对象头是实现Synchronized的锁对象的基础。当给对象加锁的时，数据是存储在对象头中。当执行Synchronized同步方法或者同步代码块的时候，会在对象头中记录锁标记，锁标记指向的是monitor对象（也称为管道或者监视器锁）。</p><ol><li><p><strong>同步代码块</strong> 的实现是基于虚拟机的指令<code>monitorenter</code>和<code>monitorexit</code>指令。<code>monitorenter</code>指令插入到同步代码块的开始位置，<code>monitorexit</code>指令插入到同步代码块的结束位置，JVM需要保证每一个<code>monitorenter</code>都有一个<code>monitorexit</code>与之相对应。任何对象都有一个<code>monitor</code>与之相关联，当且一个<code>monitor</code>被持有之后，他将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>所有权，即尝试获取对象的锁.。</p></li><li><p><strong>同步方法</strong> 的实现则是通过对象头实现的访问标志位为基础。synchronized方法会被翻译成普通的方法调用和返回指令，如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，<code>而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1</code>，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Class做为锁对象。</p></li><li><p><strong>锁升级的过程</strong><br>在jdk1.6的时候有了锁升级，</p></li></ol><ul><li><strong>无锁：</strong> 没有锁</li><li><strong>偏向锁：</strong> 有一个资源，线程去申请，并且申请到了这个锁，并且没有其他线程去争抢这个锁，当他执行同步代码块的时候，就没有必要去释放这个锁了，因为释放锁的过程需要从用户态转到内核态，是需要消耗很多资源。为了提高性能就引入了这个偏向锁。如果有两个资源去争夺这个锁，他就会升级到轻量级锁。</li><li><strong>轻量级锁：</strong><br>用CAS，先去判断能否将这个锁抢到，如果抢不到，就进行自旋操作，还是没有办法获取到这个锁，那么就升级到重量级锁。</li><li><strong>重量级锁：</strong><br>用管程实现的，就完全阻塞了。</li></ul><h2 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h2><ul><li><p>synchronized是Java内置的机制，是JVM层面的，而Lock则是接口，是JDK层面的。</p></li><li><p>Java中的锁大致分为：偏向锁、轻量级锁、重量级锁、自旋锁（锁只能升级，不能降级）</p></li><li><p><strong>偏向锁、轻量级锁、重量级锁</strong>：<br>这三种锁是指锁的状态，并且是针对Synchronized，在Java 5通过引入锁升级的机制来实现高效Synchronized，这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价；轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能；重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p></li><li><p><strong>自旋锁：</strong><br>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p></li><li><p><strong>可重入锁：</strong><br>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。 在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。</p></li><li><p><strong>乐观锁、悲观锁：</strong><br>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200607114605128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="voliate关键字"><a href="#voliate关键字" class="headerlink" title="voliate关键字"></a>voliate关键字</h2><ul><li><code>synchronized</code>是阻塞同步的，在线程竞争激烈的情况下会升级为重量级锁。而voliate就可以说是java虚拟机提供的<code>最轻量级的同步锁</code>。</li><li>voliate关键字主要有两个作用：</li></ul><p><strong>1. 保证可见性</strong><br><strong>2. 禁止进行指令重排序。</strong></p><ul><li><strong>可见性如何保证：</strong> 各个线程会将共享变量从主内存拷贝到工作内存，然后执行引擎会基于工作内容中的数据进行操作处理。那么线程在工作内存进行操作后何时会写到主内存中？这个时机对于普通变量是没有规定的，而针对<code>voliate</code>修饰的变量给java虚拟机特殊的约定，线程对voliate变量的修改会立即被其他线程感知，在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock指令。也就是说，我一旦修改了该变量，就会立马通知其他线程，修改后的值，具体就是这个写回内存的操作会使得其他缓存了该内存地址的数据无效。</li><li><strong>有序性如何保证：</strong> </li></ul><ol><li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。</p></li><li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p></li></ol><h2 id="interrupt，interrupted，isInterrupted"><a href="#interrupt，interrupted，isInterrupted" class="headerlink" title="interrupt，interrupted，isInterrupted"></a>interrupt，interrupted，isInterrupted</h2><ul><li><strong>interrupt方法用于中断线程。</strong> 调用interrupt()方法来停止线程，<strong>不会马上终止</strong></li></ul><p><strong>注意：</strong> 它仅仅是在当前的线程中打了一个停止的标记。即不会影响线程的正常运行，只是该线程多了一个停止的标记而已。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为<code>中断状态</code>，就会抛出中断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">           checkAccess();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">           Interruptible b = blocker;</span><br><span class="line">           <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">               interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">               b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       interrupt0();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>interrupted 和 isInterrupted</strong> </li></ul><p>1.先看<code>interrupted ()</code>方法，该方法就是直接调用当前线程的<code>isInterrupted(true)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.再来看<code>isInterrupted(true)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> <code>interrupted</code> 是作用于当前线程，<code>isInterrupted</code> 是作用于调用该方法的线程对象所对应的线程。（线程对象对应的线程不一定是当前运行的线程。例如我们可以在A线程中去调用B线程对象的isInterrupted方法。）这两个方法最终都会调用同一个方法，只不过参数一个是true，一个是false。</p><h2 id="notyfy和notifyAll的区别"><a href="#notyfy和notifyAll的区别" class="headerlink" title="notyfy和notifyAll的区别"></a>notyfy和notifyAll的区别</h2><ul><li><strong>notify：</strong> 只随机唤醒一个 wait 线程，被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池。</li><li><strong>notifyAll：</strong> 将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li><li>notify可能会导致死锁，而notifyAll则不会。</li><li>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。</li></ul><h2 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h2><ul><li><code>ThreadLocal</code>是线程本地存储，在每个线程中都创建了一个 <code>ThreadLocalMap</code> 对象，每个线程可以访问自己内部 <code>ThreadLocalMap</code> 对象内的 <code>value</code>。</li><li>Map的<code>key是ThreadLocal类的实例对象</code>，<code>value为用户的值</code>，</li><li><strong>ThreadLocal父子线程之间是不可以继承</strong>，因为当线程中开启了其他的线程，此时ThreadLocal里面的数据将会出现无法获取／读取错乱，甚至还可能会存在内存泄漏等问题，但是通过<code>InheritableThreadLocal</code>（<strong>ThreadLocal的子类）</strong> 这个组件可以实现父子线程之间的数据传递，在子线程中能够父线程中的ThreadLocal本地变量。</li><li>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</li></ul><p><strong>1. JDK 的实现里面这个 Map 是属于 Thread，而非属于 ThreadLocal。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal 仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在 Thread 里面。ThreadLocalMap 属于 Thread 也更加合理。<br><strong>2. 还有一个更加深层次的原因，这样设计不容易产生内存泄露。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal 持有的 Map 会持有 Thread 对象的引用，只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往比线程要长，所以这种设计方案很容易导致内存泄露。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以在JDK 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用（WeakReference），所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。JDK 的这种实现方案复杂但更安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;记录多线程出现的常见问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---多线程（三）</title>
    <link href="http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-05-22T14:35:35.000Z</published>
    <updated>2020-06-03T14:45:54.845Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于线程的锁问题，使得我们在编写程序的过程中，更加安全高效的使用线程。</p><a id="more"></a><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>多个线程一起占有共享资源，并且都在等待其他线程释放资源，你等我，我等你，某一个同步块同时拥有<code>两个以上对象的锁</code>时，就可能会发生死锁问题。</li><li><strong>产生死锁的必要条件：</strong></li></ul><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对方获得的资源保持不放。</li><li>不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><ul><li><p><strong>我们只要想办法破坏其中一个条件就可以避免死锁。</strong></p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2></li><li><p>JDK1.5之后出来，提供了更强大的线程同步机制—通过显示定义同步锁对象来实现同步，同步锁使用<code>Lock</code>对象充当。</p></li><li><p><code>java.util.concurrent.locks.lock</code>接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对<code>Lock</code>对象加锁，线程开始访问共享资源之前要先获得<code>Lock</code>对象。</p></li><li><p><code>ReentrantLock</code>类实现了<code>Lock</code>，他拥有与<code>synchronized</code>相同的并发性和内存语义，在实现线程安全控制中，比较常用的是<code>ReentrantLock</code>可以显示的加锁，释放锁。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200603214229136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="synchronized与lock的区别"><a href="#synchronized与lock的区别" class="headerlink" title="synchronized与lock的区别"></a>synchronized与lock的区别</h2><ul><li><code>Lock</code>是显示锁（手动开启和关闭锁，别忘记关闭锁）<code>synchronized</code>是隐式锁，出了作用域自动释放。</li><li><code>Lock</code>只有代码快锁，<code>synchronized</code>有代码块锁和方法锁。</li><li>使用<code>Lock</code>锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）</li><li><strong>优先使用顺序：</strong></li></ul><p><code>Lock</code>—-同步代码块（已经进入了方法体，分配了相应资源）—-同步方法（在方法体之外）</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><ul><li>生产者和消费者共享同一个资源，二者之间互相依赖。互为条件。</li></ul><ol><li>对于生产者，没有生产产品之前，要通知消费者等待，生产好了之后，要立马通知消费者来取，</li><li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li><li>在生产者消费者问题中，仅仅有synchronized是不够的</li></ol><p><code>synchronized</code>可阻止并发更新同一个共享资源，实现了同步。<br><code>synchronized</code>不能用来实现不同线程之间的消息传递（通信）</p><p><img src="https://img-blog.csdnimg.cn/20200603215725185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h2><p><img src="https://img-blog.csdnimg.cn/20200603220504358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>经常创建和销毁的，使用量特别大的资源，比如并发情况下的线程，对性能影响很大，</li><li>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建和销毁，实现重复利用，类似生活中的交通工具。</li><li><strong>使用线程池的好处：</strong></li></ul><ol><li>提高响应速度（减少了创建线程的时间）。</li><li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</li><li>便于线程管理：<code>corePoolSize</code>：核心池的大小，<code>maximumPoolSize</code>：最大线程数，<code>KeepAliveTime</code>：线程没有任务时，最多保持多长时间后会终止。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关于线程的锁问题，使得我们在编写程序的过程中，更加安全高效的使用线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---多线程（二）</title>
    <link href="http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-05-21T14:35:35.000Z</published>
    <updated>2020-06-03T14:43:51.484Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这章深入线程，了解一些线程状态以及常用的方法，以及线程同步的安全问题。</p><a id="more"></a><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><ul><li>真实对象和代理对象都要实现同一接口</li><li>代理对象要代理真实角色</li><li>代理对象可以做很多真实对象做不了的事情</li><li>真实对象专注做自己的事情</li><li><strong>它是线程底部的实现原理</strong>，你只用<code>start()</code>,<code>run()</code>交给JVM</li></ul><h2 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h2><ul><li>目的是为了<strong>避免内部类定义过多</strong></li><li>其实质是属于函数式编程的概念</li></ul><ol><li><code>(parms)-&gt;expression[表达式]</code></li><li><code>(parms)-&gt;statement[语句]</code></li><li><code>(parms)-&gt;{statements}</code></li></ol><ul><li>例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  Thread(()-&gt; System.out.println(<span class="string">"代澳旗，加油！"</span>)).start();</span><br></pre></td></tr></table></figure><ul><li><code>lamda</code>表达式的关键：函数式接口<br>函数式接口：只包含一个抽象方法，<strong>只有一个！！！</strong><br>对于函数式接口，我们可以通过<code>lamda</code>表达式来创建该接口的对象</li></ul><h2 id="线程五大状态"><a href="#线程五大状态" class="headerlink" title="线程五大状态"></a>线程五大状态</h2><ul><li>五大状态：<strong>创建，就绪，阻塞，运行，死亡</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/202006031559414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="线程常见方法"><a href="#线程常见方法" class="headerlink" title="线程常见方法"></a>线程常见方法</h2><p><img src="https://img-blog.csdnimg.cn/20200603160133458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p><strong>线程停止</strong></p><ol><li>建议线程正常停止—&gt;利用次数，不建议无限循环</li><li>建议使用标志位—&gt;设置一个标志位</li><li>不要使用stop或者destory等过时或者JDK不建议使用的方法</li></ol></li><li><p><strong>线程休眠（sleep）</strong></p></li></ul><ol><li><code>sleep(时间)指定当前线程阻塞的毫秒数</code></li><li>存在异常<code>InterruptedException</code></li><li><code>sleep</code>时间到后进入就绪状态</li><li>可以模拟网络延时，倒计时</li><li>每个对象都有一把锁，sleep不会释放锁。</li></ol><ul><li><strong>线程礼让（yield）</strong></li></ul><ol><li>让当前正在执行的线程暂停，但不阻塞</li><li>让线程从运行状态转为就绪状态</li><li><strong>让cpu重新调度，礼让不一定成功，看CPU心情</strong></li><li>我本来都要准备运行了，出于礼貌。我重新出来，咱两重新竞争。所以有可能还是我抢赢了。</li></ol><ul><li><strong>线程强制执行（join）</strong></li></ul><ol><li><p>霸道，强制执行，少使用</p><ul><li><strong>线程优先级：</strong></li></ul></li><li><p>java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p></li><li><p>线程优先级用数字表示，范围从1~10</p></li><li><p>获取优先级：<code>getPriority().setPriority(int XXX)</code></p></li></ol><ul><li><strong>守护线程：</strong></li></ul><ol><li>线程分为用户线程（如<code>main线程</code>）和守护线程（如<code>gc线程</code>）。正常线程都是用户线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待用户线程执行完毕</li><li><strong>例如：</strong> 后台记录操作日志，监控日志，垃圾回收等。。。</li></ol><h2 id="线程同步安全"><a href="#线程同步安全" class="headerlink" title="线程同步安全"></a>线程同步安全</h2><p>由于同一进程的多个线程共享同一块儿存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入<code>锁机制</code>。<code>Synchronized</code>,当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。</p><ul><li>一个线程持有锁会导致其他所需要此锁的线程挂起。</li><li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换，和调度时延，引起性能问题。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。  </li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul><li>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们需要针对方法提供一套机制，这套机制就是<code>synchronized</code>关键字，它包括两种方法：<strong>synchronized方法</strong>和<strong>synchronized块</strong></li><li><code>synchronized</code>方法控制对象的访问，每个对象对应一把锁，每个<code>synchronized</code>方法都必须获得调用该方法对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的进程才能获得这把锁，继续执行。缺点就是：若将一个大的方法申明为<code>synchronized</code>将会影响效率，锁的太多，就会浪费资源。</li></ul><h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><ul><li><strong>同步块：</strong> <code>synchronized（Obj）{}</code>，锁住的是对象，是需要修改的那个对象。</li><li><code>Obj</code>称之为<strong>同步监视器</strong></li></ul><ol><li><code>Obj</code>可以是任意对象，但是推荐使用共享资源作为同步监视器。</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是<code>this</code>.就是这个对象本身，或者是class对象。</li></ol><ul><li>同步监视器的执行过程</li></ul><ol><li>第一个线程访问，锁定同步监视器，执行其中代码。</li><li>第二个线程访问，发现同步监视器被锁定，无法访问。</li><li>第一个线程访问完毕，解锁同步监视器。</li><li>第二个线程访问，发现同步监视器没有锁了，然后锁定并访问。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>JUC并发包中的类。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这章深入线程，了解一些线程状态以及常用的方法，以及线程同步的安全问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---多线程（一）</title>
    <link href="http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://daqwt.top/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-05-20T14:35:35.000Z</published>
    <updated>2020-06-03T14:42:36.457Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程是并发编程的基础，使用多线程的目的在于提高利用率，而并不会加快系统的运行速度。这一章主要了解一些多线程的基本知识，以及创建一个线程的几种方法。</p><a id="more"></a><h2 id="多线程是什么？"><a href="#多线程是什么？" class="headerlink" title="多线程是什么？"></a>多线程是什么？</h2><ul><li>多线程也是面试高频考点之一，了解多线程对我们的日常编程也有很大的帮助，在学习过程中，也能让我们理解起来更轻松，先来看看<strong>进程和线程是什么？</strong></li></ul><p>①进程：操作系统资源分配和调度的基本单位。也就是我们电脑中运行的一个个独立的任务。<br>②线程：任务调度和执行的最小单位，线程在进程中是独立的，并发的执行流，线程也被称为轻量级进程。</p><ul><li><strong>线程与进程相比，会具有以下优势：</strong></li></ul><p>①系统创建进程时需要为其分配独立的内存单元以及分配大量的相关资源，相比而言，线程的创建简单得多，因此多线程的多任务并发比多进程的执行效率高。<br>②进程之间共享内存很麻烦，线程之间共享内存则非常容易。</p><ul><li><strong>那么多线程怎么理解呢？</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程扩展了进程的概念，使得同一个进程可以同时并发处理多个任务，就像一个大哥将一件很麻烦的工作交给众多小弟去做一样，大家各做各的，最终将这件事完成，大哥露出了欣慰的笑容，这里的并发有必要和并行区分一下。<br>①并行：在同一时刻，有多条指令在多个CPU上同时执行，只有多处理器的系统中才存在并行。<br>②并发：同一时刻只有一条指令执行，多个进程指令被迅速切换，从而达到多个进程同时执行的效果，表面上看像是在同时执行一样，其实是因为你根本感知不到转换。</p><ul><li><strong>注意：</strong> </li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程的存在，不是为了提高程序的执行速度，而是为了提高应用程序的使用率，程序的执行都是在抢占CPU资源，多个进程都在抢资源，那么某个进程执行路径比较多的话（也就是有多线程），那么它抢到CPU资源的成功率就高一点。</p><h2 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h2><ul><li><strong>优点：</strong></li></ul><p>(1)多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态；<br>(2)占用大量处理时间的任务使用多线程可以提高CPU利用率，即占用大量处理时间的任务可以定期将处理器时间让给其它任务；<br>(3)多线程可以分别设置优先级以优化性能。</p><ul><li><strong>缺点：</strong></li></ul><p>(1)等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。<br>(2)对线程进行管理要求额外的 CPU开销，线程的使用会给系统带来上下文切换的额外负担。如果线程很多的话，各线程之间还要避免发生冲突，也就是多线程的安全问题、<br>(3)线程的死锁。即对共享资源加锁实现同步的过程中可能会死锁。<br>(4)对公有变量的同时读或写，可能造成脏读等；</p><h2 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h2><p>1、常见的浏览器、Web服务(现在写的web是中间件帮你完成了线程的控制)，web处理请求，各种专用服务器(如游戏服务器)。<br>2、servlet多线程。<br>3、FTP下载，多线程操作文件。<br>4、数据库用到的多线程。<br>5、分布式计算。<br>6、tomcat内部采用多线程，上百个客户端访问同一个WEB应用，tomcat接入后就是把后续的处理扔给一个新的线程来处理，这个新的线程最后调用我们的servlet程序，比如doGet或者dpPost方法。<br>7、后台任务：如定时向大量(100W以上)的用户发送邮件；定期更新配置文件、任务调度(如quartz)，一些监控用于定期信息采集。<br>8、自动作业处理：比如定期备份日志、定期备份数据库。<br>9、异步处理：如发微博、记录日志。<br>10、页面异步处理：比如大批量数据的核对工作(有10万个手机号码，核对哪些是已有用户)。<br>11、数据库的数据分析(待分析的数据太多)，数据迁移。<br>12、多步骤的任务处理，可根据步骤特征选用不同个数和特征的线程来协作处理，多任务的分割，由一个主线程分割给多个线程完成。<br>13、desktop应用开发，一个费时的计算开个线程，前台加个进度条显示。<br>14、swing编程。</p><h2 id="线程分析"><a href="#线程分析" class="headerlink" title="线程分析"></a>线程分析</h2><ul><li>线程的生命周期：<strong>新建，就绪，运行，阻塞，死亡。</strong><br><img src="https://img-blog.csdnimg.cn/20200419221538653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>线程的基本类型<br>①<strong>用户级线程：</strong> 管理过程全部由用户程序完成，操作系统内核只对进程进行管理。<br>②<strong>系统级线程：</strong> 由操作系统内核进行管理，操作系统内核给应用程序提供相应的系统调用和应用程序接口API，以此，用户便可以创建，执行，撤销线程。</li></ul><h2 id="实现多线程的几种方法"><a href="#实现多线程的几种方法" class="headerlink" title="实现多线程的几种方法"></a>实现多线程的几种方法</h2><ul><li>在Java中，实现多线程主要有四种方式。如下：</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ThreadDemo01 t1=<span class="keyword">new</span> ThreadDemo01();</span><br><span class="line"><span class="comment">//对象调用Start方法开启线程</span></span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" running..."</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>); <span class="comment">// 休息1000ms</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看源码发现，Thread类也实现了Runnable接口。这就是典型的<strong>解耦</strong>，Runnable是一个简单的线程任务，里面只有一个run方法，而thread类是线程控制，它包括很多对线程加以操作的方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200419231518716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200419231523975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ul><li>使用接口的方式可以让我们的<strong>程序降低耦合度</strong>。Runnable接口中仅仅定义了一个run方法。</li><li>其实Runnable就是一个线程任务，<strong>线程任务和线程的控制分离</strong>，这也就是上面所说的解耦。我们要实现一个线程，可以借助Thread类，Thread类要执行的任务就可以由实现了Runnable接口的类来处理。 这就是Runnable的精髓之所在！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" running..."</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>); <span class="comment">// 休息1000ms</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Runnable接口的类，初始化一个实例对象</span></span><br><span class="line">ThreadDemo02 test =<span class="keyword">new</span> ThreadDemo02();</span><br><span class="line"><span class="comment">//将这个实例对象传入Thread中</span></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul><li>在Callable的源码中，只发现了一个call方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020041923164925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableImpl</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallableImpl</span><span class="params">(String acceptStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acceptStr = acceptStr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String acceptStr;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 任务阻塞 1 秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.acceptStr + <span class="string">" append some chars and return it!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> CallableImpl(<span class="string">"my callable test!"</span>);</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="comment">// 调用get()阻塞主线程，反之，线程不会阻塞</span></span><br><span class="line">        String result = task.get();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"hello : "</span> + result);</span><br><span class="line">        System.out.println(<span class="string">"cast : "</span> + (endTime - beginTime) / <span class="number">1000</span> + <span class="string">" second!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Runnable和实现Callable接口的异同点</li></ul><p><strong>相同点：</strong> 都用来编写多线程程序，都调用Thread.start()启动线程。<br><strong>不同点：</strong><br>①实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。<br>②Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛。</p><h3 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h3><h2 id="注意-总结"><a href="#注意-总结" class="headerlink" title="注意/总结"></a>注意/总结</h2><ul><li><p><code>run（）</code>和<code>start（）</code>的区别：<br>①<code>run（）</code>仅仅是封装被线程执行的代码，直接调用是普通方法。<br>②<code>start（）</code>先启动线程，再由<code>jvm</code>去调用线程的<code>run()</code>方法执行任务。</p></li><li><p>JVM的启动也是多线程的，不仅仅是main主线程启动了，还有垃圾回收等等线程也启动了。</p></li><li><p>一般使用实现Runnable接口来创建线程。这样做可以避免java中单继承的限制，同时也可以将运行任务和控制机制解耦。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;多线程是并发编程的基础，使用多线程的目的在于提高利用率，而并不会加快系统的运行速度。这一章主要了解一些多线程的基本知识，以及创建一个线程的几种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot---整合Thymelea与数据校验</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88Thymelea%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88Thymelea%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</id>
    <published>2020-05-15T08:40:07.000Z</published>
    <updated>2020-06-12T08:44:10.425Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 可以结合 Thymeleaf 模版来整合 HTML，使用原生的 HTML 作为视图。Thymeleaf 模版是面向 Web 和独立环境的 Java 模版引擎，能够处理 <code>HTML、XML、JavaScript、CSS</code> 等。</p><a id="more"></a><h3 id="整合Thymeleaf"><a href="#整合Thymeleaf" class="headerlink" title="整合Thymeleaf"></a>整合Thymeleaf</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;message&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- web启动jar --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建<code>appliction.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure><ul><li><code>Handler</code>控制器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"index..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>HTML</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果希望客户端可以直接访问 HTML 资源，将这些资源放置在 static 路径下即可，否则必须通过 Handler 的后台映射才可以访问静态资源。</p><h3 id="Thymeleaf-常用语法"><a href="#Thymeleaf-常用语法" class="headerlink" title="Thymeleaf 常用语法"></a>Thymeleaf 常用语法</h3><ul><li>赋值、拼接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">  map.put(<span class="string">"name"</span>,<span class="string">"张三"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"'学生姓名是'+$&#123;name&#125;+2"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"|学生姓名是,$&#123;name&#125;|"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>条件判断：<code>if/unless</code></li></ul><p><code>th:if</code> 表示条件成立时显示内容，<code>th:unless</code> 表示条件不成立时显示内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/if"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index3</span><span class="params">(Map&lt;String,Boolean&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">"flag"</span>,<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">"$&#123;flag == true&#125;"</span> <span class="attr">th:text</span>=<span class="string">"if判断成立"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">"$&#123;flag != true&#125;"</span> <span class="attr">th:text</span>=<span class="string">"unless判断成立"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"index..."</span>);</span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Student(<span class="number">1L</span>,<span class="string">"张三"</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Student(<span class="number">2L</span>,<span class="string">"李四"</span>,<span class="number">23</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Student(<span class="number">3L</span>,<span class="string">"王五"</span>,<span class="number">24</span>));</span><br><span class="line">    model.addAttribute(<span class="string">"list"</span>,list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>index<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>count<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学生ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学生姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学生年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"student,stat:$&#123;list&#125;"</span> <span class="attr">th:style</span>=<span class="string">"'background-color:'+@&#123;$&#123;stat.odd&#125;?'#F2F2F2'&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;stat.index&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;stat.count&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;student.age&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>stat 是状态变量，属性：</p><ul><li>index 集合中元素的index（从0开始）</li><li>count 集合中元素的count（从1开始）</li><li>size 集合的大小</li><li>current 当前迭代变量</li><li>even/odd 当前迭代是否为偶数/奇数（从0开始计算）</li><li>first 当前迭代的元素是否是第一个</li><li>last 当前迭代的元素是否是最后一个</li></ul><ul><li>URL</li></ul><p>Thymeleaf 对于 URL 的处理是通过 <code>@{...}</code> 进行处理，结合 th:href 、th:src</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;http://www.baidu.com&#125;"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;http://localhost:9090/index/url/&#123;na&#125;(na=$&#123;name&#125;)&#125;"</span>&gt;</span>跳转2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">"$&#123;src&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:style</span>=<span class="string">"'background:url('+ @&#123;$&#123;src&#125;&#125; +');'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>三元运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/eq"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">eq</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"age"</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">th:value</span>=<span class="string">"$&#123;age gt 30?'中年':'青年'&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>gt great than 大于</li><li>ge great equal 大于等于</li><li>eq equal 等于</li><li>lt less than 小于</li><li>le less equal 小于等于</li><li>ne not equal 不等于</li></ul><ul><li>switch</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/switch"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">switchTest</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"gender"</span>,<span class="string">"女"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">"$&#123;gender&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"女"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"男"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"*"</span>&gt;</span>未知<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基本对象<ul><li><code>#ctx</code> ：上下文对象</li><li><code>#vars</code>：上下文变量</li><li><code>#locale</code>：区域对象</li><li><code>#request</code>：HttpServletRequest 对象</li><li><code>#response</code>：HttpServletResponse 对象</li><li><code>#session</code>：HttpSession 对象</li><li><code>#servletContext</code>：ServletContext 对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/object"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">object</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">"request"</span>,<span class="string">"request对象"</span>);</span><br><span class="line">    request.getSession().setAttribute(<span class="string">"session"</span>,<span class="string">"session对象"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#request.getAttribute('request')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#session.getAttribute('session')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#locale.country&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>内嵌对象</li></ul><p>可以直接通过 # 访问。</p><p>1、dates：java.util.Date 的功能方法</p><p>2、calendars：java.util.Calendar 的功能方法</p><p>3、numbers：格式化数字</p><p>4、strings：java.lang.String 的功能方法</p><p>5、objects：Object 的功能方法</p><p>6、bools：对布尔求值的方法</p><p>7、arrays：操作数组的功能方法</p><p>8、lists：操作集合的功能方法</p><p>9、sets：操作集合的功能方法</p><p>10、maps：操作集合的功能方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/util"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">util</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"name"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    model.addAttribute(<span class="string">"count"</span>,<span class="number">22</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"date"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 格式化时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(date,'yyyy-MM-dd HH:mm:sss')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建当前时间，精确到天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.createToday()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建当前时间，精确到秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.createNow()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 判断是否为空 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.isEmpty(name)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 判断List是否为空 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#lists.isEmpty(users)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出字符串长度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.length(name)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拼接字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.concat(name,name,name)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建自定义字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.randomAlphanumeric(count)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-数据校验"><a href="#Spring-Boot-数据校验" class="headerlink" title="Spring Boot 数据校验"></a>Spring Boot 数据校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"姓名不能为空"</span>)</span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">2</span>,message = <span class="string">"姓名长度不能小于2位"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">16</span>,message = <span class="string">"年龄必须大于16岁"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/validator"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatorUser</span><span class="params">(@Valid User user,BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">  System.out.println(user);</span><br><span class="line">  <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">    List&lt;ObjectError&gt; list = bindingResult.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span>(ObjectError objectError:list)&#123;</span><br><span class="line">      System.out.println(objectError.getCode()+<span class="string">"-"</span>+objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring Boot 可以结合 Thymeleaf 模版来整合 HTML，使用原生的 HTML 作为视图。Thymeleaf 模版是面向 Web 和独立环境的 Java 模版引擎，能够处理 &lt;code&gt;HTML、XML、JavaScript、CSS&lt;/code&gt; 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot---整合JSP</title>
    <link href="http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88JSP/"/>
    <id>http://daqwt.top/SpringBoot%E6%95%B4%E5%90%88JSP/</id>
    <published>2020-05-14T08:37:36.000Z</published>
    <updated>2020-06-12T08:39:44.109Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记录SpringBoot整合jsp的过程。</p><a id="more"></a><h3 id="创建pom-xml"><a href="#创建pom-xml" class="headerlink" title="创建pom.xml"></a>创建pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- web --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 整合JSP --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- JSTL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建配置文件-application-yml"><a href="#创建配置文件-application-yml" class="headerlink" title="创建配置文件 application.yml"></a>创建配置文件 application.yml</h3><ul><li>在<code>resources</code>中创建</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">view:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">.jsp</span></span><br></pre></td></tr></table></figure><h3 id="创建-Handler与jsp页面交换"><a href="#创建-Handler与jsp页面交换" class="headerlink" title="创建 Handler与jsp页面交换"></a>创建 Handler与jsp页面交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.southwind.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.setViewName(<span class="string">"index"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"list"</span>,studentRepository.findAll());</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/deleteById/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">        studentRepository.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/hello/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        studentRepository.saveOrUpdate(student);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/hello/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        studentRepository.saveOrUpdate(student);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/hello/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/findById/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.setViewName(<span class="string">"update"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"student"</span>,studentRepository.findById(id));</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h3><ul><li><code>index.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">"false"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;学生信息&lt;/h1&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;学生编号&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;学生姓名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;学生年龄&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"student"</span>&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;$&#123;student.id&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;student.name&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;student.age&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href="/hello/findById/$&#123;student.id&#125;"&gt;修改&lt;/a&gt;</span><br><span class="line">                    &lt;a href="/hello/deleteById/$&#123;student.id&#125;"&gt;删除&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;a href="/save.jsp"&gt;添加学生&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>save.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/hello/save"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        ID:&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        name:&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        age:&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>update.jsp</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/hello/update"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        ID:&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span> value=<span class="string">"$&#123;student.id&#125;"</span> readonly/&gt;&lt;br/&gt;</span><br><span class="line">        name:&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> value=<span class="string">"$&#123;student.name&#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        age:&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> value=<span class="string">"$&#123;student.age&#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;记录SpringBoot整合jsp的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot---环境体验</title>
    <link href="http://daqwt.top/SpringBoot%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B/"/>
    <id>http://daqwt.top/SpringBoot%E5%85%B8%E5%9E%8B%E6%A1%88%E4%BE%8B/</id>
    <published>2020-05-13T08:34:16.000Z</published>
    <updated>2020-06-12T08:37:06.448Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个用springBoot框架搭起来的简单应用，目的在于感受一下SpringBoot的便捷。</p><a id="more"></a><h3 id="创建-Maven-工程，导入相关依赖。"><a href="#创建-Maven-工程，导入相关依赖。" class="headerlink" title="创建 Maven 工程，导入相关依赖。"></a>创建 Maven 工程，导入相关依赖。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- web启动jar --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建-Student-实体类"><a href="#创建-Student-实体类" class="headerlink" title="创建 Student 实体类"></a>创建 Student 实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StudentRepository业务接口"><a href="#StudentRepository业务接口" class="headerlink" title="StudentRepository业务接口"></a>StudentRepository业务接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.southwind.entity.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StudentRepositoryImpl业务实现"><a href="#StudentRepositoryImpl业务实现" class="headerlink" title="StudentRepositoryImpl业务实现"></a>StudentRepositoryImpl业务实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.repository.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.daq.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.daq.repository.StudentRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> daq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 这是具体业务方法的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">StudentRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long,Student&gt; studentMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        studentMap= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        studentMap.put(<span class="number">1l</span>,<span class="keyword">new</span> Student(<span class="number">1l</span>,<span class="string">"代澳旗"</span>,<span class="number">21</span>));</span><br><span class="line">        studentMap.put(<span class="number">1l</span>,<span class="keyword">new</span> Student(<span class="number">2l</span>,<span class="string">"吴桐"</span>,<span class="number">22</span>));</span><br><span class="line">        studentMap.put(<span class="number">1l</span>,<span class="keyword">new</span> Student(<span class="number">3l</span>,<span class="string">"呜啦啦"</span>,<span class="number">22</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        studentMap.put(student.getId(),student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        studentMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StudentHandler控制器"><a href="#StudentHandler控制器" class="headerlink" title="StudentHandler控制器"></a>StudentHandler控制器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.daq.entity.Student;</span><br><span class="line"><span class="keyword">import</span> com.daq.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> daq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 这是控制器，相关的业务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"findById/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        studentRepository.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody Student student)</span></span>&#123;</span><br><span class="line">        studentRepository.saveOrUpdate(student);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/deleteById/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">        studentRepository.deleteById(id);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot启动类"><a href="#SpringBoot启动类" class="headerlink" title="SpringBoot启动类"></a>SpringBoot启动类</h3><ul><li><code>@SpringBootApplication</code>注解 表示当前类是 Spring Boot 的入口，Application 类的存放位置必须是其他相关业务类的存放位置的父级。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> daq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 这是启动类,作为整个SpringBoot的入口,</span></span><br><span class="line"><span class="comment"> * 需要添加<span class="doctag">@SpringBootApplication</span>才知道这是入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="application-yml更改端口号"><a href="#application-yml更改端口号" class="headerlink" title="application.yml更改端口号"></a>application.yml更改端口号</h3><ul><li>必须取名为<code>application.yml</code></li><li>比<code>xml</code>简单多了，<code>xml</code>还要引入头标签</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure><h3 id="启动main方法"><a href="#启动main方法" class="headerlink" title="启动main方法"></a>启动main方法</h3><ul><li>成功！！！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个用springBoot框架搭起来的简单应用，目的在于感受一下SpringBoot的便捷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot---基础了解</title>
    <link href="http://daqwt.top/SpringBoot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/"/>
    <id>http://daqwt.top/SpringBoot%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</id>
    <published>2020-05-12T08:30:44.000Z</published>
    <updated>2020-06-12T08:34:44.534Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot现在越来越火，它是基于 Spring 开发，它本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序，是 Spring Cloud 的基础。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>发展阶段： <code>javaweb</code>—&gt; <code>Struts</code>—&gt; <code>SpringMVC</code>—&gt;<code>SpringBoot</code>,技术在不断更新换代，学的还没换的快，说不定一年后又有新框架出来，不仅仅是要学会如何使用框架，还要了解如何去学习一个新的框架，学习能力才是最重要的。</li><li>框架遵循的规律：原生代码—&gt;配置—&gt;约定大于配置，进而衍生出一些<code>一站式</code>的解决方案。</li></ul><h2 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h2><ul><li>基于 Spring 开发，它本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序，是 Spring Cloud 的基础。</li><li>换言之：它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</li><li>就像maven整合了所有的jar包，spring boot整合了所有的框架 。</li><li>SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</li><li>SpringCloud依赖于SpringBoot，他专注于快速开发个体微服务，SpringCloud是关注全局微服务协调治理框架。<h2 id="SpringBoot的优点"><a href="#SpringBoot的优点" class="headerlink" title="SpringBoot的优点"></a>SpringBoot的优点</h2></li></ul><ol><li>可以创建独立的<code>Spring</code>应用程序，并且基于其<code>Maven</code>或<code>Gradle</code>插件，可以创建可执行的<code>JARs</code>和<code>WARs</code></li><li>内嵌Tomcat或Jetty等Servlet容器</li><li>提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置</li><li>尽可能自动配置Spring容器</li><li>提供准备好的特性，如指标、健康检查和外部化配置</li><li>绝对没有代码生成，不需要 <code>web.xml</code>，<code>springmvc.xml</code>,不需要XML配置</li><li>不需要配置 JSON 解析，支持 REST 架构</li><li>个性化配置非常简单</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SpringBoot现在越来越火，它是基于 Spring 开发，它本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序，是 Spring Cloud 的基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://daqwt.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC---数据处理及跳转</title>
    <link href="http://daqwt.top/SpringMVC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/"/>
    <id>http://daqwt.top/SpringMVC%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/</id>
    <published>2020-05-08T13:19:48.000Z</published>
    <updated>2020-05-28T13:34:57.083Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跳转就是转发和重定向，在SpringMVC中，只需要加一个单词就可以搞定，数据处理就要用到JSON了。这里涉及到JSON又是为Ajax而生的。</p><a id="more"></a><h1 id="跳转方式（转发和重定向）"><a href="#跳转方式（转发和重定向）" class="headerlink" title="跳转方式（转发和重定向）"></a>跳转方式（转发和重定向）</h1><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><ul><li>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</li><li>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span><br><span class="line">     id=<span class="string">"internalResourceViewResolver"</span>&gt;</span><br><span class="line">   &lt;!-- 前缀 --&gt;</span><br><span class="line">   &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span><br><span class="line">   &lt;!-- 后缀 --&gt;</span><br><span class="line">   &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>对应的controller类</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ControllerTest1 implements Controller &#123;</span><br><span class="line"></span><br><span class="line">   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line">       //返回一个模型视图对象</span><br><span class="line">       ModelAndView mv = new ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"ControllerTest1"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="built_in">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><ul><li>通过设置ServletAPI , 不需要视图解析器 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t1"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">//1. 通过HttpServletResponse进行输出</span></span><br><span class="line">       rsp.getWriter().println(<span class="string">"Hello,Spring BY servlet API"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t2"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//2. 通过HttpServletResponse实现重定向</span></span><br><span class="line">       rsp.sendRedirect(<span class="string">"/index.jsp"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/result/t3"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//3. 通过HttpServletResponse实现转发</span></span><br><span class="line">       req.setAttribute(<span class="string">"msg"</span>,<span class="string">"/result/t3"</span>);</span><br><span class="line">       req.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/test.jsp"</span>).forward(req,rsp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringMVC做法"><a href="#SpringMVC做法" class="headerlink" title="SpringMVC做法"></a>SpringMVC做法</h3><ul><li>通过SpringMVC来实现转发和重定向—-<strong>无视图解析器。</strong></li><li>要先把<code>springmvc-servlet.xml</code>配置文件中的视图解析器注掉</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ResultSpringMVC &#123;</span><br><span class="line">   @RequestMapping(<span class="string">"/rsm/t1"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test1</span></span>()&#123;</span><br><span class="line">       //转发</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(<span class="string">"/rsm/t2"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test2</span></span>()&#123;</span><br><span class="line">       //转发二</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(<span class="string">"/rsm/t3"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test3</span></span>()&#123;</span><br><span class="line">       //重定向</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过SpringMVC来实现转发和重定向—- <strong>有视图解析器</strong>。<br>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.<br>可以重定向到另外一个请求实现 .</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ResultSpringMVC2 &#123;</span><br><span class="line">   @RequestMapping(<span class="string">"/rsm2/t1"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test1</span></span>()&#123;</span><br><span class="line">       //转发</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(<span class="string">"/rsm2/t2"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test2</span></span>()&#123;</span><br><span class="line">       //重定向</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">       //<span class="built_in">return</span> <span class="string">"redirect:hello.do"</span>; //hello.do为另一个请求/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据处理（处理和显示）"><a href="#数据处理（处理和显示）" class="headerlink" title="数据处理（处理和显示）"></a>数据处理（处理和显示）</h1><h2 id="处理提交的数据"><a href="#处理提交的数据" class="headerlink" title="处理提交的数据"></a>处理提交的数据</h2><h3 id="提交的域名称和处理方法的参数名一致"><a href="#提交的域名称和处理方法的参数名一致" class="headerlink" title="提交的域名称和处理方法的参数名一致"></a>提交的域名称和处理方法的参数名一致</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">提交数据 : http:<span class="comment">//localhost:8080/hello?name=daq</span></span><br><span class="line"></span><br><span class="line">处理方法 :</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);<span class="comment">//后台显示</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : daq，来自输入框中获取的数据</p><h3 id="提交的域名称和处理方法的参数名不一致"><a href="#提交的域名称和处理方法的参数名不一致" class="headerlink" title="提交的域名称和处理方法的参数名不一致"></a>提交的域名称和处理方法的参数名不一致</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">提交数据 : http://localhost:8080/hello?username=daq</span><br><span class="line"></span><br><span class="line">处理方法 :</span><br><span class="line">//@RequestParam(<span class="string">"username"</span>) : username提交的域的名称 .</span><br><span class="line">@RequestMapping(<span class="string">"/hello"</span>)</span><br><span class="line">public String hello(@RequestParam(<span class="string">"username"</span>) String name)&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : daq</p><h3 id="提交的是一个对象"><a href="#提交的是一个对象" class="headerlink" title="提交的是一个对象"></a>提交的是一个对象</h3><p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p><p>1、实体类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   private int id;</span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   //构造，get/<span class="built_in">set</span>，tostring()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>提交数据 : <code>http://localhost:8080/mvc04/user?name=daq&amp;id=1&amp;age=21</code></p></li><li><p>处理方法 :</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/user"</span>)</span><br><span class="line">public String user(User user)&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : User { id=1, name=’daq’, age=21 }</p><p>补充：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p><h2 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h2><h3 id="第一种-通过ModelAndView-—-麻烦"><a href="#第一种-通过ModelAndView-—-麻烦" class="headerlink" title="第一种 : 通过ModelAndView**—-(麻烦)"></a>第一种 : 通过ModelAndView**—-(麻烦)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ControllerTest1 implements Controller &#123;</span><br><span class="line"></span><br><span class="line">   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line">       //返回一个模型视图对象</span><br><span class="line">       ModelAndView mv = new ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"ControllerTest1"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="built_in">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种：通过ModelMap"><a href="#第二种：通过ModelMap" class="headerlink" title="第二种：通过ModelMap"></a>第二种：通过ModelMap</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/hello"</span>)</span><br><span class="line">public String hello(@RequestParam(<span class="string">"username"</span>) String name, ModelMap model)&#123;</span><br><span class="line">   //封装要显示到视图中的数据</span><br><span class="line">   //相当于req.setAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">   model.addAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种-通过Model"><a href="#第三种-通过Model" class="headerlink" title="第三种 : 通过Model"></a>第三种 : 通过Model</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/ct2/hello"</span>)</span><br><span class="line">public String hello(@RequestParam(<span class="string">"username"</span>) String name, Model model)&#123;</span><br><span class="line">   //封装要显示到视图中的数据</span><br><span class="line">   //相当于req.setAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">   model.addAttribute(<span class="string">"msg"</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><ul><li>Model 只有寥寥几个方法只适合用于储存数据，简化了对于Model对象的操作和理解</li><li>ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性。</li><li>ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</li></ul><h1 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h1><ul><li>SpringMVC提供了一个过滤器 , 可以在<code>web.xml</code>中配置 .以解决乱码问题 。</li><li>乱码问题，需要平时多注意，在能设置编码的地方，都设置为统一编码 <code>UTF-8</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">       &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">       &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">   &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">   &lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;跳转就是转发和重定向，在SpringMVC中，只需要加一个单词就可以搞定，数据处理就要用到JSON了。这里涉及到JSON又是为Ajax而生的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://daqwt.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC---controller控制器和RestFul风格</title>
    <link href="http://daqwt.top/SpringMVC%E4%B8%ADcontroller%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8CRestFul%E9%A3%8E%E6%A0%BC/"/>
    <id>http://daqwt.top/SpringMVC%E4%B8%ADcontroller%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8CRestFul%E9%A3%8E%E6%A0%BC/</id>
    <published>2020-05-07T13:19:48.000Z</published>
    <updated>2020-05-28T13:26:35.153Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;controller控制器是在类上加一个@controller注解，方便开发，RestFul风格是指地址栏中的链接是拼接起来。</p><a id="more"></a><h1 id="controller注解"><a href="#controller注解" class="headerlink" title="@controller注解"></a>@controller注解</h1><p>编写控制器有以下两种方式：</p><ul><li>实现controller接口</li><li>使用<code>@controller</code>注解</li></ul><h3 id="实现controller接口"><a href="#实现controller接口" class="headerlink" title="实现controller接口"></a>实现controller接口</h3><p>1.编写一个Controller类，ControllerTest1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义控制器</span></span><br><span class="line"><span class="comment">//注意点：不要导错包，实现Controller接口，重写方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">"msg"</span>,<span class="string">"Test1Controller"</span>);</span><br><span class="line">       mv.setViewName(<span class="string">"test"</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"/t1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.daq.controller.ControllerTest1"</span>/&gt;</span><br></pre></td></tr></table></figure><p>3.在WEB-INF/jsp目录下编写前端test.jsp，对应视图解析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="variable">$&#123;msg&#125;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>缺点：</strong> 一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦。</li></ul><h3 id="使用-controller注解"><a href="#使用-controller注解" class="headerlink" title="使用@controller注解"></a>使用@controller注解</h3><ul><li><p>@Controller注解类型用于声明Spring类的实例是一个控制器</p></li><li><p>Spring可以使用<strong>扫描机制</strong>来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=<span class="string">"com.daq.controller"</span>/&gt;</span><br></pre></td></tr></table></figure><ul><li>增加一个ControllerTest2类，使用注解实现；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//@Controller注解的类会自动添加到Spring上下文中</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class ControllerTest2&#123;</span><br><span class="line">   //映射访问路径</span><br><span class="line">   @RequestMapping(<span class="string">"/t2"</span>)</span><br><span class="line">   public String index(Model model)&#123;</span><br><span class="line">       //Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br><span class="line">       model.addAttribute(<span class="string">"msg"</span>, <span class="string">"ControllerTest2"</span>);</span><br><span class="line">       //返回视图位置</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>/t2</code>访问到的就是<code>WEB-INF/jsp</code>目录下的<code>test.jsp</code>，</p></li><li><p>平时用的比较多，在控制器类上加一个<code>@controller</code>注解即可，然后在具体的方法中加入<code>@RequestMapping</code>注解即可。</p></li></ul><h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h1><ul><li>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同时注解类与方法</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(<span class="string">"/admin"</span>)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">   @RequestMapping(<span class="string">"/h1"</span>)</span><br><span class="line">   public String <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问路径：<a href="http://localhost:8080">http://localhost:8080</a> / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径</li></ul><h1 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h1><ul><li>概念<br>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li><li>功能</li></ul><ol><li><p>资源：互联网所有的事物都可以被抽象为资源</p></li><li><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p></li><li><p>分别对应 添加、 删除、修改、查询。</p></li></ol><ul><li>传统方式操作资源  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/item/queryItem.action?id=1 查询,GET</span><br><span class="line">http://127.0.0.1/item/saveItem.action 新增,POST</span><br><span class="line">http://127.0.0.1/item/updateItem.action 更新,POST</span><br><span class="line">http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST</span><br></pre></td></tr></table></figure><ul><li>使用<code>RESTful</code>操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/item/1 查询,GET</span><br><span class="line">http://127.0.0.1/item 新增,POST</span><br><span class="line">http://127.0.0.1/item 更新,PUT</span><br><span class="line">http://127.0.0.1/item/1 删除,DELETE</span><br></pre></td></tr></table></figure><h3 id="使用路径变量"><a href="#使用路径变量" class="headerlink" title="使用路径变量"></a>使用路径变量</h3><ul><li>在Spring MVC中可以使用  <code>@PathVariable</code> 注解，让方法参数的值对应绑定到一个URI模板变量上。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class RestFulController &#123;</span><br><span class="line"></span><br><span class="line">   //映射访问路径</span><br><span class="line">   @RequestMapping(<span class="string">"/commit/&#123;p1&#125;/&#123;p2&#125;"</span>)</span><br><span class="line">   public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;       </span><br><span class="line">       int result = p1+p2;</span><br><span class="line">       //Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br><span class="line">       model.addAttribute(<span class="string">"msg"</span>, <span class="string">"结果："</span>+result);</span><br><span class="line">       //返回视图位置</span><br><span class="line">       <span class="built_in">return</span> <span class="string">"test"</span>;       </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200520115303265.png" alt="在这里插入图片描述"></p><ul><li>使用路径变量的好处</li></ul><ol><li>使路径变得更加简洁；</li><li>获得参数更加方便，框架会自动进行类型转换。</li><li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 </li></ol><h3 id="使用method属性指定请求类型"><a href="#使用method属性指定请求类型" class="headerlink" title="使用method属性指定请求类型"></a>使用method属性指定请求类型</h3><ul><li>用于约束请求的类型，可以收窄请求范围。指定请求的类型如<code>GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE</code>等</li><li>测试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//映射访问路径,必须是POST请求</span><br><span class="line">@RequestMapping(value = <span class="string">"/hello"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">public String index2(Model model)&#123;</span><br><span class="line">   model.addAttribute(<span class="string">"msg"</span>, <span class="string">"hello!"</span>);</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：</li></ul><p><img src="https://img-blog.csdnimg.cn/2020052012004078.png" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Spring MVC</code> 的 <code>@RequestMapping</code> 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</li><li>所有的地址栏请求默认都会是 HTTP GET 类型的。</li><li>方法级别的注解变体有如下几个：组合注解</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PatchMapping</span><br></pre></td></tr></table></figure><ul><li><code>@GetMapping</code> 所扮演的是 <code>@RequestMapping(method =RequestMethod.GET)</code> 的一个快捷方式。它是一个组合注解，<strong>平时使用的会比较多。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;controller控制器是在类上加一个@controller注解，方便开发，RestFul风格是指地址栏中的链接是拼接起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://daqwt.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC---基于注解开发</title>
    <link href="http://daqwt.top/SpringMVC%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    <id>http://daqwt.top/SpringMVC%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</id>
    <published>2020-05-06T13:19:48.000Z</published>
    <updated>2020-05-28T13:22:59.215Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringMVC基于注解开发的实例</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>maven</code>工程</li><li><code>web4.0</code>支持</li></ul><h2 id="添加依赖pom-xml"><a href="#添加依赖pom-xml" class="headerlink" title="添加依赖pom.xml"></a>添加依赖pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--扫描配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h2><ul><li>这是固定配置，不用改的</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置springmvc-servlet-xml"><a href="#配置springmvc-servlet-xml" class="headerlink" title="配置springmvc-servlet.xml"></a>配置springmvc-servlet.xml</h2><ul><li>在<code>resource</code>文件夹下添加<code>springmvc-servlet.xml</code>，配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.daq.controller"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。    </span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- annotation-driven配置帮助我们自动完成上述两个实例的注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建相关包和文件夹"><a href="#创建相关包和文件夹" class="headerlink" title="创建相关包和文件夹"></a>创建相关包和文件夹</h2><ul><li>根据上面<code>springmvc-servlet.xml</code>中的相关配置，在<code>src/main/java</code>创建可以展开的包<code>com.daq.controller</code>，在<code>web/WEB-INF</code>中创建<code>jsp</code>文件夹。</li><li>在<code>com.daq.controller</code>目录下创建业务类，以前是继承<code>HttpServlet</code>，现在只需要添加<code>@Controller</code>注解即可被装配，<code>@RequestMapping(&quot;/hello&quot;)</code>中的参数是请求所带的参数。</li><li>以前添加业务就是再写一个<code>servlet</code>现在，直接在<code>controller</code>中加方法，方法上加注解。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200519193240908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用<code>SpringMVC</code>必须配置的三大件：<code>处理器映射器</code>， <code>处理器适配器</code>，<code>视图解析器</code>通常我们只需要手动配置视图解析器，而处理器映射器和处理器适配器我们只需要开启注解驱动即可，而省去了大段<code>xml</code>配置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SpringMVC基于注解开发的实例&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://daqwt.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC---基础了解</title>
    <link href="http://daqwt.top/SpringMVC%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/"/>
    <id>http://daqwt.top/SpringMVC%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</id>
    <published>2020-05-05T13:01:19.000Z</published>
    <updated>2020-05-28T13:19:18.841Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringMVC三层架构</p><a id="more"></a><h2 id="回顾Servlet"><a href="#回顾Servlet" class="headerlink" title="回顾Servlet"></a>回顾Servlet</h2><p>正常的一个servlet编写是这样的</p><ul><li>继承<code>httpServlet</code>，重写<code>doGet()</code>方法，分为三步：</li></ul><ol><li>获取前端参数</li><li>调用业务层</li><li>视图转发或者重定向（一般转发用的比较多）</li></ol><ul><li>在<code>web.xml</code>中注册写好的<code>servlet</code></li><li>写一个提交表单提交到该<code>servlet</code></li></ul><h2 id="SpringMVC是什么？"><a href="#SpringMVC是什么？" class="headerlink" title="SpringMVC是什么？"></a>SpringMVC是什么？</h2><ul><li>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</li><li>Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200519152848155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="SpringMVC的优点"><a href="#SpringMVC的优点" class="headerlink" title="SpringMVC的优点"></a>SpringMVC的优点</h2><ol><li>轻量级，简单易学</li><li>高效 , 基于请求响应的MVC框架</li><li>与Spring兼容性好，无缝结合</li><li>约定优于配置</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li><li>简洁灵活</li></ol><h2 id="SpringMVC原理"><a href="#SpringMVC原理" class="headerlink" title="SpringMVC原理"></a>SpringMVC原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发起请求时被前置的控制器拦截到请求，根据请求参数生成<strong>代理请求</strong> ，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。<br><img src="https://img-blog.csdnimg.cn/20200519152855498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>虚线是我们要做的：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200519160013111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p> 1.DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设请求的url为 : http://localhost:8080/SpringMVC/hello,拆分成三部分:</span><br><span class="line">http://localhost:8080服务器域名</span><br><span class="line">    SpringMVC部署在服务器上的web站点</span><br><span class="line">    hello表示控制器</span><br></pre></td></tr></table></figure><p>如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p><p>2.HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,然后HandlerMapping根据请求url查找Handler。</p><p>3.HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。<br>4.HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。<br>5.HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。<br>6.Handler让具体的Controller执行。<br>7.Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。<br>8.HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。<br>9.DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。<br>10.视图解析器将解析的逻辑视图名传给DispatcherServlet。<br>11.DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。<br>12.最终视图呈现给用户</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SpringMVC三层架构&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="SpringMVC" scheme="http://daqwt.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring---AOP总结</title>
    <link href="http://daqwt.top/SpringAOP%E6%80%BB%E7%BB%93/"/>
    <id>http://daqwt.top/SpringAOP%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-04T13:01:19.000Z</published>
    <updated>2020-05-28T13:17:43.703Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对AOP的理解总结</p><a id="more"></a><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><ul><li>AOP：（Aspect Oriented Programming）面向切面编程</li><li>OOP：（Object Oriented Programming ）面向对象编程</li><li>面向切面编程：基于OOP基础之上新的编程思想，是指：在程序运行期间，将某段代码<code>动态的切入</code>到<code>指定方法</code>的<code>指定位置</code>进行运行的编程方式。</li></ul><h2 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h2><ul><li><p>场景：计算器运行四种计算方法（加减乘除）的时候进行日志记录。</p></li><li><p>加日志记录：<br>①直接编写在方法内部：修改维护麻烦，牵一发动全身，不推荐。</p><ul><li>日志记录：系统的辅助功能。</li><li>业务逻辑：（核心功能）。</li><li>这两者不能耦合在一起。</li></ul><p>②我们希望的是：</p><ul><li>业务逻辑：（核心功能）。</li><li>日志模块；在核心功能运行期间，日志功能可以自己动态的加上。</li><li>解耦。</li></ul></li></ul><p>所以：我们可以使用<strong>动态代理</strong>来将日志代码动态的在目标方法执行前后先进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.inter.Calculator;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.utils.LogUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 帮Calculator.java生成代理对象的类</span></span><br><span class="line"><span class="comment"> * Object newProxyInstance</span></span><br><span class="line"><span class="comment"> * (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为传入的参数对象创建一个动态代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> calculator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Calculator calculator:被代理对象；（宝宝）</span></span><br><span class="line"><span class="comment">     * 返回的：宋喆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法执行器。帮我们目标对象执行目标方法</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Object proxy：代理对象；给jdk使用，任何时候都不要动这个对象</span></span><br><span class="line"><span class="comment">             * Method method：当前将要执行的目标对象的方法</span></span><br><span class="line"><span class="comment">             * Object[] args：这个方法调用时外界传入的参数值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//System.out.println("这是动态代理将要帮你执行方法...");</span></span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LogUtils.logStart(method, args);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 利用反射执行目标方法</span></span><br><span class="line">                    <span class="comment">//目标方法执行后的返回值</span></span><br><span class="line">                    result = method.invoke(calculator, args);</span><br><span class="line">                    LogUtils.logReturn(method, result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LogUtils.logException(method,e);</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    LogUtils.logEnd(method);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回值必须返回出去外界才能拿到真正执行后的返回值</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces();</span><br><span class="line">        ClassLoader loader = calculator.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//Proxy为目标对象创建代理对象；</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line">        <span class="keyword">return</span> (Calculator) proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>普通的动态代理，写起来难。</li><li>问题：<strong>jdk默认的动态代理，如果目标对象没有实现任何接口，是无法为他创建代理对象的。</strong></li><li>所以Spring实现了AOP功能；底层就是动态代理。将某段代码（日志）<code>动态的切入</code>（不把日志代码写死在业务逻辑方法中）到<code>指定方法</code>（加减乘除）的<code>指定位置</code>（方法的开始、结束、异常。。。）进行运行的这种编程方式。<br>①可以利用Spring一句代码都不写的去创建动态代理。<br>②实现简单，而且没有强制要求目标对象必须实现接口。</li></ul><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p><img src="https://img-blog.csdnimg.cn/20200422095702287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="AOP使用步骤"><a href="#AOP使用步骤" class="headerlink" title="AOP使用步骤"></a>AOP使用步骤</h2><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">commons-logging-<span class="number">1.1</span><span class="number">.3</span>.jar</span><br><span class="line">spring-aop-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar</span><br><span class="line">spring-beans-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar</span><br><span class="line">spring-context-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar</span><br><span class="line">spring-core-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar</span><br><span class="line">spring-expression-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar</span><br><span class="line"></span><br><span class="line">Spring支持面向切面编程的包是：</span><br><span class="line">spring-aspects-<span class="number">4.0</span><span class="number">.0</span>.RELEASE.jar：基础版</span><br><span class="line"></span><br><span class="line">加强版的面向切面编程（即使目标对象没有实现任何接口也能创建动态代理）</span><br><span class="line">com.springsource.net.sf.cglib-<span class="number">2.2</span><span class="number">.0</span>.jar</span><br><span class="line">com.springsource.org.aopalliance-<span class="number">1.0</span><span class="number">.0</span>.jar</span><br><span class="line">com.springsource.org.aspectj.weaver-<span class="number">1.6</span><span class="number">.8</span>.RELEASE.jar</span><br></pre></td></tr></table></figure><p>2.写配置<br>①将目标类和切面类（封装了通知方法（在目标方法执行前后执行的方法））<strong>加入到ioc容器中。</strong>（加注解）<br>②还应该告诉Spring到底哪个是切面类<code>@Aspect</code><br>③告诉Spring，切面类里面的每一个方法，都是何时何地运行。<br>④开启基于注解的AOP模式</p><ul><li><p><strong>5个通知注解</strong></p><ul><li><code>@Before</code>：在目标方法之前运行；（前置通知）</li><li><code>@After</code>：在目标方法结束之后                        （后置通知）</li><li><code>@AfterReturning</code>：在目标方法正常返回之后            （返回通知）</li><li><code>@AfterThrowing</code>：在目标方法抛出异常之后运行            （异常通知）</li><li><code>@Around</code>：环绕                                （环绕通知）</li></ul></li><li><p><strong>切入点表达式：</strong><code>execution(访问权限符  返回值类型  方法签名)</code>，方法签名：直接选中方法右键选择<code>Copy Qualified  Name</code>复制即可。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【xxx】方法开始执行，用的参数列表【xxx】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想在目标方法正常执行完成</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【xxxx】方法正常执行完成，计算结果是："</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想在目标方法出现异常的时候执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【xxxx】方法执行出现异常了，异常信息是：；这个异常已经通知测试小组进行排查"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想在目标方法结束的时候执行</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【xxx】方法最终结束了"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在配置文件中写：</span><br><span class="line">&lt;!--  开启基于注解的AOP功能,aop名称空间--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure><p>3.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里按照类型取对象一定要用接口去取。没有接口就用本类原型</span></span><br><span class="line">Calculator bean = ioc.getBean(Calculator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bean.add(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>从ioc容器中拿到目标对象；注意：如果想要用类型，一定用 他的接口类型，不要用它本类。</li><li>cglib为没有接口的组件也可以创建代理对象。</li><li>切入点表达式：<code>execution(访问权限符  返回值类型  方法签名)</code></li><li>通知顺序：<br>① 正常执行： <code>@Before（前置通知）</code>=<code>@After（后置通知）</code>=<code>@AfterReturning（正常返回）</code><br>②异常执行： <code>@Before（前置通知）</code>=<code>@After（后置通知）</code>=<code>@AfterThrowing（方法异常）</code><ol start="5"><li>JoinPoint获取目标方法的信息。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想在执行目标方法之前运行；写切入点表达式</span></span><br><span class="line"><span class="comment">//execution(访问权限符  返回值类型  方法签名)</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public int com.atguigu.impl.MyMathCalculator.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"><span class="comment">//获取到目标方法运行是使用的参数</span></span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="comment">//获取到方法签名</span></span><br><span class="line">Signature signature = joinPoint.getSignature();</span><br><span class="line">String name = signature.getName();</span><br><span class="line">System.out.println(<span class="string">"【"</span>+name+<span class="string">"】方法开始执行，用的参数列表【"</span>+Arrays.asList(args)+<span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h2><ul><li>AOP加日志保存到数据库</li><li>AOP做权限验证</li><li>AOP做安全检查</li><li>AOP做事务控制</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对AOP的理解总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Spring" scheme="http://daqwt.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring---IOC总结</title>
    <link href="http://daqwt.top/Spring---IOC%E6%80%BB%E7%BB%93/"/>
    <id>http://daqwt.top/Spring---IOC%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-03T13:01:19.000Z</published>
    <updated>2020-05-28T13:13:52.644Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学完Spring之后，做一下小总结。</p><a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ioc是一个容器，帮我们管理所有的组件；</li><li>依赖注入（第一大功能）：哪些组件里要用到另外一个组件，直接<code>@Autowired</code>自动赋值。</li><li>某个组件想要使用Spring提供的更多功能（IOC、AOP）那么就必须加入到容器中。</li></ul><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><ul><li>流程：<br>1、容器启动。会创建所有单实例<code>bean</code><br>2、<code>autowired</code>自动装配的时候，是从容器中找这些符合要求的<code>bean</code><br>3、<code>ioc.getBean(&quot;bookServlet&quot;)；</code>也是从容器中找到这个<code>bean</code>。<br>4、容器中包括了所有的<code>bean</code></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>调试spring的源码，容器到底是什么？</li></ul><ol><li>其实就是一个<code>map</code>， 这个<code>map</code>中保存所有创建好的<code>bean</code>，并提供外界获取功能<code>get()</code>…</li></ol><ul><li>单实例的bean都保存到哪个map中了？</li></ul><h2 id="源码调试的思路"><a href="#源码调试的思路" class="headerlink" title="源码调试的思路"></a>源码调试的思路</h2><p>从helloworld开始的，给helloworld每一个关键步骤打上断点。进去看里面都做了什么工作。</p><ul><li>怎么知道哪些方法都是干什么的？</li></ul><ol><li>翻译这个方法</li><li>放行这个方法，看控制台,看debug的每一个变量的变化</li><li>看方法注释</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学完Spring之后，做一下小总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Spring" scheme="http://daqwt.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring---使用注解自动装配</title>
    <link href="http://daqwt.top/Spring---%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>http://daqwt.top/Spring---%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</id>
    <published>2020-05-02T13:01:19.000Z</published>
    <updated>2020-05-28T13:11:22.846Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring使用注解自动装配</p><a id="more"></a><h2 id="通过注解，创建bean"><a href="#通过注解，创建bean" class="headerlink" title="通过注解，创建bean"></a>通过注解，创建bean</h2><ul><li><code>applicationContext.xml</code>文件</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过注解，分别创建DAO，Servlice，Controller（控制器：控制网站跳转逻辑servlet） --&gt;</span><br><span class="line"> &lt;!-- 通过给bean添加某些注解，可以快速将bean添加到ioc容器中 </span><br><span class="line"> 在某个类上添加任何一个注解都能快速将这个组件加入到ioc容器中</span><br><span class="line"> Spring有四个注解：</span><br><span class="line"> <span class="meta">@Controller</span>：推荐给控制器层（servlet包下的这些）</span><br><span class="line"> <span class="meta">@Servlce</span>：业务逻辑，如：BookService</span><br><span class="line"> <span class="meta">@Repository</span>：给数据库层（持久层，dao层）的组件添加这个注解</span><br><span class="line"> <span class="meta">@Compontent</span>：给不属于以上几层的添加 </span><br><span class="line"> Spring底层不会去验证这个注解，各自层加各自的注解，Spring不会</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;!-- </span><br><span class="line"> 步骤如下：</span><br><span class="line"> <span class="number">1</span>.加注解</span><br><span class="line"> <span class="number">2</span>.告诉Spring，自动扫描这个注解的组件，依赖context名称空间</span><br><span class="line"> <span class="number">3</span>.一定要导入aop包，它支持注解</span><br><span class="line"> context:component-scan(自动扫描组件)</span><br><span class="line"> base-<span class="keyword">package</span>（扫描指定的基础包，包以及包下的所有注解的类，自动扫描进ioc容器）</span><br><span class="line">  --&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.daq"</span>&gt;</span><br><span class="line">  &lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocTest</span> </span>&#123;</span><br><span class="line">ApplicationContext ioc =</span><br><span class="line"> <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解加入到容器中的组件，和使用配置加入到容器中是一样的</span></span><br><span class="line"><span class="number">1</span>.组件的id。默认就是组件的类名的首字母小写</span><br><span class="line"> 也可以在注解里面自定义：</span><br><span class="line"> <span class="meta">@Respority</span>（<span class="string">"bookdaohaha"</span>）,这样获取的时候就要</span><br><span class="line"><span class="number">2</span>.组件的作用域，默认就是单例的。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object bean = ioc.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line">Object bean2 = ioc.getBean(<span class="string">"bookDao"</span>);</span><br><span class="line">System.out.println(bean==bean2);<span class="comment">//结果为true  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解并不能干所有的事，比如说，想要把引入的包中的某个类加到容器中，不能在引入的包中加注解，那么这个时候，就要手动配置bean了，所以，注解与bean相结合，就可以把任意的类加入到容器中。</li></ul><h2 id="扫描指定类"><a href="#扫描指定类" class="headerlink" title="扫描指定类"></a>扫描指定类</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用context: exclude-filter指定扫描包时不包含的类 --&gt;</span><br><span class="line"> &lt;!-- 扫描的时候可以排除一些不要的组件 </span><br><span class="line">type=<span class="string">"annotation"</span>按照注解进行排除，标注了指定注解的类不要。</span><br><span class="line">expression=<span class="string">""</span> 注解的全类名</span><br><span class="line">type=<span class="string">"annotation"</span>按照类进行排除，指定的类不要。</span><br><span class="line">expression=<span class="string">""</span> 类的全类名</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.daq"</span>&gt;</span><br><span class="line"> &lt;context:exclude-filter type=<span class="string">"annotation"</span> expression=<span class="string">"com.daq.service.BookService"</span>/&gt;</span><br><span class="line"> &lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用context: include-filter指定扫描包时不包含的类，使用时要禁用默认属性：</span><br><span class="line">use-<span class="keyword">default</span>-filters=<span class="string">"false"</span></span><br><span class="line">type=<span class="string">"annotation"</span>按照注解进行排除，标注了指定注解的类不要。</span><br><span class="line"> expression=<span class="string">""</span> 注解的全类名</span><br><span class="line"> type=<span class="string">"annotation"</span>按照类进行排除，指定的类不要。</span><br><span class="line"> expression=<span class="string">""</span> 类的全类名</span><br><span class="line"> --&gt;</span><br><span class="line"> &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.daq"</span> use-<span class="keyword">default</span>-filters=<span class="string">"false"</span>&gt;</span><br><span class="line">  &lt;context:include-filter type=<span class="string">"annotation"</span> expression=<span class="string">"com.daq.service.BookService"</span>/&gt;</span><br><span class="line">  &lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><h2 id="DL（依赖查找）"><a href="#DL（依赖查找）" class="headerlink" title="DL（依赖查找）"></a>DL（依赖查找）</h2><ul><li>DL已经被抛弃，因为它需要用户自己去使用API进行查找资源和组装对象，具有侵略性。</li></ul><h2 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h2><ul><li>DI是Spring使用的方式，容器负责组件的安装。</li><li><code>@Autowired</code>注解：Spring会自动为这个属性赋值，一定是去容器中找到这个属性对应的组件。自动注入值只是对引用而言。</li><li><code>@Autowired</code>原理：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BookService bookService;</span><br></pre></td></tr></table></figure><ol><li>先按照类型去容器中找到对应的组件<br><code>bookService = ioc.getBean(BookService.class);</code><pre><code>①. 找到一个，就直接赋值。②. 没找到:抛异常③. 找到多个，就按照变量名id继续匹配 ：bookService，bookServiceExt。如果没有匹配上，（是因为我们用变量名作为id继续匹配，没有那个变量名，就匹配不上）这时候，就要用到`@Qualifier(&quot;&quot;)`指定一个名作为id、</code></pre></li><li>由此发现：<code>@Autowired</code>找得到就装配，找不到就拉到。</li><li><code>@Autowired</code>注解的<strong>require</strong>的属性指定某个属性允许不被设置。这样就不会被强行装上。</li></ol><ul><li>方法上有<code>@Autowired</code>注解那么<br>①这个方法也会在bean创建的时候自动运行。<br>②这个方法上的每一个参数都会自动注入值。</li></ul><h2 id="Autowired和Resource的区别"><a href="#Autowired和Resource的区别" class="headerlink" title="Autowired和Resource的区别"></a>Autowired和Resource的区别</h2><ul><li><p><code>@Autowired</code>,<code>@Resource</code>,<code>@Inject</code>都是自动装配的意思。<br>①<code>@Autowired</code>：最强大，是Spring自己的注解。<br>②<code>@Resource</code>：j2ee，java的标准，功能一般。<br>③<code>@Inject</code>：EJB</p></li><li><p>区别：<br>①<code>@Autowired</code>离开Spring就没法用。<br>②<code>@Resource</code>扩展性强，因为他是java的标准，如果切换成另外一个容器框架，<code>@Resource</code>还是被支持的。</p></li></ul><h2 id="Spring的单元测试"><a href="#Spring的单元测试" class="headerlink" title="Spring的单元测试"></a>Spring的单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Spring的单元测试</span></span><br><span class="line"><span class="comment"> * 1.导包</span></span><br><span class="line"><span class="comment"> * 2.@ContextConfiguration(locations="")指定Spring配置文件的位置</span></span><br><span class="line"><span class="comment"> * 3.@RunWith指定哪种驱动进行单元测试，默认就是junit</span></span><br><span class="line"><span class="comment"> *  @RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment"> *   使用Spring的单元测试模块来执行了@Test注解的测试方法</span></span><br><span class="line"><span class="comment"> *   以前的@Test注解只是由Junit</span></span><br><span class="line"><span class="comment"> * 好处：我们不用ioc.getBean()获取组件，直接用Autowired组件，Spring为我们自动装配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IocTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");</span></span><br><span class="line"></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BookServlet bookServlet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(bookServlet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型依赖注入"><a href="#泛型依赖注入" class="headerlink" title="泛型依赖注入"></a>泛型依赖注入</h2><ul><li>泛型依赖注入原理</li></ul><p><img src="https://img-blog.csdnimg.cn/20200421102311681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>带泛型的父类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的类型：com.atguigu.service.BaseService</span></span><br><span class="line"><span class="comment">//带泛型的父类类型：com.atguigu.service.BaseService&lt;com.atguigu.bean.Book&gt;</span></span><br><span class="line"><span class="comment">//Spring中可以使用带泛型的父类类型来确定这个子类的类型</span></span><br><span class="line">System.out.println(bookService.getClass().getGenericSuperclass());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring使用注解自动装配&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Spring" scheme="http://daqwt.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring---bean的创建，赋值，获取</title>
    <link href="http://daqwt.top/Spring---bean%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%8E%B7%E5%8F%96/"/>
    <id>http://daqwt.top/Spring---bean%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%8E%B7%E5%8F%96/</id>
    <published>2020-05-01T13:01:19.000Z</published>
    <updated>2020-05-28T13:06:50.164Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring中bean的创建，赋值，以及获取。</p><a id="more"></a><h1 id="获取对象和赋值"><a href="#获取对象和赋值" class="headerlink" title="获取对象和赋值"></a>获取对象和赋值</h1><h2 id="（一）通过IOC容器根据id获取对象★"><a href="#（一）通过IOC容器根据id获取对象★" class="headerlink" title="（一）通过IOC容器根据id获取对象★"></a>（一）通过IOC容器根据id获取对象★</h2><p>1.导入<code>.jar</code>包</p><p><img src="https://img-blog.csdnimg.cn/20200413141504525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.建bean类，里面提供具体的<code>set/get</code>方法。</p><p><img src="https://img-blog.csdnimg.cn/20200413142010237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3.配置<code>.xml</code> 文件，注册组件</p><p><img src="https://img-blog.csdnimg.cn/20200413142116850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4.创建IOC对象，并且启动容器。</p><p><img src="https://img-blog.csdnimg.cn/20200413142053621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>5.使用的时候，就直接从容器中获取bean对象，但前提是，这个对象必须在配置文件中注册过，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册一个person对象，Spring 会自动创建这个对象 --&gt;</span><br><span class="line">&lt;!-- 一个bean标签可以注册一个组件 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"person01"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.daq.bean.Person"</span>&gt;</span><br><span class="line">&lt;property name="age" value="18"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="email" value="2829025551@qq.com"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="gender" value="男"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="name" value="代澳旗"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"person02"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.daq.bean.Person"</span>&gt;</span><br><span class="line">&lt;property name="age" value="20"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="email" value="2829025551@qq.com"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="gender" value="女"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="name" value="梧桐"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器帮我们创建好了对象</span></span><br><span class="line">Person bean1=(Person) ioc.getBean(<span class="string">"person01"</span>);</span><br><span class="line">Person bean2=(Person) ioc.getBean(<span class="string">"person02"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(bean1);</span><br><span class="line">System.out.println(bean2);</span><br></pre></td></tr></table></figure><h2 id="（二）根据bean的类型从容器中获取对象★"><a href="#（二）根据bean的类型从容器中获取对象★" class="headerlink" title="（二）根据bean的类型从容器中获取对象★"></a>（二）根据bean的类型从容器中获取对象★</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法二---通过对象类型，从容器中获取这个对象]</span></span><br><span class="line"><span class="comment"> * 但是如果ioc容器中这个类型的对象有多个，查找就会失败，报错。</span></span><br><span class="line"><span class="comment"> * 这种类型的对象，只能有一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person bean = ioc.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(bean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）调用有参构造器给对象赋值"><a href="#（三）调用有参构造器给对象赋值" class="headerlink" title="（三）调用有参构造器给对象赋值"></a>（三）调用有参构造器给对象赋值</h2><p>1.在bean类中，创建有参构造方法。<br><img src="https://img-blog.csdnimg.cn/20200413151220938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.在配置文件中，使用<code>constructor</code>标签给对象赋值。有几个参数，就用几次标签</p><p><img src="https://img-blog.csdnimg.cn/20200413151312412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3.在容器中通过id的方式获取对象。</p><p><img src="https://img-blog.csdnimg.cn/20200413151354704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="（四）通过P名称空间为bean赋值"><a href="#（四）通过P名称空间为bean赋值" class="headerlink" title="（四）通过P名称空间为bean赋值"></a>（四）通过P名称空间为bean赋值</h2><h2 id="（五）正确的为各种属性赋值"><a href="#（五）正确的为各种属性赋值" class="headerlink" title="（五）正确的为各种属性赋值"></a>（五）正确的为各种属性赋值</h2><p>1.测试使用null值 。<br>2.引用类型赋值（引用其他bean、引用内部bean）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"person01"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Person"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- lastName=<span class="string">"null"</span> --&gt;</span><br><span class="line">&lt;property name=<span class="string">"lastName"</span>&gt;</span><br><span class="line">&lt;!-- 进行复杂的赋值 --&gt;</span><br><span class="line">&lt;<span class="keyword">null</span> /&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- ref：代表引用外面的一个值 ;引用其他bean car = ioc.getBean(<span class="string">"car01"</span>) --&gt;</span><br><span class="line">&lt;!-- &lt;property name="car" ref="car01"&gt;&lt;/property&gt; --&gt;</span><br><span class="line">&lt;property name=<span class="string">"car"</span>&gt;</span><br><span class="line">&lt;!--对象我们可以使用bean标签创建 car = <span class="keyword">new</span> Car(); 引用内部bean；不能被获取到，只能内部使用 --&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Car"</span>&gt;</span><br><span class="line">&lt;property name="carName" value="自行车"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3.集合类型赋值（List、Map、Properties）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"person02"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Person"</span>&gt;</span><br><span class="line">&lt;!-- 如何为list类型赋值 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"books"</span>&gt;</span><br><span class="line">&lt;!-- books = <span class="keyword">new</span> ArrayList&lt;Book&gt;(); --&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;!-- list标签体中添加每一个元素 --&gt;</span><br><span class="line">&lt;bean class="com.atguigu.bean.Book" p:bookName="西游记"&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!-- 引用外部一个元素 --&gt;</span><br><span class="line">&lt;ref bean=<span class="string">"book01"</span> /&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Map&lt;String, Object&gt; maps; --&gt;</span><br><span class="line">&lt;property name=<span class="string">"maps"</span>&gt;</span><br><span class="line">&lt;!-- maps = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); --&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;!-- 一个entry代表一个键值对 --&gt;</span><br><span class="line">&lt;entry key="key01" value="张三"&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key="key02" value="18"&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key="key03" value-ref="book01"&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=<span class="string">"key04"</span>&gt;</span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Car"</span>&gt;</span><br><span class="line">&lt;property name="carName" value="宝马"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;entry key=<span class="string">"key05"</span>&gt;</span><br><span class="line">&lt;value&gt;李四&lt;/value&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;!-- &lt;entry key="key05"&gt; &lt;map&gt;&lt;/map&gt; &lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="keyword">private</span> Properties properties; --&gt;</span><br><span class="line">&lt;property name=<span class="string">"properties"</span>&gt;</span><br><span class="line">&lt;!-- properties = <span class="keyword">new</span> Properties();所有的k=v都是string --&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;!-- k=v都是string；值直接写在标签体中 --&gt;</span><br><span class="line">&lt;prop key="username"&gt;root&lt;/prop&gt;</span><br><span class="line">&lt;prop key="password"&gt;123456&lt;/prop&gt;</span><br><span class="line">&lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4.util名称空间创建集合类型的bean 级联属性赋值 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 级联属性赋值：   级联属性:属性的属性--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"person04"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Person"</span>&gt;</span><br><span class="line">&lt;!--为car赋值的时候。改变car的价格  --&gt;</span><br><span class="line">&lt;property name="car" ref="car01"&gt;&lt;/property&gt;</span><br><span class="line">&lt;!--  --&gt;</span><br><span class="line">&lt;property name="car.price" value="900000"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h1 id="工厂方式创建bean"><a href="#工厂方式创建bean" class="headerlink" title="工厂方式创建bean"></a>工厂方式创建bean</h1><h2 id="（六）通过继承实现bean配置信息的重用"><a href="#（六）通过继承实现bean配置信息的重用" class="headerlink" title="（六）通过继承实现bean配置信息的重用"></a>（六）通过继承实现bean配置信息的重用</h2><ul><li>不修改的信息就继承别人的，自己独有的信息，就修改。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--parent：指定当前bean的配置信息继承于哪个  --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"person06"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Person"</span> parent=<span class="string">"person05"</span>&gt;</span><br><span class="line">&lt;property name="lastName" value="李四"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="（七）通过abstract属性创建一个模板bean"><a href="#（七）通过abstract属性创建一个模板bean" class="headerlink" title="（七）通过abstract属性创建一个模板bean"></a>（七）通过abstract属性创建一个模板bean</h2><ul><li>抽象Bean只能用来被别人继承。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="keyword">abstract</span>=<span class="string">"true"</span>：这个bean的配置是一个抽象的，不能获取他的实例，只能被别人用来继承 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"person05"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.Person"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;property name="lastName" value="张三"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="age" value="18"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="gender" value="男"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="email" value="zhangsan@atguigu.com"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="（八）bean的作用域，分别创建单实例和多实例的bean★"><a href="#（八）bean的作用域，分别创建单实例和多实例的bean★" class="headerlink" title="（八）bean的作用域，分别创建单实例和多实例的bean★"></a>（八）bean的作用域，分别创建单实例和多实例的bean★</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 测试bean的作用域，分别创建单实例和多实例的bean</span><br><span class="line">bean的作用域:指定bean是否单实例，xxx；默认：单实例</span><br><span class="line"></span><br><span class="line">prototype:多实例</span><br><span class="line"><span class="number">1</span>）、容器启动默认不会去创建多实例bean。</span><br><span class="line"><span class="number">2</span>）、获取的时候创建这个bean。</span><br><span class="line"><span class="number">3</span>）、每次获取都会创建一个新的对象</span><br><span class="line">singleton:单实例的；默认情况下是单实例。</span><br><span class="line"><span class="number">1</span>）、在容器启动完成之前就已经创建好对象，保存在容器中了。</span><br><span class="line"><span class="number">2</span>）、任何获取都是获取之前创建好的那个对象。</span><br><span class="line"></span><br><span class="line">request:在web环境下，同一次请求创建一个Bean实例（没卵用）</span><br><span class="line">session:在web环境下，同一次会话创建一个Bean实例（没卵用）</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><h2 id="（九）静态-实例工厂方法创建bean，FactoryBean★"><a href="#（九）静态-实例工厂方法创建bean，FactoryBean★" class="headerlink" title="（九）静态/实例工厂方法创建bean，FactoryBean★"></a>（九）静态/实例工厂方法创建bean，FactoryBean★</h2><ul><li>有些简单的对象还好，因为属性少，但是有的对象属性很多，总不可能写一个抽象bean，让其他来继承吧，这个时候，就要用到工厂方法来创建了，</li><li>工厂模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- bean的创建默认就是框架利用反射<span class="keyword">new</span>出来的bean实例 --&gt;</span><br><span class="line">&lt;!-- 工厂模式：工厂帮我们创建对象，有一个专门帮我们创建对象的类，这个类就是工厂</span><br><span class="line">    如下面的：AirPlaneFactory </span><br><span class="line">AirPlane ap = AirPlaneFactory.getAirPlane(String jzName);</span><br><span class="line"></span><br><span class="line">静态工厂：工厂本身不用创建对象；通过静态方法调用，对象 = 工厂类.工厂方法名()；</span><br><span class="line">实例工厂：工厂本身需要创建对象；</span><br><span class="line">工厂类 工厂对象 = <span class="keyword">new</span> 工厂类();</span><br><span class="line">工厂对象.getAirPlane(<span class="string">"张三"</span>);</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><ul><li>静态工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneStaticFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AirPlaneStaticFactory.getAirPlane()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AirPlaneStaticFactory...正在为你造飞机"</span>);</span><br><span class="line">AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">airPlane.setFdj(<span class="string">"太行"</span>);</span><br><span class="line">airPlane.setFjsName(<span class="string">"lfy"</span>);</span><br><span class="line">airPlane.setJzName(jzName);</span><br><span class="line">airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">airPlane.setYc(<span class="string">"198.98m"</span>);</span><br><span class="line"><span class="keyword">return</span> airPlane;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="number">1</span>、静态工厂(不需要创建工厂本身)</span><br><span class="line"><span class="class"><span class="keyword">class</span>：指定静态工厂全类名</span></span><br><span class="line">factory-method:指定哪个方法是工厂方法</span><br><span class="line">constructor-arg：可以为方法传参</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"airPlane01"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.factory.AirPlaneStaticFactory"</span></span><br><span class="line">factory-method=<span class="string">"getAirPlane"</span>&gt;</span><br><span class="line">&lt;!-- 可以为方法指定参数 --&gt;</span><br><span class="line">&lt;constructor-arg value="李四"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>实例工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlaneInstanceFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">// new AirPlaneInstanceFactory().getAirPlane();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  AirPlane <span class="title">getAirPlane</span><span class="params">(String jzName)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AirPlaneInstanceFactory...正在造飞机"</span>);</span><br><span class="line">AirPlane airPlane = <span class="keyword">new</span> AirPlane();</span><br><span class="line">airPlane.setFdj(<span class="string">"太行"</span>);</span><br><span class="line">airPlane.setFjsName(<span class="string">"lfy"</span>);</span><br><span class="line">airPlane.setJzName(jzName);</span><br><span class="line">airPlane.setPersonNum(<span class="number">300</span>);</span><br><span class="line">airPlane.setYc(<span class="string">"198.98m"</span>);</span><br><span class="line"><span class="keyword">return</span> airPlane;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="number">2</span>、实例工厂使用 </span><br><span class="line">factory-method;指定这个实例工厂中哪个方法是工厂方法；</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"airPlaneInstanceFactory"</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.factory.AirPlaneInstanceFactory"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- factory-bean：指定当前对象创建使用哪个工厂</span><br><span class="line"><span class="number">1</span>、先配置出实例工厂对象</span><br><span class="line"><span class="number">2</span>、配置我们要创建的AirPlane使用哪个工厂创建</span><br><span class="line"><span class="number">1</span>）、factory-bean：指定使用哪个工厂实例</span><br><span class="line"><span class="number">2</span>）、factory-method：使用哪个工厂方法</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"airPlane02"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.atguigu.bean.AirPlane"</span></span><br><span class="line">factory-bean=<span class="string">"airPlaneInstanceFactory"</span> </span><br><span class="line">factory-method=<span class="string">"getAirPlane"</span>&gt;</span><br><span class="line">&lt;constructor-arg value="王五"&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>FactoryBean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了FactoryBean接口的类是Spring可以认识的工厂类；</span></span><br><span class="line"><span class="comment"> * Spring会自动的调用工厂方法创建实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *1、编写一个FactoryBean的实现类</span></span><br><span class="line"><span class="comment"> *2、在spring配置文件中进行注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBeanImple</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Book</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getObject：工厂方法；</span></span><br><span class="line"><span class="comment"> * 返回创建的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"MyFactoryBeanImple。。帮你创建对象..."</span>);</span><br><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">book.setBookName(UUID.randomUUID().toString());</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回创建的对象的类型；</span></span><br><span class="line"><span class="comment"> * Spring会自动调用这个方法来确认创建的对象是什么类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> Book<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * isSingleton：是单例？</span></span><br><span class="line"><span class="comment"> * false：不是单例</span></span><br><span class="line"><span class="comment"> * true：是单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- FactoryBean★(是Spring规定的一个接口);</span><br><span class="line">只要是这个接口的实现类，Spring都认为是一个工厂；</span><br><span class="line"><span class="number">1</span>、ioc容器启动的时候不会创建实例 </span><br><span class="line"><span class="number">2</span>、FactoryBean；获取的时候的才创建对象</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"myFactoryBeanImple"</span> </span><br><span class="line">class="com.atguigu.factory.MyFactoryBeanImple"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h1 id="引用外部属性文件★"><a href="#引用外部属性文件★" class="headerlink" title="引用外部属性文件★"></a>引用外部属性文件★</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 外部文件：dbconfig.properties</span><br><span class="line"></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=***</span><br><span class="line">jdbc.jdbcUrl=jdbc:mysql:<span class="comment">//localhost:3306/user</span></span><br><span class="line">jdbc.driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引用外部属性文件★依赖context名称空间  --&gt;</span><br><span class="line">&lt;!-- 数据库连接池作为单实例是最好的；一个项目就一个连接池，连接池里面管理很多连接。连接是直接从连接池中拿 --&gt;</span><br><span class="line">&lt;!-- 可以让Spring帮我们创建连接池对象，（管理连接池） --&gt;</span><br><span class="line">&lt;!-- 加载外部配置文件    固定写法  classpath:，表示引用类路径下的一个资源--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:dbconfig.properties"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- username是Spring的key中的一个关键字；</span><br><span class="line">为了防止配置文件中的key和spring自己的关键字冲突。我们可以给配置文件中的key加上一个前缀 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">&lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt;</span><br><span class="line">&lt;!-- $&#123;key&#125;动态取出配置文件中某个key对应的值 --&gt;</span><br><span class="line">&lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line"><span class="comment">//1、从容器中拿到连接池</span></span><br><span class="line"><span class="comment">//DataSource bean = (DataSource) ioc.getBean("dataSource");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、按照类型获取组件，可以获取到这个类型下的所有实现类子类等等...</span></span><br><span class="line">DataSource bean = ioc.getBean(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(bean.getConnection());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring中bean的创建，赋值，以及获取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Spring" scheme="http://daqwt.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring---基础了解</title>
    <link href="http://daqwt.top/%E4%BA%86%E8%A7%A3Spring/"/>
    <id>http://daqwt.top/%E4%BA%86%E8%A7%A3Spring/</id>
    <published>2020-04-29T09:02:46.000Z</published>
    <updated>2020-05-28T12:01:02.613Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大火的Spring框架，Spring就两点，IOC和AOP，依赖注入和切面编程，还有衍生出来的SpringMVC架构，SpringBoot更加简便，还有SpringCloud微服务。简便了开发，必学！！！</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200420105316590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><ul><li><strong>百度百科：</strong> Spring框架是一个开放源代码的J2EE应用程序框架，是<strong>针对bean的生命周期进行管理</strong>的轻量级<strong>容器</strong>（lightweight container）。</li><li>它提供IOC、AOP及Web MVC等等功能。</li><li><strong>Spring框架主要由七部分组成：</strong> Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。</li></ul><h2 id="应用场景有哪些？"><a href="#应用场景有哪些？" class="headerlink" title="应用场景有哪些？"></a>应用场景有哪些？</h2><ul><li>可以单独应用于构筑应用程序。</li><li><strong>应用于JEE应用程序之中：</strong> 和Struts、Webwork、Tapestry等众多Web框架组合使用，我们常用的SSM，SSH框架。</li><li><strong>应用于桌面应用程序以及小应用程序之中：</strong> 与 Swing等桌面应用程序AP组合。</li></ul><h2 id="Spring的最终目的？"><a href="#Spring的最终目的？" class="headerlink" title="Spring的最终目的？"></a>Spring的最终目的？</h2><ul><li><strong>Spring是为了替代重量级，企业级的Java技术。</strong></li><li><strong>简化java的开发：</strong><br>①基于POJO轻量级和<strong>最小入侵式开发</strong>。<br>②通过依赖注入和面向接口实现<strong>松耦合</strong>。<br>③基于切面和惯例进行<strong>声明式编程</strong>。<br>④通过减少切面和模板达到<strong>减少样板式代码</strong>。</li></ul><h2 id="如何做到简化java开发？"><a href="#如何做到简化java开发？" class="headerlink" title="如何做到简化java开发？"></a>如何做到简化java开发？</h2><ul><li><p><strong>侵入式概念</strong><br>①像<code>EJB</code>,<code>Struts</code>这些个传统框架，通常要实现特定的接口，继承特定的类才能增强功能，这样就改变了类的结构。<br>②像<code>Hibernate</code>，<code>Spring</code>这样的框架，在对现有的类结构不产生影响的前提上，就可以增强JavaBean的功能。</p></li><li><p><strong>松耦合</strong><br>①普通方法：面向接口编程，在DAO层和Service层之间通过DaoFactory等方法实现松耦合。<br>②Spring：通过IOC控制反转，实现松耦合。更灵活，更强大。</p></li><li><p><strong>切面编程</strong><br>①以前：动态代理就是一种切面编程。使用动态代理+注解的方式给Service层的方法添加权限。<br>②Spring：AOP切面编程（在执行某些代码之前，执行另外的代码）</p></li></ul><h2 id="核心思想是什么？"><a href="#核心思想是什么？" class="headerlink" title="核心思想是什么？"></a>核心思想是什么？</h2><p>在初次体验中先简单理解一下，后期在深入了解。</p><ul><li><strong>IOC（控制反转）：通过对象找到类</strong><br>通过DI（依赖注入）来实现控制反转，也就是说根据配置文件解析对象，通过配置文件中的bean注册对象，并获得类名及class，利用反射机制将其实例化后放入一个IOC容器持有bean信息的场所（HashMap），然后通过这个场所（HashMap）进行管理。</li><li><strong>AOP（切面编程）：相同的代码只需要写一次</strong><br>举个例子：就像过安检一样，每个人都要刷身份证，刷脸，安检扫描。但是不必要为每个人开一个安检口吧，重复步骤的代码也不必要反复写吧，只需要写一次，我们可以把每个纵向的控制流用一个切面阻隔，然后只留出一个口，你写好这段重复代码之后，只需要告诉Spring要把这段代码放到哪里去就行了。</li></ul><h2 id="优点有哪些？"><a href="#优点有哪些？" class="headerlink" title="优点有哪些？"></a>优点有哪些？</h2><ol><li><p>控制反转将对象的创建交给了spring,简化了开发，降低了代码之间的耦合性和侵入性。</p></li><li><p>方便对程序进行声明式事物管理，我们只需通过配置就可以完成对事物管理。</p></li><li><p>方便集成各种优秀的框架，spring不排斥各种优秀框架，其内部提供了对各种优秀框架如(struts2，hibernate,mybatis,quartz，jpa)等的直接支持。</p></li><li><p>方便对程序进行测试，spring对于Junit4的支持，可通过注解方便测试程序。</p></li><li><p>降低了JavaEE API的使用难度，JDBC,Javamail,远程调用等，spring对它们进行了封装，使这些API的使用难度大大降低。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大火的Spring框架，Spring就两点，IOC和AOP，依赖注入和切面编程，还有衍生出来的SpringMVC架构，SpringBoot更加简便，还有SpringCloud微服务。简便了开发，必学！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring全家桶" scheme="http://daqwt.top/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Spring" scheme="http://daqwt.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目的构建和部署</title>
    <link href="http://daqwt.top/Maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <id>http://daqwt.top/Maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E5%92%8C%E9%83%A8%E7%BD%B2/</id>
    <published>2020-04-28T09:02:46.000Z</published>
    <updated>2020-05-28T09:08:40.205Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用Maven命令，编译，执行，部署，等等，这一篇文章主要讲，maven的一件构建与部署。</p><a id="more"></a><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://img-blog.csdnimg.cn/20200518135620441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h2><ol><li>构建：项目从编译–&gt;测试–&gt;运行–&gt;打包–&gt;安装，整个过程都交给<code>maven</code> 进行管理，这个过程称为构建。</li><li>创建一个<code>maven</code>工程之后，在<code>cmd</code>中进入这个工程的本地文件夹下，然后输入一行代码：<code>mvn tomcat：run</code>，运行即可一键构建。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200504185147822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>mvn clean</code>：删除<code>target/</code></li><li><code>mvn compile</code>：编译,会在项目下生成一个<code>targe</code>文件夹。</li><li><code>mvn test</code>：执行test/java 源码包中的所有的<code>Junit</code>测试方法</li><li><code>mvn package</code>：将项目打成<code>war</code>包，会在<code>targe</code>下生成一个<code>war</code>包</li><li><code>mvn install</code>：把项目install到本地仓库，在你<code>mvn</code>仓库中，会发现多出来一个文件夹，具体位置就要看控制台的提示了。</li><li><code>mvn deploy</code> ： 部署，把打包后的文件安装到私服</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><code>jar</code>包和<code>war</code>包的区别</li></ul><ol><li><code>jar包</code>：<strong>类的归档文件</strong>，我们没用<code>maven</code>之前，都是通过引入别人的<code>jar</code>包，简单来说，就是别人将已经写好的一些类封装起来打成<code>jar</code>包。我们将这些<code>jar</code>包放在lib目录下，可以直接使用这些jar包中的类和属性。</li><li><code>war包</code>： 可以直接运行的web模块，通常用于网站，打成包部署到容器中。war包里面包括编译形成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。</li><li><code>区别</code>：<code>war</code>代表了一个Web应用程序，<code>jar</code>是类的归档文件。</li><li>打<code>war</code>适用于产品发布阶段，因为这个时候，不需要做太大改动了，而平时修改项目的时候，每次都要打包，就很不方便，所以在开发阶段，通常将Servlet源文件放到Web应用程序目录的src子目录下，以便和Web资源文件区分。在最终建立WAR文件时，只需要将src目录从Web应用程序目录中移走，就可以打包了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以使用Maven命令，编译，执行，部署，等等，这一篇文章主要讲，maven的一件构建与部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Maven" scheme="http://daqwt.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Maven仓库的安装与配置</title>
    <link href="http://daqwt.top/Maven%E4%BB%93%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://daqwt.top/Maven%E4%BB%93%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-28T08:55:01.000Z</published>
    <updated>2020-05-28T09:01:56.595Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以前写项目的时候，总是要去找jar包，导入依赖，项目才能正常写下去，但是搭建好本地maven之后，我们可以用maven构建工程，在pom.xml中，引入依赖，就不用千方百计的找jar包了。最终也是通过maven，将项目打成war包，发布到服务器上。</p><a id="more"></a><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><h3 id="何为Maven？"><a href="#何为Maven？" class="headerlink" title="何为Maven？"></a>何为Maven？</h3><ul><li>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</li></ul><h3 id="maven有什么作用？"><a href="#maven有什么作用？" class="headerlink" title="maven有什么作用？"></a>maven有什么作用？</h3><ul><li>最重要的作用就是：<code>jar</code>包管理<br>①从<code>Maven</code>中央仓库获取标准规范的<code>jar</code>包以及相关依赖的<code>jar</code>包，避免自己手残下载错了包，还能避免一些包冲突。<br>②本地仓库统一管理<code>jar</code>包，使<code>jar</code>包与项目分离，减轻项目体积。</li></ul><h3 id="有什么好处？"><a href="#有什么好处？" class="headerlink" title="有什么好处？"></a>有什么好处？</h3><ul><li>maven是<code>java</code>语言编写的，所以是跨平台的，可以再<code>windows</code>，<code>linux</code>上使用。</li><li>使项目结构清晰。</li><li>多工程开发，将模块拆分成若干工程，利于团队协作开发。</li><li><strong>一键构建项目：</strong> 使用命令可以对项目一键构建，操作系统中无需安装<code>eclipse</code>和<code>tomcat</code></li></ul><h2 id="一、下载maven"><a href="#一、下载maven" class="headerlink" title="一、下载maven"></a>一、下载maven</h2><ul><li>下载网址：<a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a><br><img src="https://img-blog.csdnimg.cn/20200224154115658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="二、配置maven环境变量"><a href="#二、配置maven环境变量" class="headerlink" title="二、配置maven环境变量"></a>二、配置maven环境变量</h2><ul><li>MAVEN_HOME</li></ul><p><img src="https://img-blog.csdnimg.cn/2020022416291727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>path</li></ul><p><img src="https://img-blog.csdnimg.cn/2020022416300398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>检查</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224163022731.png" alt="在这里插入图片描述"></p><h2 id="三、配置本地仓库，修改conf"><a href="#三、配置本地仓库，修改conf" class="headerlink" title="三、配置本地仓库，修改conf"></a>三、配置本地仓库，修改conf</h2><ul><li>找到conf文件夹，打开setting.xml文件</li><li>在 settings 标签中，添加 licalRepository 标签，中间填写maven下载jar包到本地计算机的存储目录</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224154651502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>找到 mirrors标签，在其中添加如下配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200224155057668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>保存退出</li><li><strong>mvn -help:system</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200224170125502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200224170219558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>maven</code>工程找<code>jar</code>包的过程：</li></ul><ol><li>优先查找本地</li><li>本地找不到，则从私服上查找，找到后下载到本地仓库</li><li>私服上找不到，则从中央仓库查找，找到后下载到私服，最后下载到本地仓库</li><li>总结：最终<code>maven</code>都会把<code>jar</code>下载到本地仓库，<code>maven</code>工程再引用本地仓库的<code>jar</code>包。</li></ol><h2 id="四、Eclipse-安装-maven插件"><a href="#四、Eclipse-安装-maven插件" class="headerlink" title="四、Eclipse 安装 maven插件"></a>四、Eclipse 安装 maven插件</h2><ol><li>下载地址：<a href="http://www.pc6.com/softview/SoftView_428621.html">http://www.pc6.com/softview/SoftView_428621.html</a></li></ol><ol start="2"><li>将下载的包中的两个文件中的jar包分别放入eclipse安装包下的相同文件名里。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200224183159731.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200224183216915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="6"><li>重启eclipse，点击Windows—preference，可以看到，有了maven选项</li></ol><p><img src="https://img-blog.csdnimg.cn/20200224183451941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="五、Eclipse配置maven"><a href="#五、Eclipse配置maven" class="headerlink" title="五、Eclipse配置maven"></a>五、Eclipse配置maven</h2><ul><li>依次点击Windows—Preferences—Maven—User Setting</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224185019564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>点击Windows—show view—other—maven</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224185114475.png" alt="在这里插入图片描述"></p><ul><li>出现的问题</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224185235371.png" alt="在这里插入图片描述"></p><h2 id="六、STS配置maven"><a href="#六、STS配置maven" class="headerlink" title="六、STS配置maven"></a>六、STS配置maven</h2><ol><li><p>修改STS中默认maven,点击<code>windows--&gt;prefences--&gt;maven--&gt;installation--&gt;add</code>，添加本地安装maven的路径。</p></li><li><p>点击<code>windows--&gt;prefences--&gt;maven--&gt;User Setting</code>，找到<code>setting.xml</code>的路径。填入，并且下面的<code>jar</code>地址他会自动识别。目录就是你创建的本地存放<code>jar</code>包的文件夹。</p></li><li><p>IDEA自带Maven，真香！！！！</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以前写项目的时候，总是要去找jar包，导入依赖，项目才能正常写下去，但是搭建好本地maven之后，我们可以用maven构建工程，在pom.xml中，引入依赖，就不用千方百计的找jar包了。最终也是通过maven，将项目打成war包，发布到服务器上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Maven" scheme="http://daqwt.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis环境搭建及使用</title>
    <link href="http://daqwt.top/Mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://daqwt.top/Mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-28T08:33:36.000Z</published>
    <updated>2020-05-28T08:46:10.745Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇记录MyBatis的环境搭建以及使用过程</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-pom-xml添加依赖"><a href="#1-pom-xml添加依赖" class="headerlink" title="1.pom.xml添加依赖"></a>1.pom.xml添加依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;        </span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-新建数据表account"><a href="#2-新建数据表account" class="headerlink" title="2.新建数据表account"></a>2.新建数据表account</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use mybatis;</span><br><span class="line"><span class="function">create table <span class="title">t_account</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span> primary key auto_increment,</span></span></span><br><span class="line"><span class="function"><span class="params">username varchar(<span class="number">11</span>)</span>,</span></span><br><span class="line"><span class="function">password <span class="title">varchar</span><span class="params">(<span class="number">11</span>)</span>,</span></span><br><span class="line"><span class="function">age <span class="keyword">int</span></span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><h3 id="3-新建数据表对应的实体类Account"><a href="#3-新建数据表对应的实体类Account" class="headerlink" title="3.新建数据表对应的实体类Account"></a>3.新建数据表对应的实体类Account</h3><ul><li>在<code>pom.xml</code>中引入<code>lombok</code>可以简化实体类的编写。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写<code>Account</code>实体类的时候加注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.southwind.entity;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建Mybatis配置文件config-xml"><a href="#4-创建Mybatis配置文件config-xml" class="headerlink" title="4.创建Mybatis配置文件config.xml"></a>4.创建Mybatis配置文件config.xml</h3><ul><li>要先加<code>dtd</code>的配置文档<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置MyBatis运行环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置JDBC事务管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- POOLED配置JDBC数据源连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?</span></span></span><br><span class="line"><span class="tag"><span class="string">useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"daq"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Mybatis开发的两种方式"><a href="#Mybatis开发的两种方式" class="headerlink" title="Mybatis开发的两种方式"></a>Mybatis开发的两种方式</h2><ul><li><code>Mybatis</code>开发的两种方式，使用原生接口和使用<code>Mapper</code>代理实现自定义接口。<h3 id="（一）使用原生接口"><a href="#（一）使用原生接口" class="headerlink" title="（一）使用原生接口"></a>（一）使用原生接口</h3>Mybatis框架需要开发者自定义SQL语句，写在<code>Mapper.xml</code>文件中，实际开发中会为每个实体类创建对应的<code>Mapper.xml</code>，定义管理对象数据的SQL。</li></ul><ol><li><p>为<code>account</code>实体类创建<code>AccountMapper.xml</code>,</p><p><strong>如下：</strong> 先引入<code>dtd</code>头文件。<br><code>namesapce</code>通常设置为文件所在包+文件名的形式。<br><code>insert</code>标签—&gt;添加，<code>select</code>—&gt;查询，<code>update</code>—&gt;更新，<code>delete</code>—&gt;删除<br><code>id</code>使实际调用<code>MyBatis</code>方法时需要用到的参数。<br><code>parameterType</code>是调用对应方法时参数的数据类型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.southwind.mapper.AccoutMapper"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"save"</span> parameterType=<span class="string">"com.southwind.entity.Account"</span>&gt;</span><br><span class="line">      <span class="function">insert into <span class="title">t_account</span><span class="params">(username,password,age)</span> <span class="title">values</span><span class="params">(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在全局配置文件<code>config.xml</code>中注册<code>AccountMapper.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册AccountMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/southwind/mapper/AccountMapper.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>调用<code>Mybatis</code>原生接口来执行添加操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载MyBatis配置文件</span></span><br><span class="line">        InputStream inputStream = Test.class.getClassLoader().getResourceAsStream("config.xml");</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        String statement = <span class="string">"com.southwind.mapper.AccoutMapper.save"</span>;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">1L</span>,<span class="string">"张三"</span>,<span class="string">"123123"</span>,<span class="number">22</span>);</span><br><span class="line">        sqlSession.insert(statement,account);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<code>maven</code>工程不会读取java中的配置文件，他默认只会读取<code>resource</code>中的，解决办法就是，在<code>pom.xml</code>中添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（二）使用Mapper代理实现自定义接口"><a href="#（二）使用Mapper代理实现自定义接口" class="headerlink" title="（二）使用Mapper代理实现自定义接口"></a>（二）使用Mapper代理实现自定义接口</h3><p>只需要把方法定义好，相应的<code>Sql</code>语句在<code>Mapper.xml</code>中定义好，其他的就不用管了。只需要拿到对象就可以了。</p><ol><li>自定义接口，定义好相关的业务方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById2</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByNameAndAge</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">count2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findNameById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findByIds</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建接口对应的<code>Mapper.xml</code>,定义接口方法对应的SQL语句。</li></ol><p><code>statement</code>标签可根据SQL执行的业务选择<code>insert,delete,update,select</code><br><code>Mybatis</code>框架会根据规则来自动创建接口实现类的代理对象<br>规则：</p><ul><li><code>Mybatis.xml</code>中<code>namespace</code>为接口的全类名。</li><li><code>Mybatis.xml</code>中<code>statement</code>的id为接口中对应的方法名。</li><li><code>Mybatis.xml</code>中<code>statement</code>的<code>parmeterType</code>和接口中对应方法的参数类型一致。</li><li><code>Mybatis.xml</code>中<code>statement</code>的<code>resultType</code>和接口中对应方法的返回值类型一致。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.southwind.repository.AccountRepository"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"com.southwind.entity.Account"</span>&gt;</span></span><br><span class="line">insert into t_account(username,password,age) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.southwind.entity.Account"</span>&gt;</span>update t_account </span><br><span class="line">set username = #&#123;username&#125;,password = #&#123;password&#125;,age= #&#123;age&#125; where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteById"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">delete from t_account where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"com.southwind.entity.Account"</span>&gt;</span></span><br><span class="line">select * from t_account</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"com.southwind.entity.Account"</span>&gt;</span></span><br><span class="line">select * from t_account where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>config.xml</code>中注册<code>AccountRepository.xml</code>,追加一个<code>mapper</code>标签即可。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;mappers&gt;</span><br><span class="line">   &lt;mapper resource="com/southwind/mapper/AccountMapper.xml"&gt;&lt;/mapper&gt;</span><br><span class="line">   &lt;mapper resource="com/southwind/repository/AccountRepository.xml"&gt;&lt;/mapper&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试增删改查</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = Test.class.getClassLoader().getResourceAsStream("config.xml");</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取实现接口的代理对象，这就设计到动态代理，CGLib动态代理具体类，获取到代理对象</span></span><br><span class="line">        AccountRepository accountRepository = sqlSession.getMapper(AccountRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加对象</span></span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">3L</span>,<span class="string">"王五"</span>,<span class="string">"111111"</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">int</span> result = accountRepository.save(account);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询全部对象</span></span><br><span class="line">         List&lt;Account&gt; list = accountRepository.findAll();</span><br><span class="line">         <span class="keyword">for</span> (Account account:list)&#123;</span><br><span class="line">              System.out.println(account);</span><br><span class="line">         &#125;</span><br><span class="line">         sqlSession.close();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过id查询对象</span></span><br><span class="line">         Account account = accountRepository.findById(<span class="number">3L</span>);</span><br><span class="line">         System.out.println(account);</span><br><span class="line">         sqlSession.close();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//修改对象</span></span><br><span class="line">         Account account = accountRepository.findById(<span class="number">3L</span>);</span><br><span class="line">         account.setUsername(<span class="string">"小明"</span>);</span><br><span class="line">         account.setPassword(<span class="string">"000"</span>);</span><br><span class="line">         account.setAge(<span class="number">18</span>);</span><br><span class="line">         <span class="keyword">int</span> result = accountRepository.update(account);</span><br><span class="line">         sqlSession.commit();</span><br><span class="line">         System.out.println(result);</span><br><span class="line">         sqlSession.close();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//通过id删除对象</span></span><br><span class="line">         <span class="keyword">int</span> result = accountRepository.deleteById(<span class="number">3L</span>);</span><br><span class="line">         System.out.println(result);</span><br><span class="line">         sqlSession.commit();</span><br><span class="line">         System.out.println(accountRepository.findByName(<span class="string">"张三"</span>));</span><br><span class="line">         Long id = Long.parseLong(<span class="string">"1"</span>);</span><br><span class="line">         System.out.println(accountRepository.findById2(id));</span><br><span class="line">         System.out.println(accountRepository.findByNameAndAge(<span class="string">"张三"</span>,<span class="number">22</span>));</span><br><span class="line">         System.out.println(accountRepository.count());</span><br><span class="line">         System.out.println(accountRepository.count2());</span><br><span class="line">         System.out.println(accountRepository.findNameById(<span class="number">1L</span>));</span><br><span class="line">         sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这篇记录MyBatis的环境搭建以及使用过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis+Hibernate" scheme="http://daqwt.top/categories/MyBatis-Hibernate/"/>
    
    
      <category term="Mybatis" scheme="http://daqwt.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis基础了解</title>
    <link href="http://daqwt.top/Mybatis%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/"/>
    <id>http://daqwt.top/Mybatis%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</id>
    <published>2020-04-28T08:33:36.000Z</published>
    <updated>2020-05-28T08:43:32.743Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有另一个框架就是MyBatis，这也是现在很火的SSM框架中的M，由于Hibernate框架自动生成sql，那也就意味着不能优化sql语句，虽然有<code>HQL</code>但是，难写难理解，也没什么好的。后来出现了轻量级的MyBatis框架，更有不久前推出的MyBatis Plus，开发中自然是更加轻便。</p><a id="more"></a><h2 id="持久层概述"><a href="#持久层概述" class="headerlink" title="持久层概述"></a>持久层概述</h2><ul><li>持久层的技术有：<code>JDBC</code>，<code>Hibernate</code>，<code>SpringDAO</code>，<code>Mybatis</code>，<code>Spring DATA JPA</code></li><li><code>JDBC</code>很容易理解，步骤简洁明了，但是重复代码太多了，增加程序员的工作量。</li><li><code>Hibernate</code>是一个比较老旧的框架，用起来十分舒服，不用写sql代码，自动根据数据库生成sql语句也就意味着不能优化sql语句，虽然有<code>HQL</code>但是，难写难理解，也没什么好的。</li><li><code>SpringDAO</code>就是<code>JDBC</code>的一层封装，类似于<code>dbutils</code></li><li><code>MyBatis</code> 避免了几乎所有的 <code>JDBC</code> 代码和手动设置参数以及获取结果集。<code>MyBatis</code> 可以使用简单的 <code>XML</code> 或注解来配置和映射原生信息，将接口和 Java 的 <code>POJOs(Plain Ordinary Java Object</code>,（普通的 Java对象)映射成数据库中的记录。 </li></ul><h2 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h2><ul><li><code>MyBatis</code> 原来是<code>apache</code>的一个开源项目<code>iBatis</code>, 2010年这个项目迁移，并且改名为<code>MyBatis</code>。它是<strong>一个基于<code>Java</code>的持久层框架</strong>。</li><li>通常与<code>Spring MVC</code>和<code>Spring</code>整合，也就是我们所说的<code>SSM</code>。</li><li>这是<code>Mybatis</code>的<a href="http://www.mybatis.cn/">中文官方文档</a></li><li>这是<code>Spring整合MyBatis</code>的<a href="http://mybatis.org/spring/zh/index.html">官方文档</a></li></ul><h2 id="三层功能架构"><a href="#三层功能架构" class="headerlink" title="三层功能架构"></a>三层功能架构</h2><ol><li><strong>API接口层：</strong> 提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li><strong>数据处理层：</strong> 负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li><strong>基础支撑层：</strong> 负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ol><h2 id="核心接口和类"><a href="#核心接口和类" class="headerlink" title="核心接口和类"></a>核心接口和类</h2><ul><li>业务逻辑怎么连接到框架内部？<br>就是这个<code>SqlSession</code>用来连接。</li><li>可以看到这个流程有点像工厂方法模式，最终的目的是拿到<code>SqlSession</code>，开发的时候就调用他的接口和方法进行开发。<br><img src="https://img-blog.csdnimg.cn/2020043014061749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h2><p><strong>优点：</strong><br>①简单易学，本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件。<br>②灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能。而且现在也有工具可以不使用xml配置文件了：<a href="https://mp.baomidou.com/">mybatis - puls</a><br>③解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。<br>④提供映射标签，支持对象与数据库的orm字段关系映射。<br>⑤提供对象关系映射标签，支持对象关系组建维护。<br>⑥提供xml标签，支持编写动态sql。</p><p><strong>缺点：</strong><br>①编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。<br>②SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。<br>③框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。<br>④<strong>二级缓存机制不佳。</strong></p><h2 id="核心接口和类-1"><a href="#核心接口和类-1" class="headerlink" title="核心接口和类"></a>核心接口和类</h2><ul><li>最终都是通过<code>SqlSession</code>这个对象与我们的java程序建立关系。<br><img src="https://img-blog.csdnimg.cn/20200514093356271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h2></li><li><code>Mybatis</code>是数据库持久层的技术，主要和数据库打交道。</li><li>学会使用<code>Mybatis</code>，掌握配置文件的编写。</li><li>了解<code>Mybatis</code>的逆向工程，缓存，代理</li><li>一对多，一对一，多对多</li><li>学会整合<code>Spring</code>和<code>Mybatis</code>，也就是<code>SSM</code>中的后两者。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;还有另一个框架就是MyBatis，这也是现在很火的SSM框架中的M，由于Hibernate框架自动生成sql，那也就意味着不能优化sql语句，虽然有&lt;code&gt;HQL&lt;/code&gt;但是，难写难理解，也没什么好的。后来出现了轻量级的MyBatis框架，更有不久前推出的MyBatis Plus，开发中自然是更加轻便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis+Hibernate" scheme="http://daqwt.top/categories/MyBatis-Hibernate/"/>
    
    
      <category term="Mybatis" scheme="http://daqwt.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate使用规范</title>
    <link href="http://daqwt.top/Hibernate%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://daqwt.top/Hibernate%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</id>
    <published>2020-04-27T08:33:36.000Z</published>
    <updated>2020-05-28T08:39:29.926Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Hibernate这个数据库框架的时候，有很多需要注意的地方。</p><a id="more"></a><h2 id="实体类编写规则"><a href="#实体类编写规则" class="headerlink" title="实体类编写规则"></a>实体类编写规则</h2><ol><li>实体类的属性都是私有的</li><li>私有属性都有公开的<code>get，set</code>方法来操作</li><li>要求实体类有属性作为唯一值（一般使用id值）</li><li>实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类</li></ol><ul><li>八个基本数据类型对应的包装类<br><code>int</code>—&gt;<code>Integer</code>,<code>char</code>—&gt;<code>Character</code>,其他都是首字母大写，例如<code>double</code>—&gt;<code>Double</code></li><li>为什么要用包装类？<br>因为包装类相当于操作一个对象，它可以为<code>null</code>值，但是基本数据类型就不可以。数据库中有字段为<code>null</code>的情况。<h2 id="hibernate主键生成策略"><a href="#hibernate主键生成策略" class="headerlink" title="hibernate主键生成策略"></a>hibernate主键生成策略</h2></li><li><code>hibernate</code>要求实体类中有一个属性作为唯一值，对应表主键，主键也有不同的生成策略。主键可以是自增长，也可以是<code>UUID</code>生成，<code>hibernate</code>中也提供了很多种主键生成策略。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator class="native"&gt;&lt;/generator&gt;</span><br></pre></td></tr></table></figure></li><li><code>class</code>属性中有很多值：</li></ul><ol><li><code>native</code>： 根据使用的数据库帮选择哪个值</li><li><code>uuid</code>： 之前<code>web</code>阶段写代码生成<code>uuid</code>值，<code>hibernate</code>帮我们生成<code>uuid</code>值</li></ol><ul><li>如何使用<code>uuid</code>？</li></ul><ol><li>修改实体类中<code>uid</code>的类型为<code>string</code>，修改<code>get(),set()</code>方法的类型。</li><li>在配置文件中，换成<code>uuid</code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator class="uuid"&gt;&lt;/generator&gt;</span><br></pre></td></tr></table></figure></li><li>在<code>hibernateUtils</code>类中加入<code>main()</code>方法，让他执行。<h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2></li></ol><ul><li><strong>添加操作</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"张三"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">user.setAddress(<span class="string">"上海"</span>);</span><br><span class="line"><span class="comment">//调用session的方法进行添加</span></span><br><span class="line">session.save(user);</span><br></pre></td></tr></table></figure><ul><li><strong>根据id查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.根据id查询</span><br><span class="line">调用session里面的get方法</span><br><span class="line">第一个参数:实体类的<span class="class"><span class="keyword">class</span></span></span><br><span class="line">第二个参数:id值</span><br><span class="line">User user = session.get(User<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">需要事先在User实体类中重写tosring方法</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><ul><li><strong>修改操作</strong></li></ul><ol><li>先根据id查询出来，然后再修改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.修改操作</span><br><span class="line">先根据id查询出来，调用session里面的get方法</span><br><span class="line">User user = session.get(User<span class="class">.<span class="keyword">class</span>, 2)</span>;</span><br><span class="line">向返回的user对象中设置修改之后的值</span><br><span class="line">user.setUsername(<span class="string">"我的桐宝"</span>);</span><br><span class="line">调用session中update方法修改</span><br><span class="line">session.update(user);</span><br></pre></td></tr></table></figure><ul><li><strong>删除操作</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.删除操作</span><br><span class="line">方法一:先根据id查询出来，调用session里面的get方法</span><br><span class="line">User user = session.get(User<span class="class">.<span class="keyword">class</span>, 3)</span>;</span><br><span class="line">session.delete(user);</span><br><span class="line"> </span><br><span class="line">方法二:</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUid(<span class="number">3</span>);</span><br><span class="line">session.delete(user);</span><br></pre></td></tr></table></figure><h2 id="实体类对象状态"><a href="#实体类对象状态" class="headerlink" title="实体类对象状态"></a>实体类对象状态</h2><ol><li>瞬时态：对象里面没有id值，对象与<code>session</code>没有关联</li><li>持久态：对象里有id值，对象与<code>session</code>关联</li><li>托管态：对象里有id值，但是与<code>session</code>无关<h2 id="hibernate缓存"><a href="#hibernate缓存" class="headerlink" title="hibernate缓存"></a>hibernate缓存</h2></li></ol><ul><li><strong>什么是缓存？</strong><br>数据存到数据库中，数据库本身是文件系统，使用流的方式操作文件，效率并不是很高，所以把数据存到<code>内存</code>中，不需要使用流的方式，可以直接从内存中读取数据 ，提升读取效率。</li><li><code>hibernate</code>框架提供很多优化的方法，<code>hibernate</code>缓存就是一种优化方法。<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3></li></ul><ol><li><code>hibernate</code>一级缓存默认是打开的</li><li><code>hibernate</code>一级缓存使用范围就是<code>session</code>的范围，从<code>session</code>创建到关闭。</li><li><code>hibernate</code>一级缓存中，存储的数据必须是<code>持久态</code>的数据</li></ol><h3 id="验证一级缓存存在"><a href="#验证一级缓存存在" class="headerlink" title="验证一级缓存存在"></a>验证一级缓存存在</h3><ul><li><strong>验证方式：</strong></li></ul><ol><li>首先根据id查询对象，返回对象</li><li>再次根据id查询，用<code>debug</code>运行，看到控制台不会出现重新sql语句 ，证明他去查缓存了。</li></ol><ul><li><strong>一级缓存执行流程：</strong><br><img src="https://img-blog.csdnimg.cn/20200502150153627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>一级缓存执行特性：</strong></li></ul><ol><li>持久态自动更新数据库，快照区不相同就更新，相同不更新<br><img src="https://img-blog.csdnimg.cn/20200502155326533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ol><li>目前已经不使用了，现在有替代技术：<code>redis</code></li><li>二级缓存不是默认打开的需要配置</li><li>二级缓存使用范围，是<code>sessionFactory</code>的范围。</li></ol><h2 id="事务代码规范写法"><a href="#事务代码规范写法" class="headerlink" title="事务代码规范写法"></a>事务代码规范写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.代码结构：</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">开启事务</span><br><span class="line">提交事务</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">回滚事务</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">关闭事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">事务的规范写法</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sessionFactory = HibernateUtils.getSesionFactory();</span><br><span class="line">session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"天才"</span>);</span><br><span class="line">user.setPassword(<span class="string">"1111"</span>);</span><br><span class="line">user.setAddress(<span class="string">"sahnghai "</span>);</span><br><span class="line">session.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line">tx.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">session.close();</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hibernate绑定session"><a href="#Hibernate绑定session" class="headerlink" title="Hibernate绑定session"></a>Hibernate绑定session</h2><ul><li><code>session</code>类似于<code>JDBC</code>的<code>connection</code>，之前web时候学过的<code>threadLocal</code></li><li>帮助实现与本地线程绑定<code>session</code>，我们只需要配置即可，不用去关心如何实现的。</li><li>获取与本地线程<code>session</code></li></ul><ol><li>在hibernate核心配置文件中配置</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置session绑定本地线程 --&gt;</span><br><span class="line">&lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在工具类中提供返回与本地线程帮的session的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSessionobject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory.getCurrentSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.注意不要关闭<code>sessionFactory</code>,关闭之后会报错。</p><h2 id="hibernate的其他API"><a href="#hibernate的其他API" class="headerlink" title="hibernate的其他API"></a>hibernate的其他API</h2><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><ul><li>使用query对象，不需要写sql语句，但是写hql语句</li></ul><ol><li>hql：<code>hibernate query language</code>，<code>hibernate</code>提供的查询语言，这个hql语句和普通sql语句很相似</li><li>hql和sql语句区别：<br>使用sql操作表和表字段<br>使用hql操作实体类和属性</li></ol><ul><li><p>hql语句 查询所有：<br>（1）from 实体类名称</p></li><li><p>Query对象使用<br>（1）创建Query对象<br>（2）调用query对象里面的方法得到结果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200502171400879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Criteria"><a href="#Criteria" class="headerlink" title="Criteria"></a>Criteria</h3><ol><li><p>使用这个对象查询操作，但是使用这个对象时候，不需要写语句，直接调用方法实现</p></li><li><p>实现过程：</p></li></ol><ul><li>创建<code>criteria</code>对象</li><li>调用对象里面的方法得到结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200502171517354.png" alt="在这里插入图片描述"></p><h3 id="SQLQuery"><a href="#SQLQuery" class="headerlink" title="SQLQuery"></a>SQLQuery</h3><ol><li><p>使用hibernate时候，调用底层sql实现</p></li><li><p>实现过程:</p></li></ol><ul><li>创建对象</li><li>调用对象的方法得到结果</li></ul><p><strong>实现方法一：返回list集合每部分是数组</strong><br><img src="https://img-blog.csdnimg.cn/2020050217162070.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020050217175178.png" alt="在这里插入图片描述"></p><p><strong>实现方法二：返回list中每部分是对象形式</strong></p><p><img src="https://img-blog.csdnimg.cn/20200502171933504.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200502171939376.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用Hibernate这个数据库框架的时候，有很多需要注意的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis+Hibernate" scheme="http://daqwt.top/categories/MyBatis-Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://daqwt.top/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate环境搭建及使用</title>
    <link href="http://daqwt.top/Hibernate%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://daqwt.top/Hibernate%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-26T08:33:36.000Z</published>
    <updated>2020-05-28T08:36:40.199Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文记录Hibernate的环境搭建及使用。</p><a id="more"></a><h2 id="导入Hibernate的jar包"><a href="#导入Hibernate的jar包" class="headerlink" title="导入Hibernate的jar包"></a>导入Hibernate的jar包</h2><p><img src="https://img-blog.csdnimg.cn/20200501150613612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="创建实体类和数据库表"><a href="#创建实体类和数据库表" class="headerlink" title="创建实体类和数据库表"></a>创建实体类和数据库表</h2><ul><li>创建实体类，要求属性唯一，目前手动创建，以后可以逆向工程自动创建实体类。</li><li>根据实体类中的属性，创建数据表。其实在使用hibernate的时候，不需要手动创建表。也会自动创建出来。</li></ul><h2 id="建立映射关系"><a href="#建立映射关系" class="headerlink" title="建立映射关系"></a>建立映射关系</h2><p>使用配置文件，将实体类和数据库表一一对应起来（映射关系）</p><ul><li>创建<code>xml</code>格式的配置文件</li></ul><p>1.映射配置文件名称和位置没有固定要求。<br>2.建议：在实体类所在的包里创建，<code>实体类名称.hbm.xml</code></p><ul><li>配置是<code>xml</code>格式，在配置文件中首先引入<code>xml</code>约束</li></ul><p>3.在<code>hibernate</code>中引入<code>dtd</code>约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插入这行代码在xml文件开头：</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC </span><br><span class="line">    <span class="string">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line">    <span class="string">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"</span>&gt;</span><br></pre></td></tr></table></figure><p>4.配置映射关系</p><p><img src="https://img-blog.csdnimg.cn/20200501154600799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="引入约束文件，解决提示问题"><a href="#引入约束文件，解决提示问题" class="headerlink" title="引入约束文件，解决提示问题"></a>引入约束文件，解决提示问题</h2><ul><li>可以看出来，在写<code>xml</code>文件的时候，默认是没有补全提示的，因为没有导入约束，所以我们需要倒入约束，才能使用补全提示功能，这样就会避免自己写的过程中出错。也方便敲代码。</li></ul><ol><li>复制这句话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.hibernate.org/dtd/hibernate-mapping-3.0.dtd</span></span><br></pre></td></tr></table></figure><ol start="2"><li>点开<code>windows--&gt;preference--&gt;XML Catalog--&gt;add</code>，修改<code>Key type</code>为<code>URL</code>，然后将复制的那句粘贴在<code>key</code>中，在<code>location</code>中选中你<code>.dtd</code>问价的位置，导入进来即可。</li></ol><h2 id="创建hibernate的核心配置文件"><a href="#创建hibernate的核心配置文件" class="headerlink" title="创建hibernate的核心配置文件"></a>创建hibernate的核心配置文件</h2><ul><li>核心配置文件的格式：<code>xml</code>，名称和位置固定</li><li>位置：<code>src</code>下面，名称：<code>hibernate.cgf.xml</code></li></ul><ol><li>在<code>src</code>下创建<code>hibernate.cfg.xml</code>，引入约束：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line"><span class="string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>hibernate在操作过程中，只会加载核心配置文件，其他配置文件不会加载</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line"><span class="string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">&lt;session-factory&gt;</span><br><span class="line">&lt;!-- <span class="number">1</span>.配置数据库信息 必须要有--&gt;</span><br><span class="line">&lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">"hibernate.connection.url"</span>&gt;jdbc:mysql:<span class="comment">///Hibernate01&lt;/property&gt;</span></span><br><span class="line">&lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name="hibernate.connection.password"&gt;***&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">2</span>.配置hibernate信息 可有可无--&gt;</span><br><span class="line">&lt;!-- 输出底层sql语句 --&gt;</span><br><span class="line">&lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;</span><br><span class="line">&lt;!-- 输出底层sql语句格式 --&gt;</span><br><span class="line">&lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;</span><br><span class="line">&lt;!-- update:如果已经有表，更新，如果没表，自动创建--&gt;</span><br><span class="line">&lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;</span><br><span class="line">&lt;!-- 配置数据库方言，每个数据库语法有细微不同的差别--&gt;</span><br><span class="line">&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">3</span>.把映射文件放到核心配置文件中 必须 --&gt;</span><br><span class="line">&lt;mapping resource="com/daq/entity/User.hbm.xml"&gt;&lt;/mapping&gt;</span><br><span class="line">&lt;/session-factory&gt;</span><br><span class="line"></span><br><span class="line">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>环境搭建好了</strong></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><strong>实际添加操作</strong></li></ul><ol><li>加载核心配置文件</li><li>创建<code>SessionFactory</code>对象</li><li>使用<code>SessionFactory</code>创建<code>session</code>对象</li><li>开启事务</li><li>写具体逻辑<code>CRUD</code>操作</li><li>提交事务</li><li>关闭资源</li></ol><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 加载核心配置文件</span></span><br><span class="line"><span class="comment">//在hibernate中封装对象</span></span><br><span class="line">Configuration cfg=<span class="keyword">new</span> Configuration();</span><br><span class="line">cfg.configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建SessionFactory对象</span></span><br><span class="line"><span class="comment">//读取hibernate配置文件的核心内容，来创建sessionFactory</span></span><br><span class="line"><span class="comment">//在这个过程中，根据映射关系，在数据库中创建表</span></span><br><span class="line">SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 使用SessionFactory创建session对象</span></span><br><span class="line">Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 开启事务</span></span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 写具体逻辑CRUD操作</span></span><br><span class="line"><span class="comment">//添加的功能</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"代澳旗"</span>);</span><br><span class="line">user.setPassword(<span class="string">"520"</span>);</span><br><span class="line">user.setAddress(<span class="string">"湖北武汉"</span>);</span><br><span class="line"><span class="comment">//调用session的方法进行添加</span></span><br><span class="line">session.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 关闭资源</span></span><br><span class="line">session.close();</span><br><span class="line">sessionFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20200501171257758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>千万要注意，映射不能写错了，实体类和数据库的映射不要写错！！！</strong></li></ul><h2 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h2><h3 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h3><ul><li>使用<code>configuration</code>对象创建<code>sessionFactory</code>对象</li></ul><ol><li>根据核心配置文件中，有数据库配置，有映射文件部分，到数据库里面根据映射关系把表创建。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>sessionFactory</code>过程中，特别耗资源<br>在<code>hibernate</code>操作中，建议一个项目中一般创建一个<code>sessionFactory</code>对象，类似于<code>servlet</code>中的<code>serverContext</code>，用到单例模式的思想，在<code>静态代码块中创建这个对象</code>（因为静态代码块在类加载的时候执行，并且只执行一次），所以抽取到工具类中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line">/工具类的抽取，写在静态代码块中，保证只创建一个sessionFactory对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态代码块实现</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 加载核心配置文件</span></span><br><span class="line">cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">cfg.configure();</span><br><span class="line">sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个方法返回sessionFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSesionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li><code>session</code>类似于<code>jdbc</code>中的<code>connection</code>。</li><li><code>session</code><strong>是单线程对象</strong>（重点！！！）<code>session</code>对象不能共用，只能自己用</li><li>调用<code>session</code>中的不同方法实现<code>CRUD</code>操作。</li></ul><ol><li>添加<code>save（）</code></li><li>修改<code>update（）</code></li><li>删除<code>delete（）</code></li><li>根据id查询，<code>get（）</code>方法。</li><li>根据主键查询，<code>load（）</code></li><li>条件查询 <code>createCriteria（）</code></li><li>用于数据库操作对象 <code>createQuery（）</code>和<code>creatSQLQuery（）</code></li></ol><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><ul><li>事务对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>. 开启事务</span><br><span class="line">Transaction tx = session.beginTransaction();</span><br></pre></td></tr></table></figure><ul><li>事务提交和回滚</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tx.commit();</span><br><span class="line">tx.rollback();</span><br></pre></td></tr></table></figure><ul><li>事务概念</li></ul><ol start="5"><li>原子性（要么成功，要么失败）</li><li>一致性（操作之前之后都一样）</li><li>隔离性（多个事务同时操作，他们之间不会影响）</li><li>持久性（当你提交，数据库里面就生效了）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文记录Hibernate的环境搭建及使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis+Hibernate" scheme="http://daqwt.top/categories/MyBatis-Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://daqwt.top/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate基础了解</title>
    <link href="http://daqwt.top/Hibernate%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/"/>
    <id>http://daqwt.top/Hibernate%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/</id>
    <published>2020-04-25T08:28:58.000Z</published>
    <updated>2020-05-28T08:34:24.719Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MVC三层架构中，后台与数据库之间的持久层，我们之前使用JDBC来连接，但是那样效率不高，并且功能单一，所以衍生出轻量级的ORM框架，常用的就有Mybatis，Hibernate。</p><a id="more"></a><h2 id="何为Hibernate？"><a href="#何为Hibernate？" class="headerlink" title="何为Hibernate？"></a>何为Hibernate？</h2><ul><li><code>Hibernate</code>：一个开源的<code>对象关系映射框架</code>，对<code>JDBC</code>进行了非常轻量级的对象封装，将<code>POJO</code>与数据库表建立映射关系，以实现直接存取<code>java</code>对象。</li></ul><p><strong>注：</strong><code>POJO（Plain Ordinary Java Object）</code>：简单的Java对象，就是普通<code>JavaBeans</code>，是为了避免和<code>EJB</code>混淆所创造的简称。</p><ul><li><code>hibernate</code>是一个全自动的orm框架，可以<strong>自动生成SQL语句，自动执行</strong>，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 可以应用在任何使用JDBC的场合，既：可以在Java的客户端程序使用，也可以在<code>Servlet/JSP的Web应用</code>中使用</li><li>最具革命意义的是，<code>Hibernate</code>可以在应用<code>EJB</code>的JaveEE架构中<code>取代CMP</code>，完成数据持久化的重任。</li></ul><p><strong>注：</strong><code>ORM（Object Relational Mapping）</code>框架采用元数据来描述对象与关系映射的细节，元数据一般采用<code>XML</code>格式，并且存放在专门的对象映射文件中。</p><h2 id="为什么要使用Hibernate？"><a href="#为什么要使用Hibernate？" class="headerlink" title="为什么要使用Hibernate？"></a>为什么要使用Hibernate？</h2><p> <code>Hibernate</code>是关于java对象与数据库之间的联系，也就是<code>MVC</code>中的<strong>数据持久层</strong>，也就是<code>DAO</code>层。</p><ul><li>正常步骤：<br>①在<code>DAO</code>层操作<code>xml</code>，数据封装在<code>xml</code>上，读写<code>xml</code>文件来实现<code>CRUD</code>。<br>②<code>DAO</code>层使用原生<code>JDBC</code>连接数据库<br>③<code>JDBC</code>代码冗余，使用封装后的<code>JDBC</code>—》<code>DBUtils</code>来简化CRUD。</li><li><code>DBUtils</code>的规律：<br>①插入数据时，将<code>javaBean</code>对象拆分，拼装成<code>SQL</code>语句。<br>②数据查询时，用<code>SQL</code>语句把数据库中的列组合，拼装成<code>javaBean</code>对象。</li><li>使用<code>Hibernate</code>：<br>①根据<code>javaBean</code>对象和数据表中的列之间的映射关系，自动生成<code>SQL</code>语句。</li></ul><h2 id="Hibernate的优缺点"><a href="#Hibernate的优缺点" class="headerlink" title="Hibernate的优缺点"></a>Hibernate的优缺点</h2><ul><li><strong>优点：</strong><br>①<code>Hibernate</code>直接提供相关支持，底层驱动可以随意切换数据库，快速简洁。<br>②使业务层与具体数据库分开，只针对Hibernate 进行开发，完成数据和对象的持久化。并且可以针对不同的数据库形成不同的SQL 查询语句，降低数据库之间迁移的成本。<br>③<code>Hibernate</code>支持多种缓存机制，可以适配多种数据库。<br>④非侵入式：<code>Hibernate</code>不要求持久化类实现任何接口或继承任何类，<code>POJO</code>即可。</li><li><strong>缺点：</strong><br>①无法对<code>SQL</code>进行优化。虽然有<code>HQL</code>但性能还是很差。<br>②框架中遵循<code>ORM</code>原则，大型项目表多的话，会导致配置文件过于复杂，性能和维护问题就令人头疼。<br>③执行效率不高，比原生的<code>JDBC</code>差，尤其是在批量处理数据的时候。这也是<code>ORM</code>框架的弱点。<br>④不支持批量修改，删除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在MVC三层架构中，后台与数据库之间的持久层，我们之前使用JDBC来连接，但是那样效率不高，并且功能单一，所以衍生出轻量级的ORM框架，常用的就有Mybatis，Hibernate。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis+Hibernate" scheme="http://daqwt.top/categories/MyBatis-Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://daqwt.top/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>结构型---适配器模式</title>
    <link href="http://daqwt.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-25T08:07:22.000Z</published>
    <updated>2020-05-28T08:15:16.101Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器模式（Adapter Pattern）：<strong>将一个类的接口转换成客户希望的另一个接口适配器模式，让那些接口不兼容的类可以一起工作。</strong></p><a id="more"></a><h1 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h1><ul><li><code>作用：</code>如果在系统中存在不兼容的接口，可以通过引入一个适配器来使原本因为接口不兼容，而不能在一起工作的两个类能够协同工作。</li><li><code>定义：</code>适配器模式（Adapter Pattern）：<strong>将一个类的接口转换成客户希望的另一个接口适配器模式，让那些接口不兼容的类可以一起工作。</strong></li><li>因为结构性模式可以描述两种不同的东西：类和类的实例（对象）,根据这一点结构型模式可以分为<code>类结构性模式</code>和<code>对象结构性模式</code>。</li><li><strong>类结构型模式</strong>：关心类的组合，由多个类可以组合成一个更大的系统，所以在类结构型模式中一般只存在继承关系和实现关系。</li><li><strong>对象结构型模式</strong>：关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象，然后通过该调该对象调用相应的方法。</li><li><strong>根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</strong></li></ul><h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p><img src="https://img-blog.csdnimg.cn/20200511131651111.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>Target</code>（目标抽象类）：定义客户所需要的接口。</li><li><code>Adapter</code>（适配器类）：通过实现<code>Target</code>接口并继承<code>Adapter</code>类，使二者产生联系。</li><li><code>Adaptee</code>（适配者类）：适配者是被适配的角色，他定义了一个已经存在的接口，这个接口需要适配，适配者一般是一个具体类，包含了客户希望使用的业务方法。</li><li>由于java不支持多重继承，所以没办法实现类适配器模式。</li></ul><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p><img src="https://img-blog.csdnimg.cn/20200511150335568.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>需求</strong>：给移动的小汽车增加灯光闪烁和声音提示两个功能。</p><ul><li><strong>目标抽象类：</strong><code>CarController</code> 汽车控制类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.classAdapter;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    汽车控制类：充当抽象目标类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarController</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"玩具汽车移动"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">phonate</span><span class="params">()</span></span>;<span class="comment">//发出声音</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">twinkle</span><span class="params">()</span></span>;<span class="comment">//灯光闪烁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>适配者：</strong> 喇叭类 &amp; 灯光类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.classAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//喇叭类，充当适配者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceSound</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarmSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"发出警笛声音"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.classAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灯光类，充当适配者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceLamp</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarmLamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"灯光闪烁"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>适配器类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.classAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoliceCarAdapter</span> <span class="keyword">extends</span> <span class="title">CarController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> PoliceSound sound; <span class="comment">//定义适配者PoliceSound对象</span></span><br><span class="line"><span class="keyword">private</span> PoliceLamp lamp;   <span class="comment">//定义适配者PoliceLamp对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PoliceCarAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sound=<span class="keyword">new</span> PoliceSound();</span><br><span class="line">lamp=<span class="keyword">new</span> PoliceLamp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发出警笛声</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phonate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sound.alarmSound(); <span class="comment">//调用适配者类PoliceSound的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灯光闪烁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">twinkle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lamp.alarmLamp();   <span class="comment">//调用适配者类PoliceLamp的方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.classAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CarController car;</span><br><span class="line">car=<span class="keyword">new</span> PoliceCarAdapter();</span><br><span class="line">car.move();</span><br><span class="line">car.phonate();</span><br><span class="line">car.twinkle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果需要增加其他的喇叭类或者灯光类，可以增加一个新的适配器类，使用新的适配器来适应新的声音类或者灯光类，原代码无需修改。只需要在客户端更换这个新的适配器类即可。</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：</p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</li><li>增加类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者可以在多个不同的系统中复用。</li></ul><p>缺点：</p><ul><li>对于java，C#这种不支持多重继承的语言，一次最多只能适配一个适配者类。</li><li>适配者不可以是最终类，在java中不能是final类，</li><li>与类适配器模式相比，在该模式下要在适配器中置换适配者类的某些方法比较麻烦。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于和彼此之间没有太大关系的类（包括可能在将来引进的类）一起工作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;适配器模式（Adapter Pattern）：&lt;strong&gt;将一个类的接口转换成客户希望的另一个接口适配器模式，让那些接口不兼容的类可以一起工作。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>结构型---装饰模式</title>
    <link href="http://daqwt.top/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-24T08:06:07.000Z</published>
    <updated>2020-05-28T08:13:32.278Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装饰模式是一种用于替代继承的技术，他通过一种无需定义子类的方式来给对象动他动态增添职责，使用对象之间的关联关系，取代类之间的继承关系。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>装饰模式：动态的给一个对象增加一些额外的职责，就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。</strong></li><li>在装饰模式中引入了<strong>装饰类</strong>，在装饰类中既可以调用带装饰的原有类的方法，还可以增加新的方法以扩充原有类的功能。</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li><code>Component()</code><strong>（抽象构件）</strong>：是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象的以及装饰后的对象，实现客户端透明操作。</li><li><code>ConcreteComponent()</code><strong>（具体构件）</strong>：他是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类还可以给他增加额外的职责（方法）。</li><li><code>Decorator</code><strong>（抽象装饰类）</strong>:他也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在子类中实现，它维护了一个指向抽象构建对象的引用，通过该应用可以调用装饰之前构建对象的方法，并通过其子类扩展该方法以达到装饰的目的。</li><li><code>ConcreteDecorator</code><strong>（具体装饰类）</strong>：他是抽象装饰类的子类，负责向构建添加新的职责</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li>抽象构件类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象构件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">//在其中声明抽象业务方法，也可以有具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体构件类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体构件：实现一些简单的业务方法，一些复杂的功能需要通过装饰类来进行扩展。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//基本功能的实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象装饰类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维持一个对抽象构件对象的引用</span></span><br><span class="line"><span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个抽象构件类型的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.component=component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">component.operation();<span class="comment">//调用原有的业务方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体装饰类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"><span class="comment">//将具体构件的对象注入其中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写父类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.operation();<span class="comment">//调用原有业务方法</span></span><br><span class="line">addedBehavior();<span class="comment">//调用新增业务方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明装饰模式"><a href="#透明装饰模式" class="headerlink" title="透明装饰模式"></a>透明装饰模式</h2><ul><li>要求客户端完全针对抽象编程装饰模式的透明要求，客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。</li></ul><h2 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h2><ul><li>也就是说对于客户端而言，具体构建无需关心是透明的，但是具体装饰类必须制定，这是不透明的。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点：</strong></li></ul><ol><li>对于扩展一个对象的功能，装饰模式比继承更灵活，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰，得到功能更加强大的对象。</li><li>具体构建类和具体装饰类可以独立变化。</li></ol><ul><li><strong>缺点：</strong></li></ul><ol><li>在使用装饰模式进行系统设计时，产生很多小对象，这些对象产生必然会占用更多的系统资源，一定程度上影响程序的性能。</li><li>排错困难</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责。</li><li>当不能采用继承的方式对系统进行扩展或者采用继承，不利于系统扩展和维护时，可以使用装饰模式。如<code>final</code>定义的类。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;装饰模式是一种用于替代继承的技术，他通过一种无需定义子类的方式来给对象动他动态增添职责，使用对象之间的关联关系，取代类之间的继承关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>结构型---桥接模式</title>
    <link href="http://daqwt.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-23T08:06:37.000Z</published>
    <updated>2020-05-28T08:11:19.193Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;桥接模式又被称为柄体模式或接口模式，它用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活并予以扩展，同时有效的控制了系统中类的个数。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>桥接模式<code>（Bridge Pattern）</code>：<strong>将抽象部分和它的实现相解耦，使得两者都能独立变化。</strong></li><li>桥接模式又被称为<code>柄体模式</code>或<code>接口模式</code>，它用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活并予以扩展，同时有效的控制了系统中类的个数。</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li><code>Abstraction(抽象类)</code>：定义抽象类，还维护了一个<code>Implementor(实现类接口)</code>的对象，</li><li><code>RefindedAbstraction(扩充抽象类)</code>：扩充由<code>Abstraction(抽象类)</code>定义的接口，通常是具体类，实现了在<code>Abstraction(抽象类)</code>定义的抽象业务方法。也可以调用<code>Implementor(实现类接口)</code>中定义的业务方法。</li><li><code>Implementor(实现类接口)</code>：定义实现类的接口这个接口不用和<code>Abstraction(抽象类)</code>保持一致，它提供基本操作，使用关联关系来替代继承关系。</li><li><code>ConcreteImplementor(具体实现类)</code>：实现<code>Implementor</code>接口，在不同的<code>ConcreteImplementor</code>提供基本操作的不同实现，程序运行时，<code>ConcreteImplementor</code>对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li></ul><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li>实现类接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="comment">//业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//具体业务方法的实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"><span class="comment">//维护一个实现类接口的对象</span></span><br><span class="line"><span class="keyword">protected</span> Implementor impl;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.impl=impl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明抽象业务方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩充抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">impl.operationImpl();<span class="comment">//调用实现类的方法</span></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>需求：开发一款可以在多种系统（Windows，Linux，UNIX）展示多种格式图片（BMP，JPG，GIF，PNG）的模块。</p><ul><li>具体代码就省略了：留下结构图<br><img src="https://img-blog.csdnimg.cn/20200522114640889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>分离抽象接口及其实现部分。</li><li>取代多层继承方案，极大的减少了此类的个数。</li><li>提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统符合开闭原则。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>增加系统的理解与设计难度</li><li>要求正确的识别出系统中两个独立变化的维度，因此其使用范围是有一定的局限性。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>桥接模式一般与适配器模式联用。</li><li>松耦合</li><li>一个类存在两个或多个独立变化的维度，且这些维度都需要独立进行扩展。</li><li>对于那些不希望使用继承或因为多层继承，导致系统中类的个数急剧增加的系统，</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;桥接模式又被称为柄体模式或接口模式，它用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活并予以扩展，同时有效的控制了系统中类的个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>结构型---代理模式</title>
    <link href="http://daqwt.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-22T13:55:59.000Z</published>
    <updated>2020-05-06T14:05:29.440Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给某一个对象提供一个代理或者占位符，并由代理对象来控制对原对象的访问。</p><a id="more"></a><h2 id="什么是代理模式？"><a href="#什么是代理模式？" class="headerlink" title="什么是代理模式？"></a>什么是代理模式？</h2><ul><li>当无法直接访问某个对象或者访问某个对象有一些困难时，可以通过代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。这就是代理模式。</li><li><strong>例如：</strong> 用户执行了某一简单的注册操作，当然在客户端代码中不仅仅只有注册这一功能的方法，还有其他的方法，比如说打印日志：<code>XXX于几月几日注册</code>，当然这些日志是不会返回给用户看到，这些是给开发人员看的，但是用户看到的注册功能和开发人员看到的日志功能要实现同一个接口，这时候就需要一个代理对象来松耦合，真实对象处理业务代码，代理对象处理非业务代码。</li><li><strong>定义：</strong> 给某一个对象提供一个代理或者占位符，并由代理对象来控制对原对象的访问。它去掉客户不能看到的内容和服务或者增加客户需要的额外的新服务。</li></ul><h2 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a>代理模式的结构</h2><ul><li>代理模式的核心结构就是代理类，<strong>为了使客户端 可以一致性的对待真实对象和代理对象，引入了抽象层</strong></li><li>真实类和代理类都实现了抽象接口，并且在代理类中维持一个真实类的引用<br>①在任何可以使用真实类的地方，都可以使用代理类。<br>②代理类还可以控制真实类的使用，因为代理类中有真实类的引用。<br>③实现了松耦合：真实类处理业务代码，代理类处理非业务代码。</li></ul><h2 id="代理模式的实现"><a href="#代理模式的实现" class="headerlink" title="代理模式的实现"></a>代理模式的实现</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>在一个商务查询的基础上加<strong>身份验证</strong>和<strong>打印日志</strong>的功能。当然，用户是看不到任何改变的，还是使用之前的用户查询功能。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><ol><li><code>AccessValidator</code>身份验证类（业务类），提供<code>validate()</code>方法实现身份验证。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AccessValidator身份验证类（业务类），提供validate()方法实现身份验证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessValidator</span> </span>&#123;</span><br><span class="line"><span class="comment">//模拟实现登录验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(userId.equals(<span class="string">"代澳旗"</span>)) &#123;</span><br><span class="line">System.out.println(<span class="string">"欢迎"</span>+userId+<span class="string">"回来！！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"请重新登录！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>Logger</code>日志记录类，提供<code>log()</code>方法来保存日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Logger:日志记录类，提供log()方法来保存日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">num++;</span><br><span class="line">System.out.println(userId+<span class="string">"第"</span>+num+<span class="string">"次查询"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>Searcher</code>：抽象查询接口，充当抽象类，声明<code>doSeacrh()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Searcher</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSearcher</span><span class="params">(String userId,String keyword)</span> </span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>RealSearcher</code>:具体查询类，充当真实类，只实现查询功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RealSearcher:具体查询类，充当真实类，只实现查询功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSearcher</span> <span class="keyword">implements</span> <span class="title">Searcher</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSearcher</span><span class="params">(String userId, String keyword)</span> </span>&#123;</span><br><span class="line">System.out.println(userId+<span class="string">"使用"</span>+keyword+<span class="string">"关键词查询！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"返回的详细信息"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.<code>ProxySearcher</code>代理查询类，维持了<code>RealSearcher对象</code>，<code>AccessValidator对象</code>，<code>Logger对象</code>的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ProxySearcher：代理查询类，</span></span><br><span class="line"><span class="comment"> * 维持了RealSearcher对象</span></span><br><span class="line"><span class="comment"> * AccessValidator对象</span></span><br><span class="line"><span class="comment"> * Logger对象的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySearcher</span> <span class="keyword">implements</span> <span class="title">Searcher</span></span>&#123;</span><br><span class="line"><span class="comment">//维持了RealSearcher对象的引用。可以控制真实对象</span></span><br><span class="line"><span class="keyword">private</span> RealSearcher realcher=<span class="keyword">new</span> RealSearcher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//维持了AccessValidator对象，Logger对象的引用。</span></span><br><span class="line">    <span class="comment">//如果真实对象挂掉了，代理对象可以顶。</span></span><br><span class="line"><span class="keyword">private</span> AccessValidator validator;</span><br><span class="line"><span class="keyword">private</span> Logger logger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSearch</span><span class="params">(String userId, String keyword)</span> </span>&#123;</span><br><span class="line"><span class="comment">//身份验证成功，执行查询</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.validate(userId)) &#123;</span><br><span class="line"><span class="comment">//调用真实类对象，执行查询方法</span></span><br><span class="line">String result=searcher.doSearch(userId,keyword);</span><br><span class="line"><span class="comment">//记录日志</span></span><br><span class="line"><span class="keyword">this</span>.log(userId);</span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建验证访问对象，并调用其validate方法实现身份验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">validator=<span class="keyword">new</span> AccessValidator();</span><br><span class="line"><span class="keyword">return</span> validator.validate(userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建日志对象，并调用其log方法实现打印日志</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">logger=<span class="keyword">new</span> Logger();</span><br><span class="line">logger.log(userId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.配置<code>config.xml</code>,在配置文件中存储代理主题类的全类名</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line">&lt;className&gt;com.daq.proxy.ProxySearcher&lt;/className&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><p>7.<code>XMLUtil</code>：工具类，提供<code>getBean（）</code>方法，用于从XML配置文件中提取该具体类的名字，并返回一个实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Document;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Node;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">// 该方法用于从XML配置文件中提取该具体类的名字，并返回一个实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建DOM文档对象</span></span><br><span class="line">DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">Document doc;</span><br><span class="line">doc = builder.parse(<span class="keyword">new</span> File(<span class="string">"src//designpatterns//Proxy//conf.xml"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">NodeList nl=doc.getElementsByTagName(<span class="string">"className"</span>);</span><br><span class="line">Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">String cName=classNode.getNodeValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名生成实例对象并返回</span></span><br><span class="line">Class c= Class.forName(cName);</span><br><span class="line">Object obj = c.newInstance();</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daq.proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Searcher searcher;</span><br><span class="line">searcher=(Searcher)XMLUtil.getBean();</span><br><span class="line">String result=searcher.doSearch(<span class="string">"代澳旗"</span>, <span class="string">"https://daqwt.top"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>代理类和真实类都是事先存在的，接口和代理方法也明确指定了，每个代理类编译之后都会生成class文件，这叫做<code>静态代理（Static Proxy）</code>新增功能也会增加类的个数，不利于管理，也会增加系统开销。</li><li>以上就是静态代理的实现思想了：在代理类中实现对真实类的权限控制，如果想新增功能，只需要增加一个相应的代理类，在修改配置文件，不用修改源码，但是这种静态代理的方式，实现起来，还是比较困难的。Java的动态代理，就可以很好地解决这个问题，在Spring框架的AOP中得以运用，而且整合封装之后使用更加简洁。</li></ul><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><ul><li>可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实类，并且可以代理不同的方法，动态代理比较高级，在事务管理,AOP，都有着很大的作用。具体的动态代理实现方法，在后续学习AOP的时候去写。</li><li>通过动态代理可以实现对多个真实主题类的统一代理和集中控制</li><li>JDK中的动态代理只能代理一个或者多个接口，如果要动态代理某些具体类或者是抽象类，可以使用<code>GGLib</code>等工具，它是一款代码生成包。</li></ul><h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><ul><li>它使客户端程序可以访问到远程主机上的对象，远程业务在本地主机有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，客户端无需关心是谁来实现具体业务，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。在Java中通过<code>RMI机制</code>实现远程代理。（就是Java虚拟机中的对象调用另一个java虚拟机中的对象）</li></ul><h2 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h2><ul><li>对于一些占用系统资源比较多的或者加载时间长的对象，可以提供虚拟代理，在真实对象创建之前虚拟代理扮演真实对象的替身，而当真实对象创建之后虚拟代理将用户的请求转发给真实对象。</li><li><strong>以下两种情况下使用虚拟代理：</strong><br>①由于各种原因，对象的创建时间比较长，在实现是结合多线程，一个对象用于显示代理对象，其他线程用于加载真实对象。在程序启动的时候，用代理对象代替真实对象初始化，加速系统的启动时间，这种方式可以缩短用户等待的时间。<br>②当一个对象加载非常消耗资源的时候，虚拟代理可以让那些占用大量内存或处理起来比较麻烦的对象推迟到使用他们的时候在创建。访问对象时要进行存在性检测，这可能需要消耗系统时间，但是节省了内存空间，以时间换空间。</li></ul><h2 id="各模式的优缺点"><a href="#各模式的优缺点" class="headerlink" title="各模式的优缺点"></a>各模式的优缺点</h2><ul><li><p><strong>优点：</strong>  解耦，可扩展，灵活。</p></li><li><p><strong>远程代理：</strong> 为两个不同地址空间的对象提供一种实现机制，可以将一些资源消耗比较多的对象和操作移动至性能更好的计算机上，提高系统的整体运行效率。</p></li><li><p><strong>虚拟代理：</strong> 通过一个消耗资源比较少的对象来替代一个消耗资源比较多的对象，可以在一定程度上节约系统运行开销。</p></li><li><p><strong>缓冲代理:</strong> 为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这个结果，优化系统性能，缩短执行时间。</p></li><li><p><strong>保护代理：</strong> 控制一个对象的访问权限，为不同的用户提供不同的使用权限。</p></li><li><p><strong>缺点：</strong><br>①由于在客户端和真实类之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度慢，例如保护代理。<br>②代理的实现比较复杂。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;给某一个对象提供一个代理或者占位符，并由代理对象来控制对原对象的访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建型---抽象工厂模式</title>
    <link href="http://daqwt.top/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-21T13:35:04.000Z</published>
    <updated>2020-05-06T15:13:39.898Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一个创建一系列相关和相互依赖对象的接口，而无需指定他们具体的类。</p><a id="more"></a><h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul><li>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题。</li><li>但是由于工厂方法模式中每个具体工厂只能产生一个单一的对象，如果需要工厂提供多种产品对象，那么会存在大量的工厂类，加大系统的开销。</li><li>可以考虑将一些相关的产品组成一个<code>产品族</code>，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。</li><li><strong>例如：</strong> 我需要生产<code>海尔电视机，海尔冰箱，海尔空调，海信冰箱，海信空调，海信电视机，Tcl电视机，TCL冰箱，TCL空调，</code>如果用工厂方法模式的话，就要创建9个具体工厂类，但是如果使用抽象工厂模式的话，只需要按照产品等级结构（海尔，海信，TCL）和产品族（电视机，冰箱，空调，）划分，只需要提供三个具体工厂，极大的减少了系统种类的歌个数。</li><li><strong>定义：</strong> <strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类，抽象工厂模式又成为工具模式。</strong></li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li><code>AbstractFactory</code>(抽象工厂)：我们一组用于创建一<code>族</code>产品的方法，一个方法对应一种产品。</li><li><code>ConcreteFactory</code>（具体工厂）：生成一组具体产品，这些产品构成了一个产品族。</li><li><code>AbstractProduct</code>(抽象产品)：声明产品所具有的业务方法。</li><li><code>ConcreteProduct</code>(具体产品)：具体产品对象。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 设计一款皮肤库，有不同风格，每种风格又分种类。风格就是<strong>等级结构</strong>，后面的就是<strong>产品族</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200503152520604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200503164112458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：</li></ul><ol><li>隔离了具体类的生成，用户并不需要知道什么被创建，只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统行为。</li><li>当一个产品族中多个对象被设计成一起工作时，他能够保证客户端是终止使用同一个产品族中的对象。</li><li>增加新的产品族很方便，无需修改已有系统。</li></ol><ul><li>缺点：</li></ul><ol><li>增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来很大的不便，违背了开闭原则。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;提供一个创建一系列相关和相互依赖对象的接口，而无需指定他们具体的类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建型---工厂方法模式</title>
    <link href="http://daqwt.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-20T13:31:25.000Z</published>
    <updated>2020-05-06T13:34:30.545Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个用于创建对象的接口，但是让子类决定将哪一个类似类化工厂方法模式，让一个类的实例化延迟到其子类。</p><a id="more"></a><h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul><li>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，弥补了缺陷。他也被称为<code>虚拟构造器模式</code>或者<code>多态工厂模式</code>。</li><li>先定义一个<code>抽象工厂类</code>，再定义<code>具体工厂类</code>去实现抽象工厂类的方法，这种抽象化的结果是：可以在不修改具体工厂类的情况下引进新的产品，如果出现新的功能，只需要为这个功能定义一个具体的工厂类。就可以创建出该功能的实例，这种改进方案，就叫做工厂方法模式。</li><li>在工厂方法模式中，工厂父类负责定义创建产品对象的<code>公共接口</code>，而工厂子类负责生成<code>具体的产品对象</code>，这样做得目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定久经应该实例化哪一个具体产品类。</li><li><strong>总结:定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。</strong></li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ol><li>抽象产品（定义产品的接口，产品对象的公共父类）</li><li>具体产品（实现产品的接口）</li><li>抽象工厂（声明工厂方法，返回一个产品）</li><li>具体工厂（抽象工厂的子类，客户端调用，返回一个具体的实例）</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 日志记录器可以通过很多途径保存日志，用户可以修改配置文件，灵活的更换日志记录的方式，为了更好的封装记录器的初始化过程，并保证多种记录器切换的灵活性，使用工厂方法模式设计该系统。</p><p>1.<strong>抽象产品接口：</strong> <code>Logger</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>具体产品实现：</strong> <code>DatabaseLogger</code>,<code>FileLogger</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"数据库日志记录"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">implements</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"文件日志记录"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>抽象工厂接口：</strong> <code>LoggerFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">//抽象工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>具体工厂实现：</strong> <code>DatabaseLoggerFactory</code>，<code>FileLoggerFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Impl.DatabaseLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line">Logger logger = <span class="keyword">new</span> DatabaseLogger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据库日志记录器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Impl.FileLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoggerFactory</span> <span class="keyword">implements</span> <span class="title">LoggerFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">createLogger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建文件日志记录对象</span></span><br><span class="line">Logger logger = <span class="keyword">new</span> FileLogger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件</span></span><br><span class="line"><span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.<strong>客户端测试：</strong> <code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factory.Impl.FileLoggerFactory;</span><br><span class="line"><span class="keyword">import</span> com.daq.factorymethod.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LoggerFactory factory;</span><br><span class="line">Logger logger;</span><br><span class="line"><span class="comment">//具体工厂的实例</span></span><br><span class="line">factory=<span class="keyword">new</span> FileLoggerFactory();</span><br><span class="line">logger=factory.createLogger();</span><br><span class="line">logger.writeLog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.如果要增加新的功能，只需要对应的增加一个新的具体工厂类，然后在客户端代码中修改具体工厂类的类名，原有类库的代码无需修改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.通过引入配合文件并使用反射机制可以实现<code>在不修改客户端代码的基础上更换具体共产类</code>，系统更符合开闭原则，具备更好的扩展性。</p><h2 id="工厂方法的隐藏"><a href="#工厂方法的隐藏" class="headerlink" title="工厂方法的隐藏"></a>工厂方法的隐藏</h2><ul><li>通过把业务方法调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无需使用工厂方法来创建产品对象。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><p><strong>优点：</strong><br>①用户只需关心所需产品对应的工厂，无需关心创建细节。<br>②基于工厂角色和产品角色的多态性设计是工厂方法模式的关键，工厂方法模式之所以被称为<code>多态工厂模式</code>，正是因为所有的具体工厂类都具有同一抽象父类。<br>③新增功能时，无需修改源码，只增添一个具体工厂和具体产品即可。</p></li><li><p><strong>缺点：</strong><br>①新增了产品类，意味着系统的复杂度要增加。<br>②代码中引入了抽象层，在客户端中也使用了抽象性进行定义，增加了理解难度。</p></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>客户端不知道它所需要使用的类，因为客户端只需要知道所对应的工厂就行了。</li><li>抽象工厂类通过使用他的子类来指定创建哪个对象。在工厂方法模式中对于抽象工厂只需要提供一个创建产品的接口，而由其子类来决定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;定义一个用于创建对象的接口，但是让子类决定将哪一个类似类化工厂方法模式，让一个类的实例化延迟到其子类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>String,StringBuffer,StringBuilder详解</title>
    <link href="http://daqwt.top/String,StringBuffer,StringBuilder%E8%AF%A6%E8%A7%A3/"/>
    <id>http://daqwt.top/String,StringBuffer,StringBuilder%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-20T08:23:09.000Z</published>
    <updated>2020-05-28T08:26:06.796Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在平时处理字符串的时候，是不是都用的String？由于这个类是final定义的，所以，他也是不可变的字符串，再JDK1.5之后，还引入了StringBuilder。</p><a id="more"></a><h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><ul><li><strong>区别</strong></li></ul><table><thead><tr><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程不安全</td><td>安全，效率低</td><td>不安全，效率高</td></tr><tr><td>JDK1.0</td><td>JDK1.0</td><td>JDK1.5</td></tr></tbody></table><ul><li><strong>继承关系</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200524113610621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用技巧</li></ul><ol><li>如果要操作少量的数据用 String；</li><li>多线程操作字符串缓冲区下操作大量数据使用 StringBuffer；</li><li>单线程操作字符串缓冲区下操作大量数据使用 StringBuilder。</li></ol><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><p><img src="https://img-blog.csdnimg.cn/20200524112709323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>equals()</code>字符串比较</li><li><code>trim()</code>删除空格</li><li><code>substring()</code>截取指定位置的字串。</li><li><code>length()</code>数组长度</li><li><code>charAt(index)</code>返回第指定索引值的字符，索引从0开始</li><li><code>concat()</code>追加字符串</li><li><code>equalsIgnoreCase()</code>忽略大小写比较</li><li><code>endsWith()</code>是否以某字符结束，一般用于检查图片是否以<code>.jpg</code>或者其他结尾。</li><li><code>StartWith()</code>是否以某字符开始。</li><li><code>indexOf(&quot;q&quot;)</code>某字符首次出现的位置</li><li><code>lastIndexOf(&quot;d&quot;)</code>某字符最后依次出现的位置</li><li><code>toLowerCase()</code>变小写<code>toUpperCase()</code>变大写</li></ul><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p><img src="https://img-blog.csdnimg.cn/20200524112805996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>append(&quot; &quot;)</code>拼接</li><li><code>insert(2, &quot;小明&quot;);</code>   插入</li><li><code>sb.delete(2,4);</code> 包头不包尾</li><li><code>sb.replace(1,2,&quot;hello&quot;);</code>替换</li><li><code>reverse()</code>倒置</li></ul><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ul><li><code>StringBuffer</code>与<code>StringBuilder</code>的方法是一样的，区别就在于，<code>StringBuffer</code>更高效，毕竟是jdk1.5出来的。但是StringBuffer是线程安全的，各有各的用处</li></ul><p><img src="https://img-blog.csdnimg.cn/202005241128410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在平时处理字符串的时候，是不是都用的String？由于这个类是final定义的，所以，他也是不可变的字符串，再JDK1.5之后，还引入了StringBuilder。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://daqwt.top/HashMap/"/>
    <id>http://daqwt.top/HashMap/</id>
    <published>2020-04-20T03:27:37.000Z</published>
    <updated>2020-04-20T01:35:09.824Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。</p><a id="more"></a><ul><li><strong>全文概要</strong></li></ul><table><thead><tr><th>版本</th><th>1.7</th><th>1.8</th></tr></thead><tbody><tr><td>底层实现</td><td>数组+链表</td><td>数组+链表/红黑树</td></tr><tr><td>存值</td><td>Entry&lt;key，value&gt;对象</td><td>Node（key，value）节点</td></tr><tr><td>初始容量</td><td>小于传入数的2的幂次方数（移位运算）</td><td>大于传入数的2的幂次方数</td></tr><tr><td>哈希值</td><td>高低位混合运算（异或和移位）</td><td>高低位混合运算</td></tr><tr><td>扩容机制</td><td>头插法</td><td>尾插法/链表长度大于8时转化为红黑树</td></tr><tr><td>缺点</td><td>链表反转，形成循环链表，线程不安全</td><td>高度依赖hash算法，如果key是自定义类害得重写hashcode（），线程不安全</td></tr></tbody></table><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><h3 id="大致了解"><a href="#大致了解" class="headerlink" title="大致了解"></a>大致了解</h3><ul><li><code>JDK1.7</code>：数组+链表</li><li><code>key</code>和<code>value</code>组合成一个<code>entry</code>对象，将这个对象的引用地址存放在数组中。</li><li><code>table</code>数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.根据key先算出来一个hash值</span><br><span class="line"><span class="keyword">int</span> hash = key.hashcode();</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.用这个hash值去跟数组长度(table.length)做与操作</span><br><span class="line"><span class="keyword">int</span> i = hash &amp; (length-<span class="number">1</span>); <span class="comment">//得到的这个i就是数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.就把这个key对应的value放入数组下标i对应的位置</span><br><span class="line">table[i]=value;</span><br></pre></td></tr></table></figure><ul><li>那为什么要用链表呢？</li></ul><ol><li>再传进来一个<code>value</code>值,万一这个值对应的<code>key</code>算出来的<code>hash</code>值跟之前的重复了怎么办？这就要用到链表了。</li><li>将这个<code>key</code>对应的<code>value</code>值放在数组的同一个位置，只不过是以链表的形式。</li><li>那怎么放呢？是把这个元素放在链表的头部还是尾部呢？当然是采用<strong>头插法</strong>，因为尾插法效率低（他要遍历整个链表，要知道尾结点是谁，才能放入。）而放在头部只需要将<code>next</code>指向链表的头结点。</li><li>那么用<code>put（）</code>存进去了，用<code>get()</code>怎么取呢？，因为<code>get()</code>也是通过计算<code>hash</code>值，得到数组下标，但是这个下标上，有一个链表呀，怎么知道取的是哪个值呢？<strong>所以说：</strong> 一个新的结点插入到头部之后，要往下移动一个位置，（虽然说是移动一个位置，实际上是将这个新元素的值赋值给<code>table[i]</code>,这样，头结点在哪里，链表就在那里）那么取链表上的元素就好取了。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>先分析一下<code>put()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">         inflateTable(threshold);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             e.value = value;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     addEntry(hash, key, value, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>通过查看源码第一行的<code>if语句</code>可以看出，只有当要往里面存放元素的时候，才去初始化这个桶，懒加载（延迟初始化），在初始化数组的时候，调用了<code>inflateTable(threshold)</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>在其中又调用了<code>roundUpToPowerOf2(toSize)</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>highestOneBit（）</code>方法,通过移位和或运算计算出小于<code>i</code>的<code>2的幂次方数capacity</code>（这就是庶族的初始化容量），比如说，传入10，计算得出8，传入19，计算得出16。这个方法里面的运算是先把传入的数转化为二进制，然后在进行移位位运算和或运算，就像这个方法名字一样：得到最高位的那一位，自然而然的得出来的数就是2次幂的数了。得出来的这个数就是<code>table数组</code>的长度，jdk的作者对于位运算的使用已经达到出神入化的境界。</li><li>这样做的目的是，如果你修改了这个<code>number值</code>，他也会在加载的时候将这个值转化小于<code>number</code>的2的幂次方数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">       i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">       i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">       <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>再看<code>indexFor()</code>方法，是通过将算出来的<code>hash值</code>与数组长度进行一个与运算，得到这个数组下标<code>i</code>。这个<code>table[i]</code>就是要存的位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">思考为什么要length-<span class="number">1</span>？</span><br><span class="line">因为length是<span class="number">2</span>的幂次方数</span><br><span class="line">经过与运算之后，只得到低四位有效，有效的低四位取值范围就是<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">就得出了下标在<span class="number">0</span>-<span class="number">15</span>这个范围之内。</span><br></pre></td></tr></table></figure><ul><li>这就可以解决以上的一个问题了，为什么hashmap在初始化一个数组的容量的时候，要是一个2的幂次方数，因为要配合<code>indexFor()</code>计算出数组下标，对应存储。但是这样算出来的<code>hash值</code>会覆盖掉很多种情况，这就导致了很多元素算出来的下标值一样，存储在同一链表上，链表就会很长，进而影响到<code>get()</code>的效率，因为<code>get()</code>要循环链表嘛，所以回到上一步，可以看到<code>hash()方法</code>。</li><li>再看<code>hash()</code>方法（并不是<code>hashcode()方法哦</code>），它里面有异或和移位运算（这样高位就参与到运算了–高低位混合运算），可以理解为<code>再次哈希</code>，这样就增加了散列性。解决了的单条链表很长的问题。如果我们要改写<code>hashcode（）</code>，但是我们水平不行，改了之后导致返回的<code>hashcode值</code>非常不均匀，那么这个<code>hash()方法</code>就会帮我们容错。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>再看<code>for循环</code>，它要做的事就是遍历链表，看看有没有key值相同的，比如说<code>put(1,2);</code>和<code>put(1,3)</code>，可以看到，两个key值是相等的，for循环判断之后，就会用新的值覆盖老的值，再返回老的值<code>oldValue</code>。</li><li><code>modCount++</code>跟多线程并发有关。</li><li><code>addEntry(hash,key,value,i)</code>这才是真正的将<code>key和value</code>放到数组上面去。<code>if</code>里面的语句就是涉及到扩容了，<code>threshold</code>是通过阈值<code>capacity</code>乘加载因子<code>DEFAULT_LOAD_FACTOR</code>得到的，如16<em>0.75=12，可以看到扩容要满足两个条件。这里的<code>size</code>是指当前数组占用了多少，而不是指链表的长度。后面那个条件是指数组中没有位置为空了，*</em>大于阈值，并且发生过一次碰撞之后就扩容！！！**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>扩容的目的就是为了提高效率，因为链表上元素太多了，就会影响<code>get()</code>的效率。点开<code>resize()</code>方法可以看到，先<code>new</code>出来一个新的数组，长度是原先的两倍，然后在调用<code>transfer()</code>方法将老元素移动到新数组中。在转移的时候，将一个长链表拆成两个个短链表，减轻了压力。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>扩容是怎么来实现的呢？看这个<code>transfer()</code>方法中显示，有需要进行<code>rehash</code>的情况，也有不需要<code>rehash</code>的情况。看到<code>for()循环</code>是遍历这个数组上有没有空，而嵌套的<code>while()</code>循环是遍历这个链表上的元素。</li></ul><ol><li>先看不需要<code>rehash</code>的情况（<strong>适用于单线程</strong>）此时<code>rehash=false</code>，可以看到下面又使用了<code>indexFor</code>方法，传入的是被遍历的这个元素的hash值，和新数组的长度，计算得出一个值<code>i</code>，这就是新数组的下标，把老元素放到<code>newTable[i]</code>上。事实上，根据运算得到的<code>i</code>值和原先是一样的，因为原本的hash值没有变，只是拿过来用，而变化的是数组长度，但是并不会影响算出来的<code>i</code>值，所以说，传到新数组后，下标还是没有变。但是这样引发了扩容之后的一个问题：<strong>链表上的元素全部倒过来了，意思就是新链表的顺序和之前的完全颠倒了。</strong></li><li>多线程情况下，如果有两个线程同时调用haspmap的这个对象，都会使用到<code>put()</code>方法，如果最终同时走到了<code>resize()</code>方法中，各种混乱的走法之后，<strong>最终会产生一个循环链表，最终耗尽CPU的资源。</strong>–这就是haspmap扩容带来的第二个问题</li><li>再看需要<code>rehash</code>的情况，其实很少会走到<code>rehash()</code>中，在<code>rehash（）</code>中打了一个断点，测试的时候无限<code>put()</code>,却发现，始终不会执行<code>rehash（）</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h3><ul><li><strong>HashMap底层是怎么实现的呢？</strong><br>答：在jdk1.7的时候，底层是由数组+链表实现的，由key和value组成一个entry对象，用put方法将key和value传入，当调用这个put方法的时候，就会初始化一个数组（也就是所说的延迟初始化），这个数组的初始容量给的是16，负载因子是0.75，根据这个key值使用hash方法算出hash值，再用这个hash值跟数组的长度做模运算，得到一个数组下标，就将这个元素的值放入到对应下标的位置，那如果再传入的另一个元素算出来的hash值也是一样的（这就叫hash冲突），那么进而算出来的下标也是一样的，这就要用到链表了，使用头插法，并保证最新插入的这个元素是整个链表的头结点，就实现了存储的过程。</li><li><strong>扩容的机制？</strong><br>在put的时候，有一个方法是<code>addEntry</code>，先判断当前的size是不是大于阈值，这里的阈值就是（数组初始长度<em>加载因子），默认的就是12，大于这个阈值，并且发生了hash碰撞的时候，就要进行扩容了，就是执行<code>resize()</code>方法，扩容的方法就是，new一个新数组，长度是原数组长度的两倍，然后在用<code>transfer</code>方法将老数组中的元素转移过去，还重新算一下扩容之后的阈值，这样做出现的问题就是：在单线程情况下还好，只不过转移过去的链表会反转，*</em>但是在多线程的情况下**，就会出现一个闭环，会把cpu的资源耗尽。这里面还有一个<code>rehash()</code>方法，但是这个方法我并没有具体研究，涉及到一个哈希种子，其实这个rehash方法并不会用到。在源码rehash中打个断点，测试代码中无限put操作，发现程序并不会停止。</li><li><strong>HashMap为什么是线程不安全的？</strong><br>HashMap在put的时候，超过的阈值就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</li></ul><h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><h3 id="大致了解-1"><a href="#大致了解-1" class="headerlink" title="大致了解"></a>大致了解</h3><ul><li>在1.7中叫entry对象，在1.8中叫node结点。</li><li><strong>在1.8中加入了红黑树，为什么加红黑树？</strong><br>虽然在1.7中实行了很多措施，如扩容，去增加元素的散列性，使链表的长度更短一些，但是还是会出现一些极端情况，某些地方链表还是会很长，所以加入了红黑树，当链表达到一定长度大于8的时候，就要先看数组，决定是否要扩容，然后在不行就要换用红黑树了。当红黑树结点小于6的时候，又变为链表了。</li><li><strong>为什么链表上限设置为8，为红黑树下限设置为6呢？为什么不设置为8？</strong><br>这样是为了防止平凡的插入和删除，打个比方，当我插入第9个元素的时候，这就要变为红黑树了，可是我马上又删除了一个元素，红黑树又要变成链表，这样不停的来回转换，会拉低效率，所以将红黑树结点下限设置为6。</li></ul><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>分析put（）方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200416091904314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200416094525420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>在1.8中初始化容量的时候，和1.7有不同，如果你传入的一个数字，会调用<code>tableSizeFor()</code>方法进行移位运算，最终得到一个大于你传入的这个数字的数（这个数依旧是2的次幂），而1.7中得到的这个数字是小于你传入的这个数。这个数用来作为数组的初始容量。</p></li><li><p>在1.8中采用尾插法加入元素，这是因为，每次加入元素的时候，本来就要遍历一下链表，看有没有超过八个结点，超过了就变成红黑树，总之是要遍历的，直接用尾插法，一举两得。</p></li><li><p>在遍历的过程中，还要看有没有与老元素key值相同的，相同则覆盖掉，除此之外还要判断是否为红黑树。</p></li><li><p><strong>关于树化:</strong> 点开treeifyBin方法发现：在链表上的结点大于八个的时候，不会第一时间去树化，而是先判断是否需要扩容，然后再去决定要不要树化，其实扩容大概率能减少链表的长度了。一举两得，扩容比树化优点好多了。基于对内存的一个节省，不能扩容的太大，就用红黑树。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2020041609544419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>1.8里的扩容只要满足一个条件，而1.7中需要满足两个。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200416094609702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>扩容详解，条件只有一个，但是代码却长了很多，核心思想就是：使用2次幂的扩展（长度变两倍）所以，要么元素的位置是在原位置，要么是在原位置基础上移动2次幂的位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>看到里面的算hash值的方法。跟1.7的差不多。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200416092054872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="总结归纳"><a href="#总结归纳" class="headerlink" title="总结归纳"></a>总结归纳</h3><ul><li>JDK1.8中，HashMap是怎么实现的？<br>在JDK1.8中，底层是由数组+链表/红黑树实现的，将key和value封装成一个node结点，计算hash值和1.7是差不多的，在put的时候，有两点要注意，一个是判断新元素key值是否与老元素相等，相等则覆盖掉，不相等就直接插入，另一点就是判断是链表还是红黑树，选择遍历的方式，采用尾插法来插入元素，也不用担心需要遍历整个链表，因为判断链表上结点个数的时候总是要遍历的，这里值得注意的是，在判断是否需要变为红黑树的时候，（也就是链表结点大于等于8的时候）首先要考虑的是扩容，因为扩容大概率能够解决链表长度的问题，而且还增大了空间，但是不能一味的扩容，这样会导致内存浪费，所以就转换成红黑树了。</li></ul><h2 id="对比JDK1-7和1-8"><a href="#对比JDK1-7和1-8" class="headerlink" title="对比JDK1.7和1.8"></a>对比JDK1.7和1.8</h2><table><thead><tr><th></th><th>1.7</th><th>1.8</th></tr></thead><tbody><tr><td><strong>底层实现</strong></td><td>数组+链表</td><td>数组+链表/红黑树</td></tr><tr><td><strong>形式</strong></td><td>Entry&lt;key，value&gt;对象</td><td>Node&lt;key,value&gt;结点</td></tr><tr><td><strong>下标值</strong></td><td>hash &amp;（length-1）</td><td>（n-1）&amp; hash</td></tr><tr><td><strong>元素插入</strong></td><td>头插法</td><td>尾插法</td></tr><tr><td><strong>扩容机制</strong></td><td>resize（链表反转，循环链表）</td><td>解决了链表反转的问题</td></tr><tr><td><strong>查询效率</strong></td><td>链表：n</td><td>红黑树：log（n）</td></tr><tr><td><strong>扩容</strong></td><td>transfor（）方法，新数组两倍长度</td><td>resize（）方法</td></tr></tbody></table><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p><strong>HashMap线程不安全，为什么还要用它？</strong><br>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。但综合各种因素，首要推荐使用ConcurrentHashMap。</p></li><li><p><strong>ConcurrentHashMap实现</strong><br>ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</p></li><li><p><strong>ConcurrentHashMap有哪些优点？</strong></p></li></ul><ol><li>线程安全的，在多线程下效率更高。</li><li>ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有。</li><li>ConcurrentHashMap在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。 </li></ol><ul><li><strong>ConcourrentHashMap和Hashtable都是线程安全的，为什么不用Hashtable？</strong></li></ul><ol><li>hashtable:使用一把锁处理并发问题，当有多个线程访问时，需要多个线程竞争一把锁，导致阻塞。</li><li>concurrentHashMap则使用分段，相当于把一个hashmap分成多个，然后每个部分分配一把锁，这样就可以支持多线程访问。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前有一篇关于HashMap底层原理的分析，由于没有结合源码，所以只停留在浅显的层面，这篇结合JDK1.7和1.8的源码，分析一下HashMap的底层实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="HashMap" scheme="http://daqwt.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---注解</title>
    <link href="http://daqwt.top/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://daqwt.top/%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-04-19T13:37:10.000Z</published>
    <updated>2020-05-16T13:39:46.596Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注解（<code>Annotation</code>）：在JDK1.5中引入，代码中的特殊标记，这些标记可以在编译，类加载，运行时被程序读取，并执行相对应的处理。注释给程序员看，注解给编译器看。框架的底层，基本都是反射和注解，所以这两者结合使用，功能非常强大。</p><a id="more"></a><h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul><li>就目前我常用到的注解有：<code>@overide</code>，<code>@Test</code>，<code>@Autowired</code>，特别是自动装配的注解，提供了强大的功能。</li><li>基本Annotation<br>在<code>java.lang</code>包下，用于常用于标记该方法，抑制编译器警告等。相当于给他们添加了额外的辅助信息。</li><li>元Annotaion<br>在<code>java.lang.annotation</code>包下，常用于修饰其他的Annotation定义。</li></ul><h2 id="注解有什么作用？"><a href="#注解有什么作用？" class="headerlink" title="注解有什么作用？"></a>注解有什么作用？</h2><ul><li>传统方式是通过配置XML文件的方式来告诉类要如何运行。</li><li>现在，我们可以通过加注解的方式告诉类如何运行。</li><li>让编译器检查代码</li><li>将数据注入到方法、成员变量、类上。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>在<code>java.lang</code>包下有五个基本的注解。</p><ul><li><code>@Override</code> 重写注解</li><li><code>@Deprecated</code> 过时注解</li><li><code>@SuppressWarnings(&quot;all&quot;)</code> 抑制编译器警告，<code>all</code>:全部镇压</li><li><code>@SafeVarargs</code>是jdk7中堆污染警告</li><li><code>@Functionallnterface</code> 显示指定该接口是函数式接口</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>负责注解其他的注解。</p><ul><li><p><code>@Target</code> 用于描述注解的使用范围（被描述的注解可以用在什么地方）</p></li><li><p><code>@Retention</code>表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）一般都写<code>RUNTIME</code>，保证在运行的时候，注解还是有效的。</p></li><li><p><code>@Document</code>说明该注解被包含在javadoc中</p></li><li><p><code>@Inherited</code> 子类可以继承父类的注解</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2020051522031311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用<code>@interfae</code>自定义注解时，自动继承<code>java.lang.annotation.Annotation</code>接口。</p><ol><li>格式：<code>public @interface 注解名{定义内容}</code>，在类中声明的时候要把<code>public</code>去掉。</li></ol><ul><li>在注解上定义的成员变量只能是String，数组，Class，枚举类，注解</li></ul><p><img src="https://img-blog.csdnimg.cn/20200515224043361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="如何使用自定义注解（反射）"><a href="#如何使用自定义注解（反射）" class="headerlink" title="如何使用自定义注解（反射）"></a>如何使用自定义注解（反射）</h2><ul><li>赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解拥有什么属性，在修饰的时候就要给出相对应的值</span></span><br><span class="line">   <span class="meta">@MyAnnotation</span>(username = <span class="string">"zhangsan"</span>, age = <span class="number">20</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>在注解声明属性的时候，给出默认值，修饰的时候就不需要给出具体的值了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">//定义了两个成员变量</span></span><br><span class="line">    <span class="function">String <span class="title">username</span><span class="params">()</span> <span class="keyword">default</span> "zicheng"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>把自定义注解的基本信息注入到方法上（利用反射技术）</strong><br>要事先在自定义注解上加上这样一段代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><ul><li>自动注入过程：</li></ul><p><strong>①反射出该类的方法</strong><br><strong>②通过方法得到注解上具体的信息</strong><br><strong>③将注解上的信息注入到方法上</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解拥有什么属性，在修饰的时候就要给出相对应的值</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@MyAnnotation</span>(username = <span class="string">"zhongfucheng"</span>, age = <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//反射出该类的方法</span></span><br><span class="line"> Class c1 = Demo2<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"> Method method = c1.getMethod(<span class="string">"add"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过该方法得到注解上的具体信息</span></span><br><span class="line"> MyAnnotation annotation = method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> String username = annotation.username();</span><br><span class="line"> <span class="keyword">int</span> age = annotation.age();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将注解上的信息注入到方法上</span></span><br><span class="line"> Object o = c1.newInstance();</span><br><span class="line"> method.invoke(o, username, age);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对象注入方法的过程：<br>①得到想要注入到类中的属性<br>②得到该属性的对象<br>③得到属性对应的写方法<br>④通过写方法得到注解<br>⑤获取注解详细的信息<br>⑥将注解的信息注入到对象上<br>⑦调用属性写方法，将已填充数据的对象注入到方法中</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;注解（&lt;code&gt;Annotation&lt;/code&gt;）：在JDK1.5中引入，代码中的特殊标记，这些标记可以在编译，类加载，运行时被程序读取，并执行相对应的处理。注释给程序员看，注解给编译器看。框架的底层，基本都是反射和注解，所以这两者结合使用，功能非常强大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>创建型---简单工厂模式</title>
    <link href="http://daqwt.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-19T13:25:07.000Z</published>
    <updated>2020-05-06T13:30:26.013Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个工厂类，它可以根据参数的不同，返回不同类的实例，被创建的实例通常都具有共同的父类。</p><a id="more"></a><h2 id="模式概述"><a href="#模式概述" class="headerlink" title="模式概述"></a>模式概述</h2><ul><li>工厂方法属于创建型模式，描述如何将对象的创建与使用相分离，目的在于让用户使用对象的同时，无需关心对象的创建细节，从而降低系统的耦合度，让设计方案易于修改和扩展。</li><li><strong>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</strong></li><li>由于<strong>简单工厂模式中</strong> 用于创建实例的方法是静态的，因此<strong>简单工厂模式</strong>又被称为<code>静态工厂模式</code></li><li>简单工厂模式的要点在于：<strong>用户需要什么时，只需要传入一个正确的参数，就可以获取所需要的对象，而无需知道创建细节。</strong></li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><ul><li>工厂类</li><li>抽象产品类</li><li>具体产品类</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>需求：</strong> 开发一套图表库，可以向用户提供各种图标，例如柱状图（HistogramChart），饼状图（PieChart），折现图（LineChart），并且后期还可以根据需求添加别的图。<br>1.<strong>抽象产品类:</strong> <code>Chart</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>具体产品类：</strong> <code>HistogramChart</code>，<code>PieChart</code>，<code>LineChart</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HistogramChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HistogramChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"创建柱状图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"显示柱状图"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PieChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"创建饼状图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"显示饼状图"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineChart</span> <span class="keyword">implements</span> <span class="title">Chart</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LineChart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"创建折线图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"显示折线图"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>工厂类：</strong> <code>ChartFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChartFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chart <span class="title">getChart</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Chart chart=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"histogram"</span>)) &#123;</span><br><span class="line">chart=<span class="keyword">new</span> HistogramChart();</span><br><span class="line">System.out.println(<span class="string">"初始化设置柱状图！"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"pie"</span>))&#123;</span><br><span class="line">chart=<span class="keyword">new</span> PieChart();</span><br><span class="line">System.out.println(<span class="string">"初始化设置饼状图！"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"line"</span>))&#123;</span><br><span class="line">chart=<span class="keyword">new</span> LineChart();</span><br><span class="line">System.out.println(<span class="string">"初始化设置折线图！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chart;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>测试类：</strong> <code>client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.daq.factory.Chart;</span><br><span class="line"><span class="keyword">import</span> com.daq.factory.ChartFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Chart chart;</span><br><span class="line">chart=ChartFactory.getChart(<span class="string">"pie"</span>);</span><br><span class="line">chart.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试结果：</span><br><span class="line"></span><br><span class="line">创建饼状图</span><br><span class="line">初始化设置饼状图！</span><br><span class="line">显示饼状图</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>以上就是简单工厂模式的实现，当然也可以将静态工厂方法的参数存储在<code>XML</code>配置文件中，然后通过一个工具类<code>XMLUtil</code>来读取配置文件中的字符串参数。这样就可以实现不用修改源码就可以获取到相应的实例。</li><li>简单工厂模式也可以简化：将抽象产品类和工厂类合并，将静态工厂方法移动至抽象产品类中。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点<br>①实现了对象创建和使用相分离<br>②通过引入配置文件，可以不用修改源码，只用修改配置文件，实现更换和增加新的具体产品类。</li><li>缺点<br>①工厂类集中了所有产品的创建逻辑，职责过重。一旦不能正常工作，整个系统都会出问题。<br>②会增加类的个数，增加系统的负担。<br>③不利于系统的扩展和维护。<br>④由于是使用静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑过于复杂。</li><li>客户端只知道传入工厂类的参数，对如何创建对象不关心。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;定义一个工厂类，它可以根据参数的不同，返回不同类的实例，被创建的实例通常都具有共同的父类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建型---单例模式</title>
    <link href="http://daqwt.top/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-18T13:19:38.000Z</published>
    <updated>2020-05-06T15:16:27.183Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式（<strong>Singleton Pattern</strong>）：确保一个类只有一个实例，并提供一个全局访问点来访问这一个唯一实例。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>定义：</strong> 某个类只能有一个对象实例，并且这个类只提供一个获取该对象实例的方法（静态方法）。</li><li>单例设计模式涉及到的知识点还是特别多的，比如：类加载机制，JVM的指令重排，序列化之类的知识。这就很让人头痛。</li><li>核心思想：类内创建，类外获取，使用时创建（懒加载）。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>①应用中某个实例对象需要频繁的被访问，如线程池，工具类对象，数据源，session工厂。<br>②应用中每次启动只会存在一个实例。如账号系统，数据库系统。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li>优点：<br>①对于一些需要频繁创建和销毁的对象，（如工具类对象，数据源，session工厂等…）使用单例模式提高新能，节省系统资源。<br>②只new一次即可，这就大大降低了系统内存的使用频率，减轻了GC的压力。<br>③有些核心类，控制着重要流程，如果该类可以创建多个的话，系统就会混乱。只有使用单例模式，才能保证核心服务器独立控制整个流程。</li><li>缺点：<br>①由于单例模式没有抽象层，因此单例类的扩展就有很大困难。<br>②单例类职责过重，一定程度上违背了单一职责原则。<br>③在垃圾回收的情况下，如果长时间不用，会被当做是垃圾回收掉。</li></ul><h1 id="五种写法"><a href="#五种写法" class="headerlink" title="五种写法"></a>五种写法</h1><h2 id="饿汉式（两种写法）"><a href="#饿汉式（两种写法）" class="headerlink" title="饿汉式（两种写法）"></a>饿汉式（两种写法）</h2><h3 id="（一）静态常量"><a href="#（一）静态常量" class="headerlink" title="（一）静态常量"></a>（一）静态常量</h3><ul><li><strong>写法步骤</strong></li></ul><ol><li>构造器私有化（防止new）</li><li>在类的内部创建对象</li><li>向外暴露一个静态的公共方法：getInstance（）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式（静态变量）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本地内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供一个公有的静态方法，返回对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为true，说明这两个对象是完全一样的</span></span><br><span class="line">System.out.println(instance==instance1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个new出来的对象HashCode值也一样</span></span><br><span class="line">System.out.println(instance.hashCode());</span><br><span class="line">System.out.println(instance1.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：写法简单，在类装载的时候就完成了实例化（上述第二步），避免了线程同步的问题。</li><li>正是由于在类装载的时候就完成了实例化，没有达到懒加载（lazy loading）的效果，那么如果从始至终都未使用这个实例，就会造成内存浪费。</li><li>在JDK中有用到，在<code>java.lang.Runtime</code>下。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200419202904706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>总结：<strong>如果你确定能够用到这个实例，那么没问题，但是你不能确定是否会用到，就会造成内存浪费的问题。</strong></li></ul><h3 id="（二）静态代码块"><a href="#（二）静态代码块" class="headerlink" title="（二）静态代码块"></a>（二）静态代码块</h3><ul><li>写法：在静态代码块中创建单例对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式（静态代码块）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本地内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中创建单例对象</span></span><br><span class="line">instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供一个公有的静态方法，返回对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这与静态变量是一样的，也同样是在类装载的时候创建实例。优缺点也一样，可能会造成内存浪费。</li></ul><h2 id="懒汉式（三种写法）"><a href="#懒汉式（三种写法）" class="headerlink" title="懒汉式（三种写法）"></a>懒汉式（三种写法）</h2><h3 id="（一）线程不安全"><a href="#（一）线程不安全" class="headerlink" title="（一）线程不安全"></a>（一）线程不安全</h3><ul><li>起到了懒加载的效果，但是只能在单线程下使用</li><li>如果多线程下，一个线程进入<code>if(instance==null)</code>判断语句块，还没来得及往下执行，另一个线程又进来了，这样会产生多个实例，所以多线程情况下，不使用这种方式</li><li><strong>在实际开发中，不要使用懒汉式！！！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.构造器私有化，外部不能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，当使用该方法时，才去创建instance，即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）线程安全，同步方法"><a href="#（二）线程安全，同步方法" class="headerlink" title="（二）线程安全，同步方法"></a>（二）线程安全，同步方法</h3><ul><li>解决了线程不安全的问题，但是同时也带来了效率低下的问题。每个线程想获得类的实例，执行<code>getInstance（）</code>都需要进行同步。</li><li><strong>所以实际开发中不使用这种方式！！！</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个获取实例的公有方法上加一个`synchronized`关键字，就解决了线程安全的问题。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line">instance=<span class="keyword">new</span> Singleton3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（三）线程安全，同步代码块"><a href="#（三）线程安全，同步代码块" class="headerlink" title="（三）线程安全，同步代码块"></a>（三）线程安全，同步代码块</h3><ul><li><p>这种方式本意是想通过同步代码块来改善同步方法带来的效率低下的问题。但是并没有什么卵用。</p></li><li><p>其实也没有太大的意义，还是线程不安全的，<strong>开发中一定不能用！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：延迟加载（需要的时候才去加载）</p></li><li><p>缺点： 线程不安全，在多线程中很容易出现不同步的情况，如在数据库对象进行的频繁读写操作时。</p></li></ul><h2 id="双重检查-推荐使用"><a href="#双重检查-推荐使用" class="headerlink" title="双重检查(推荐使用)"></a>双重检查(推荐使用)</h2><ul><li>使用<code>volatile</code>关键字，这个<code>instance</code>变量就共享了，一旦有改变，就会刷新到内存中，可以理解为轻量级的<code>synchronized</code>，</li><li>解决了线程安全和懒加载的问题，同时保留了效率，它或许可以在并发量不多，安全性不太高的情况能完美运行。</li><li>但是，问题就是出现在这句 <code>instance = new Singleton();</code> 在JVM编译的过程中会出现指令重排的优化过程，这就会导致当 instance实际上还没初始化，就可能被分配了内存空间，也就是说会出现 instance !=null 但是又没初始化的情况，这样就会导致返回的 instance 不完整。</li><li>优点：在并发量不多，安全性不高的情况下或许能很完美运行单例模式</li><li>缺点：不同平台编译过程中可能会存在严重安全隐患。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span></span>&#123;</span><br><span class="line"><span class="comment">//使用volatile关键字，这个instance变量就共享了，一旦有改变，就会刷新到内存中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;<span class="comment">//如果instance为空，则说明还没创建，此时才去创建。</span></span><br><span class="line"><span class="keyword">synchronized</span>(Singleton3<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类（推荐使用）"><a href="#静态内部类（推荐使用）" class="headerlink" title="静态内部类（推荐使用）"></a>静态内部类（推荐使用）</h2><ul><li>这个主类装载的时候，它里面的内部类不会被装载的，但是如果主类中的方法使用到了这个静态内部类的静态变量的时候，这个类才会装载，（以此实现延迟加载），而且只会装载一次，并且还是线程安全的。</li><li>利用了JVM装载类的时候是线程安全的这个特点，因为在类初始化的时候，别的线程是无法进入的。</li><li><strong>推荐使用！！！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类实现单例模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个静态内部类，这个类中有一个静态属性Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTnstance</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法,直接返回这个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Singleton5.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的方法（强烈推荐）"><a href="#枚举的方法（强烈推荐）" class="headerlink" title="枚举的方法（强烈推荐）"></a>枚举的方法（强烈推荐）</h2><ul><li>借助JDK1.5中添加的枚举来实现单例，不仅避免了多线程同步的问题，而且还能够防止反序列化重新创建新的对象。</li><li>枚举方式也是JAVA作者推荐使用的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest6</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Singleton6 instance = Singleton6.INSTANCE;</span><br><span class="line">Singleton6 instance1 = Singleton6.INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为true，说明这两个对象是完全一样的</span></span><br><span class="line">System.out.println(instance==instance1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个new出来的对象HashCode值也一样</span></span><br><span class="line">System.out.println(instance.hashCode());</span><br><span class="line">System.out.println(instance1.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，可以实现单例</span></span><br><span class="line"><span class="keyword">enum</span> Singleton6&#123;</span><br><span class="line">INSTANCE;<span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在实际开发中：<br>①<strong>饿汉式</strong>————————–单线程情况下并且知道一定会用到这个实例的时候采用<br>②<strong>懒汉式的</strong>———————–三种写法都不推荐<br>③<strong>双重检查</strong>和<strong>静态内部类</strong>—–多线程情况下推荐使用的写法。<br>④<strong>枚举</strong>—————————–最最推荐的是的方法，写法简单，安全，高效！</li><li><strong>注意：</strong> synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单例模式（&lt;strong&gt;Singleton Pattern&lt;/strong&gt;）：确保一个类只有一个实例，并提供一个全局访问点来访问这一个唯一实例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---反射</title>
    <link href="http://daqwt.top/%E5%8F%8D%E5%B0%84/"/>
    <id>http://daqwt.top/%E5%8F%8D%E5%B0%84/</id>
    <published>2020-04-18T12:26:21.000Z</published>
    <updated>2020-05-28T08:17:16.828Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>java</code>是一门静态语言（运行时结构不变），不像<code>JavaScript，python...</code>那些动态语言一样，在运行时可以修改变量的值，但是java也可以称为<code>准动态语言</code>，因为他可以利用反射机制，获得类似动态语言的效果。</p><a id="more"></a><p><strong>前言：</strong> 反射就像是一面镜子，这面镜子其实就是JVM，他能照出你的类的所有属性和方法，也能调用你所有对象的属性和方法，<strong>crazy~</strong></p><p><code>java</code>是一门静态语言（运行时结构不变），不像<code>JavaScript，python...</code>那些动态语言一样，在运行时可以修改变量的值，但是java也可以称为<code>准动态语言</code>，因为他可以利用反射机制，获得类似动态语言的效果。</p><h1 id="反射是什么？"><a href="#反射是什么？" class="headerlink" title="反射是什么？"></a>反射是什么？</h1><ul><li>先说<strong>正</strong>是怎么一回事。我要使用某个类，我必须要知道它是什么类，有何作用？用的时候，要先实例化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个对象，实例化的过程牵扯太多，不赘述</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Studnt();</span><br><span class="line">Class c1 = stu.getClass();</span><br><span class="line">System.out.println(c1.getName());</span><br></pre></td></tr></table></figure><ul><li>上面这个Student类，JVM在加载的时候这个类的时候，其实会在JAVA堆中创建一个<code>java.lang.class类</code>的对象，就是上面的<code>c1</code>，这个class对象代表类的相关信息。可以使用这个对象的一些方法来获取类的相关信息，这里也体现出了<strong>万物皆对象</strong>的理念，连类都是对象。</li><li>看看class类，这还只是一小部分方法，跟类相关的都可以在Class类中找到。<br><img src="https://img-blog.csdnimg.cn/202004181940283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>那说了这么多，反射到底是什么呢？</li></ul><p>我的理解：在运行状态中，可以知道任意一个类的属性和方法，也可以调用任意一个对象的属性和方法，也就是动态获取信息，动态获取对象方法和属性，然而这些底层的实现细节都被屏蔽了，只留下API库给我们使用，也就是<code>java.lang.reflect</code>类库，这些API学习并不难，难在理解反射这个概念，由于实现细节都被屏蔽了，我们也就很少写到反射的代码。</p><h1 id="反射有什么意义？"><a href="#反射有什么意义？" class="headerlink" title="反射有什么意义？"></a>反射有什么意义？</h1><p>我直接<code>new</code>出来一个对象不就可以了，为什么用反射，要兜个大圈子？其实出去这些浅显表面的，反射真正的意义在于提高程序的灵活性，屏蔽底层实现细节，便于使用。</p><h1 id="反射如何使用？"><a href="#反射如何使用？" class="headerlink" title="反射如何使用？"></a>反射如何使用？</h1><p>这个在使用的时候直接查API即可，常用的有以下几种。</p><ul><li>通过一个对象获得完整的包名和类名。</li><li>实例化Class对象。</li><li>获取一个对象的父类与实现的接口。</li><li>获取某个类的全部构造函数。</li><li>通过反射机制实例化一个对象。</li><li>获取某个类的全部属性</li><li>获取某个类的全部方法</li></ul><h1 id="Class类详解"><a href="#Class类详解" class="headerlink" title="Class类详解"></a>Class类详解</h1><h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><ul><li>对象照镜子后可以得到的信息：某个类的属性，方法，构造器，以及实现了哪些接口。</li><li>对每个类而言，JRE都为其保留一个不变的Class类型的对象，一个Class对象包含了特定某个结构（<code>class/interface/enum/annotation/primitive type/void/[]</code>）的有关信息。</li></ul><ol><li>Class本身也是一个类。</li><li>Class对象只能由系统建立。我们只能通过反射去得到。</li><li>一个加载的类在JVM中只会有一个Class实例。</li><li>Class类是Reflection的根源，如果你想动态加载，运行的类，只有先获得相应的class对象才可以。</li></ol><h2 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h2><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>static ClassforName（String name）</code></td><td>返回指定类名name的Class对象</td></tr><tr><td><code>Object newInstence（）</code></td><td>通过反射创建对象，返回Class对象的一个实例</td></tr><tr><td><code>getName（）</code></td><td>返回Class对象所表示的实体（类，接口，数组的名称）</td></tr><tr><td><code>Class getSuperClass（）</code></td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td><code>Class[] getInterdaces（）</code></td><td>获取当前class对象的接口</td></tr><tr><td><code>ClassLoader getClassLoader（）</code></td><td>返回该类的类加载器</td></tr><tr><td><code>Constructor[] getConstructor（）</code></td><td>返回一个包含某些Constructor对象的数组</td></tr></tbody></table><h2 id="创建class对象"><a href="#创建class对象" class="headerlink" title="创建class对象"></a>创建class对象</h2><p>创建class对象的三种方式</p><ul><li>通过对象获得</li><li>forname获得</li><li>通过类名.class获得 </li></ul><p><img src="https://img-blog.csdnimg.cn/20200516133509741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h1><ul><li>JDBC（连接数据库与后端的桥梁），这其中就牵扯到一个连接的问题，我们将数据库的连接信息（用户名，用户密码，库名…）写在配置文件里，而不是写在代码里，为什么？因为这样我们更换数据库的时候，只需要改配置信息，而不是去改代码。而这里的由配置文件到代码，就是由反射来加载驱动的。</li><li>Spring MVC，学<code>servlet</code>的时候各种<code>getParameter()</code>获取信息，但是在SpringMVC框架中只需要在<code>javaBean</code>中约定好字段名，就可以把值填充进去。这就是反射的好处。</li><li>Spring，这个我学的还不多，但是涉及到一个自动组装的问题，只要字段名的顺序是约定一致的，就可使实现自动组装的效果，就像一个萝卜一个坑一样。如果顺序颠倒，可能在你想象中组装出来的是超跑，但是现实却是拖拉机。</li><li>Java的反射用的最多的地方就是在框架里面。比如说有两个程序员，他们各自创建了两个类，第一个程序员现在需要第二个程序员创建的类，可是现在第二个程序员创建的类还没有完成。那么第一个程序员编译自然不成功，但是现在第一个程序员又要使用第二个程序员的类，这个时候，反射就可以完成这个任务。因为反射是在类运行的时候获取对象的各个信息，所以第一个程序员的类就可以完成编译了。</li></ul><h1 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h1><ul><li>通过反射，调用类中的方法，通过Method类完成。</li></ul><ol><li>获取到类的class对象。</li><li>通过Class对象调用<code>getMethod（String name， Class ...parameterTypes）</code> 方法获取一个<code>Method</code>对象，并设置此方法操作时所需要的参数类型。</li><li>使用<code>Object invoke(Object obj,Object[] args)</code>进行调用，并向方法中传递要设置的obj对象的参数信息。</li></ol><ul><li><code>setAccessible</code>：启动和禁用访问安全检查的开关。默认为false，设置为true之后，可以访问一些私有属性，可以提高反射的效率，如果代码中必须用反射，而该句代码需要频繁的被调用，就设置为true。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200516211315324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h1><h1 id="提高反射效率"><a href="#提高反射效率" class="headerlink" title="提高反射效率"></a>提高反射效率</h1><ol><li>反射比new对象慢，是因为Class.forName这个方法比较耗时，它实际上调用了一个本地方法，通过这个方法来要求JVM查找并加载指定的类。所以我们在项目中使用的时候，可以把Class.forName返回的Class对象缓存起来，下一次使用的时候直接从缓存里面获取，这样就极大的提高了获取Class的效率。同理，在我们获取Constructor、Method等对象的时候也可以缓存起来使用，避免每次使用时再来耗费时间创建。</li><li>还有一种更极致的使用反射手法，一个高性能反射工具包ReflectASM。它是通过字节码生成的方式来实现的反射机制</li><li>总结一下，为了更好的使用反射，我们应该在项目启动的时候将反射所需要的相关配置及数据加载进内存中，在运行阶段都从缓存中取这些元数据进行反射操作。如果对性能有极致追求的时候，可以考虑通过三方包，直接对字节码进行操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;java&lt;/code&gt;是一门静态语言（运行时结构不变），不像&lt;code&gt;JavaScript，python...&lt;/code&gt;那些动态语言一样，在运行时可以修改变量的值，但是java也可以称为&lt;code&gt;准动态语言&lt;/code&gt;，因为他可以利用反射机制，获得类似动态语言的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>各设计模式的应用场景</title>
    <link href="http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-04-17T13:03:34.000Z</published>
    <updated>2020-05-06T13:15:26.783Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅要清楚的知道设计模式的结构还有实现过程，还要熟悉应用场景，在什么时候使用什么设计模式，能够达到更好的效果，使软件复用性更高，性能更好，这才是最重要的。不仅要会用，而且还要知道什么时候用。</p><a id="more"></a><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ul><li><strong>抽象工厂模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。<strong>它使得应用程序能够和使用的框架的具体实现进行解耦。</strong> 在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。<code>任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了</code>。该模式可以与策略模式结合使用。</p><ul><li><strong>建造者模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。这个在业务代码中使用的场景很广泛。比如订单系统大部分项目都有，订单对象就是一个复杂对象，就可以采用建造者模式来做。</p><ul><li><strong>工厂方法：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只是一个返回实际类型的方法。</p><ul><li><strong>原型模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，拷贝一个对象并直接修改它就完事儿。这是一个大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。</p><ul><li><strong>单例模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>用来确保类只有一个实例。</code>还有一种方法就是使用枚举。单例是用得最多的，因为Spring的bean，默认就是单例级别的。单例模式的应用场景太多了，例如：在<code>hibernate</code>操作中，一个项目中一般创建一个<code>sessionFactory</code>对象。创建太多会造成资源的浪费</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ul><li><strong>适配器模式</strong>：</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用于将一个新接口适配旧接口，在业务代码中经常有新旧接口适配的需求，可以采用该模式。</p><ul><li><strong>桥接模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>将抽象和抽象的具体实现进行解耦</strong>，这样可以使得抽象和抽象的具体实现可以独立进行变化。其实我们每天都在用到，可能却浑然不知。只要用到面向接口编程，其实都是在用桥接模式。</p><ul><li><strong>享元模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用缓存来减少对小对象的访问时间，<code>只要用到了缓存，基本都是在使用享元模式</code>。用个map缓存几个对象，基本上都运用了享元的思想。</p><ul><li><strong>装饰者模式:</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。装饰者模式在JDK中广泛运用，例如我们常用的AOP，既有动态代理，也有装饰者的味道。</p><ul><li><strong>门面模式：</strong></li></ul><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为一组组件，接口，抽象或子系统提供简化的接口。SLFJ日志就是门面日志，比如使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。</p><ul><li><strong>组合模式:</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。<code>组合模式常用于递归操作的优化上，</code>比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么可以试试这个设计模式。<strong>总之，凡是有级联操作的，都可以尝试这个设计模式。</strong></p><ul><li><strong>代理模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理模式用于向较简单的对象代替创建复杂或耗时的对象。几乎所有的开源框架，都用到了动态代理。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><ul><li><strong>中介者模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。业务代码使用的场景太多了。比如MQ，其实就是在用中介者模式。</p><ul><li><strong>模板方法模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。<code>这个模式是非常高频的模式。</code>业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化。</p><ul><li><strong>策略模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能，<code>常用于优化大量的if-else</code></p><ul><li><strong>责任链：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合</strong>，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现，凡是带有Filter关键词的，用到拦截器的地方基本都在用这个设计模式。</p><ul><li><strong>迭代器模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供一个统一的方式来访问集合中的对象，这个模式中间件和基础框架中用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典。</p><ul><li><strong>命令模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。命令模式使用频率较高，和策略模式比较像，Activiti工作流引擎中很多地方都用到了命令模式。</p><ul><li><strong>解释器模式：</strong></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常描述为该语言定义语法并使用该语法来解释该格式的语句，比较冷门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不仅要清楚的知道设计模式的结构还有实现过程，还要熟悉应用场景，在什么时候使用什么设计模式，能够达到更好的效果，使软件复用性更高，性能更好，这才是最重要的。不仅要会用，而且还要知道什么时候用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---四种内部类</title>
    <link href="http://daqwt.top/517577219/"/>
    <id>http://daqwt.top/517577219/</id>
    <published>2020-04-17T04:34:50.000Z</published>
    <updated>2020-04-17T04:54:36.513Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，<strong>可以将一个类定义在另一个类里面或者一个方法里边</strong>，这样的类称为<strong>内部类</strong>，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。</p><a id="more"></a><p> <strong>1. 成员内部类</strong><br>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；<br>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；<br>（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；<br>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。</p><p> <strong>2.  局部内部类</strong><br>（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；<br>（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p><p><strong>3.匿名内部类</strong><br>（1）一般使用匿名内部类的方法来编写事件监听代码；<br>（2）匿名内部类是不能有访问修饰符和static修饰符的；<br>（3）匿名内部类是唯一一种没有构造器的类；<br>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><p><strong>4.静态内部类</strong><br>（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；<br>（2）不能使用外部类的非static成员变量或者方法。</p><h2 id="内部类的共性："><a href="#内部类的共性：" class="headerlink" title="内部类的共性："></a>内部类的共性：</h2><ul><li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。</li><li>内部类不能用普通的方式访问。</li><li>内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量。</li><li>外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问。</li></ul><h2 id="内部类的作用："><a href="#内部类的作用：" class="headerlink" title="内部类的作用："></a>内部类的作用：</h2><ul><li>内部类方法可以访问该类定义所在的作用域的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来,一般的非内部类，是不允许有 private 与protected权限的，但内部类可以。</li><li>可以实现多重继承。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li></ul><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><strong>每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。大家都知道Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。</strong></p><h2 id="外部类："><a href="#外部类：" class="headerlink" title="外部类："></a>外部类：</h2><p>外部的类。定义一个类A，在A的内部再定义一个类B，则A就是外部类，B就是内部类。</p><h2 id="内部类与外部类区别与联系"><a href="#内部类与外部类区别与联系" class="headerlink" title="内部类与外部类区别与联系"></a>内部类与外部类区别与联系</h2><p>内部类可以访问外部类所有的方法和属性，如果内部类和外部类有相同的成员方法和成员属性，内部类的成员方法调用要优先于外部类即内部类的优先级比较高（只限于类内部，在主方法内，内部类对象不能访问外部类的成员方法和成员属性），外部类只能访问内部类的静态常量或者通过创建内部类来访问内部类的成员属性和方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Java中，&lt;strong&gt;可以将一个类定义在另一个类里面或者一个方法里边&lt;/strong&gt;，这样的类称为&lt;strong&gt;内部类&lt;/strong&gt;，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---Object类</title>
    <link href="http://daqwt.top/Object/"/>
    <id>http://daqwt.top/Object/</id>
    <published>2020-04-17T03:51:07.000Z</published>
    <updated>2020-04-17T03:54:29.442Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object类是所有类的父类，位于java.lang包中。这也是面试的一个小考点吧，这篇文章看看Object中有哪些方法。</p><a id="more"></a><h2 id="Object类概述"><a href="#Object类概述" class="headerlink" title="Object类概述"></a>Object类概述</h2><ul><li>Object类是JDK默认提供的一个类。java中除了Object类，所有类都存在继承，默认会继承Object父类</li><li>所有类的对象都可以使用 Object 接收。</li><li>Object 达到最高参数统一化。</li></ul><h2 id="什么时候使用Object类"><a href="#什么时候使用Object类" class="headerlink" title="什么时候使用Object类?"></a>什么时候使用Object类?</h2><ul><li>对于Object类的使用可以分为两个阶段：JDK 1.5以前，以及JDK 1.5之后。</li><li>Object之所以会被大量的进行参数的接收处理，很大的一部分原因在于：你的程序里面需要接受的类型很多，并不固定，可是现在的开发理念中强调的问题不再是这一点了，而是如何可以避免向下转型（如果避无可避，那么就用），因为从JDK1.5之后引入了泛型机制（在基础课程讲解泛型机制的时候重点分析了Object缺陷）。</li><li>现在的设计思想是用泛型来避免向下转型的操作（ClassCastException），如果你要认真读了API文档你会发现，可以接收Object类型的方法是越来越少了，开发中尽量回避Object接收的项目为主。</li></ul><h2 id="Object类有哪些方法？"><a href="#Object类有哪些方法？" class="headerlink" title="Object类有哪些方法？"></a>Object类有哪些方法？</h2><ul><li>可以看到里面都是用native关键字修饰的方法。都是原生函数，得调用C++的函数。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020041711473684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object类是所有类的父类，位于java.lang包中。这也是面试的一个小考点吧，这篇文章看看Object中有哪些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="javaSE" scheme="http://daqwt.top/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>类的加载过程</title>
    <link href="http://daqwt.top/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://daqwt.top/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-04-17T02:53:44.000Z</published>
    <updated>2020-05-17T02:56:06.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><p><img src="https://img-blog.csdnimg.cn/20200516134009962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="https://img-blog.csdnimg.cn/20200516134537454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>加载：</strong> 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，<strong>并通过反射生成一个代表这个类的Class对象</strong>。</li><li><strong>链接：</strong> 将java类的二进制代码合并到JVM的运行状态之中</li></ul><ol><li>验证：确保加载的类信息符合jvm规范，没有安全方面的问题。</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ol><ul><li><strong>初始化：</strong></li></ul><ol><li>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程,类构造器<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（<strong>类构造器是构造类信息的，不是构造该对象的构造器</strong>）</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁和同步</li></ol><p><img src="https://img-blog.csdnimg.cn/20200516142155751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器有哪些？</li></ul><ol><li><strong>引导类加载器</strong>：C++编写，是JVM自带的类加载器，负责加载java平台核心库<code>rt.jar</code>,<strong>该加载器无法直接获取</strong>。</li><li><strong>扩展类加载器（EXT）</strong>：负责<code>jre/lib/ext</code>目录下的jar包，以及我们引进的jar包。</li><li><strong>系统类加载器（APP）</strong>： 负责<code>java-classpath</code>或<code>java.class.path</code>所指的目录下的类与jar包装入，是最常用的加载器。</li></ol><ul><li>获取：<code>类.getClassLoader();</code></li><li>作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的class对象，作为方法中类访问数据的入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间，不过JVM垃圾回收机制可以回收这些class对象<br><img src="https://img-blog.csdnimg.cn/20200516144741630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><ul><li>类的主动引用（<strong>一定会发生类的初始化</strong>）</li></ul><ol><li>虚拟机启动，先初始化main方法所在的类。</li><li>new一个类的对象</li><li>调用类的静态成员和静态方法。</li><li>使用反射调用</li><li>初始化一个类，要先初始化其父类。</li></ol><ul><li>类的被动引用（<strong>不会发生类的初始化</strong>）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java内存分析&quot;&gt;&lt;a href=&quot;#Java内存分析&quot; class=&quot;headerlink&quot; title=&quot;Java内存分析&quot;&gt;&lt;/a&gt;Java内存分析&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200516
      
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2020-04-16T12:53:52.000Z</published>
    <updated>2020-05-28T08:04:06.871Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个设计模式都符合某一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一，通过在软件开发中使用这些原则，可以提高软件的可维护性和可复用性，以便设计出兼具良好的软件系统，实现可维护性服用的目标。</p><a id="more"></a><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul><li>单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小。</li><li><strong>定义：</strong> 一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。它是高内聚低耦合的指导方针 。</li></ul><h2 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><h2 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h2><p>任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><p>这个是开闭原则的基础，<strong>针对接口编程，依赖于抽象而不依赖于具体</strong>。</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>使用多个隔离的接口，比使用单个接口要好。旨在降低类之间的耦合度，<strong>由此可以看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。需要降低依赖，降低耦合。</strong></p><h2 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h2><p>简单来讲：个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也是解耦的一部分思想。</p><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p>原则是<strong>尽量使用合成/聚合的方式，而不是使用继承。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每一个设计模式都符合某一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一，通过在软件开发中使用这些原则，可以提高软件的可维护性和可复用性，以便设计出兼具良好的软件系统，实现可维护性服用的目标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>入门设计模式</title>
    <link href="http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daqwt.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-15T12:43:34.000Z</published>
    <updated>2020-05-06T13:01:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目开发过程中，经过验证的解决方案，用于解决在特定环境下、重复出现的某些特定问题。前人栽树，后人乘凉，日常写代码，很少有创新，因为所做的80%都已经由前辈实现了，所以我们在学习过程中，要善于利用前辈们总结出来的经验。帮助我们少走弯路。</p><a id="more"></a><h2 id="23种设计模式概览"><a href="#23种设计模式概览" class="headerlink" title="23种设计模式概览"></a>23种设计模式概览</h2><ul><li>总体上分为三类：</li></ul><p><strong>①创建型模式：</strong>  用于创建对象<br><strong>②结构型模式：</strong> 用于处理类和对象的组合。<br><strong>③行为型模式：</strong> 描述类和对象之间的交互和怎样分配职责。</p><table><thead><tr><th>类别</th><th>模式</th></tr></thead><tbody><tr><td>创建型</td><td>工厂方法模式、抽象工厂模式、<strong>单例模式、</strong> 建造者模式、<strong>原型模式</strong>。</td></tr><tr><td>结构型</td><td>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</td></tr><tr><td>行为型</td><td>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</td></tr></tbody></table><ul><li>还有一种分类方式是：并发性模式与线程池模式。不做论述。</li></ul><h2 id="为什么要使用设计模式？"><a href="#为什么要使用设计模式？" class="headerlink" title="为什么要使用设计模式？"></a>为什么要使用设计模式？</h2><p>①学习设计模式对提高技术能力很有帮助。<br>②不用重复造轮子。<br>③节省大部分时间</p><h2 id="使用设计模式有什么好处？"><a href="#使用设计模式有什么好处？" class="headerlink" title="使用设计模式有什么好处？"></a>使用设计模式有什么好处？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;老生常谈，所有的技术，存在即合理，一种技术。无非就是，节省写代码的时间，提高代码的健壮性，可维护性，复用性，简化问题。</p><h2 id="反模式是什么？"><a href="#反模式是什么？" class="headerlink" title="反模式是什么？"></a>反模式是什么？</h2><ul><li>是指用来解决问题的带有共同性的不良方法。它们已经经过研究并分类，以防止日后重蹈覆辙，并能在研发尚未投产的系统时辨认出来。简单的来说，<strong>反模式</strong>是指在对经常面对的问题使用低效，不良，或者有待优化的设计模式。</li><li>举例：在面向对象设计/编程中，单一责任原则，其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能，有的类里有几千行的代码，有很多功能，但是责任不明确单一。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是有意而为的。久而久之代码累计，符合单一原则类慢慢的变的臃肿起来。</li><li>总之，开发过程中，肯定会不幸的陷入反模式中，这就与初衷背道而驰了，所以我们熟练掌握设计模式，并且研究反模式，尽量避免反模式情况的发生，防患于未然！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在项目开发过程中，经过验证的解决方案，用于解决在特定环境下、重复出现的某些特定问题。前人栽树，后人乘凉，日常写代码，很少有创新，因为所做的80%都已经由前辈实现了，所以我们在学习过程中，要善于利用前辈们总结出来的经验。帮助我们少走弯路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://daqwt.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://daqwt.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;小狗钱钱&gt;&gt;</title>
    <link href="http://daqwt.top/read.html/"/>
    <id>http://daqwt.top/read.html/</id>
    <published>2020-04-14T03:35:45.000Z</published>
    <updated>2020-04-14T04:09:31.079Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在B站看了半佛仙人一期关于理财的视频，视频里面也推荐了很多值得一看的书，有《小狗钱钱》，《海龟交易法则》，《经济学原理》，我首先看的是小狗钱钱，写下了这篇读后感。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这本书是美国的一版儿童理财读物，虽然说是儿童读物，但在我看来，实际上就是用孩子能够理解的故事，讲述一些大人都未必清楚的一些道理，这些道理可能直白的说出来，成人都懂，可是又有谁能够贯彻到生活中呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致内容讲的是，小女孩吉娅的爸爸妈妈陷入了财政窘迫的时期，吉娅意外的捡到了一条狗，而这是一条会说话的狗，名字就叫钱钱，机缘巧合，钱钱开始教吉娅理财知识，吉娅一步一步富有了起来，并且也帮助爸爸妈妈摆脱了财政窘境。我看完这本书，并不能说从中学到了什么知识，知识把以前了解到的理财观念加深了，就像那句话：道理咱都懂！！！可他并没有深入你的骨髓，这才是关键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将重要的理念罗列以下：</p><h2 id="一-做自己喜欢做的事"><a href="#一-做自己喜欢做的事" class="headerlink" title="(一)做自己喜欢做的事"></a>(一)做自己喜欢做的事</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要为了挣钱而去挣钱，尤其是在我们这个年纪，通过打工，兼职挣来的钱，如果只是满足自己的消费欲望，那将毫无意义，如果将这些钱用在正道上，比如说买书，买课程，提高自己的修养与知识积累，那暂且还花对了地方，对我们这个年纪的学生，真正的意义是提升自己的能力，然后再去赚钱，换句话说，就是用自己的专业技能变现，如果专业技能达不到要求，那就将赚钱一事先放在一边，提升技能放在第一位，毕竟以后还是要靠本事吃饭，当你的专业技能足够好时，就不愁赚不到钱，这个时候就要找渠道了。</p><h2 id="二-把钱分成日常开销。梦想目标，和账户三部分"><a href="#二-把钱分成日常开销。梦想目标，和账户三部分" class="headerlink" title="(二)把钱分成日常开销。梦想目标，和账户三部分"></a>(二)把钱分成日常开销。梦想目标，和账户三部分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常开销是刚需，这个必不可少，但也不要追求过高的消费，如果超出了自己经济承担范围，那么将所剩无几，梦想目标是指，心中有一个或者多个明确的目标，并且用小本本将他们记下来，估计达成这个目标需要多少钱，多少时间。单独为他们开一个账户，当然这里的账户是指形式上的，目的就是为了实现这些目标而去存钱。</p><h2 id="三-进行明智的投资"><a href="#三-进行明智的投资" class="headerlink" title="(三)进行明智的投资"></a>(三)进行明智的投资</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;投资是一门高深的学问，我觉得入个门还是很有必要的，毕竟等到以后，人到中年了，还是靠着储蓄过日子，并不是理想的生活，我身边有很多长辈有观念上的错误，他们就是将挣到的钱定期存进银行里，一存就是五到十年，吃定期的利息，然而他们并想不清楚，你吃银行的利息，通货膨胀在吃你的本金，对于他们那一代人，这个观念既然不能扭转，那就从我们这一代人做起吧，培养理财意识，学习投资方式，也是一种赚钱的利器，万年亘古不变的道理：投资有风险！！！明智的投资会帮你入账不少，而一旦看错了眼，亏损也是常有的事，这就需要长期的积累经验，形成意识了，投资—得先从韭菜做起。</p><h2 id="四-关键在于自信程度"><a href="#四-关键在于自信程度" class="headerlink" title="(四) 关键在于自信程度"></a>(四) 关键在于自信程度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个老生常谈的话题，听过很多道理，喝过很多鸡汤，尝试过很多次，然而至少就我个人而言，我是一个没有自信的人，我顶多算是一个脸皮比较厚的人，自信和自卑是对立的，但是他们同样都是骨子里的东西，我们都活了二十多年了，经历的事也不少了，生活环境等等因素，到底是帮我们养成了自信，还是形成了自卑，只有我们自己清楚，深入骨髓的东西很难完全改变，但未必是坏事，在做任何事情的时候，保持谦逊的同时，也要掌握50%的主动权。</p><h2 id="五-你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱"><a href="#五-你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱" class="headerlink" title="(五) 你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱"></a>(五) 你最好想清楚你喜欢做什么，然后再考虑怎么用它来挣钱</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如上面所说的，不为挣钱而做一些没有意义的事，年轻人，多提升以下自己。花时间花精力修炼内功，学习，比什么都重要。</p><h2 id="六-欠债的人应该毁掉所有的信用卡"><a href="#六-欠债的人应该毁掉所有的信用卡" class="headerlink" title="(六)欠债的人应该毁掉所有的信用卡"></a>(六)欠债的人应该毁掉所有的信用卡</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里毁掉信用卡，并不是真正意义上的毁掉，就像那些段子：只要你卸载掉支付宝，你就不用还花呗了，对于花呗这个东西，该怎么去形容你最贴切？拿什么跟你作比较才算特别？还是要看用途的，如果是为了缓解经济压力，（这里的经济压力是指，你做了某些有意义的事后，欠下的债），有短期之内不要利息的钱用，何乐而不为呢？但是如果要是为了用这个花呗满足自己的消费欲望，那我觉得还是大可不必了，个人觉得，这种做法，是最low的，买不起我就不买。又不是必需品。还花呗的时候，也要在不收取利息的时候，还最低还款，但是要保证，最终能还清。</p><h2 id="七-真的有必要吗？"><a href="#七-真的有必要吗？" class="headerlink" title="(七)真的有必要吗？"></a>(七)真的有必要吗？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花钱买一样东西的时候，事先考虑有没有必要，你是真的需要他吗？买了之后有什么用？能给你带来你预期的效果吗？能用多久？有更好的替代品吗?一般，扪心自问这些问题之后，你就应该知道，该不该买了。得出买不买的结论之后，就要考虑，买什么样的？现在这个信息错综复杂的互联网时代，各种测评，各种推荐，各种大数据分析，最后到你手里的，也许达不到你的预期，什么性价比乱七八糟的，哪儿有什么性价比，都是些商家搞出来唬人的噱头，你真的能看准东西吗？所谓性价比，大部分就是低价配low货，想买的东西，就别去占便宜。你占的便宜最终都会反映在产品上。</p><h2 id="八-当你定下大目标的时候，就意味着你必须付出比别人更多的努力。"><a href="#八-当你定下大目标的时候，就意味着你必须付出比别人更多的努力。" class="headerlink" title="(八)当你定下大目标的时候，就意味着你必须付出比别人更多的努力。"></a>(八)当你定下大目标的时候，就意味着你必须付出比别人更多的努力。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我以前考四级的时候，考教师资格证，都没过，包括这次四级430分险过，是因为我没有努力吗？不是，我努力了，周围也有人裸考过了的，并且分比我高多了，羨慕吗？不羡慕，因为我努力过，我没过的原因是我的方法不对，也是努力的不够，你努力了不一定会成功，但你不努力，一定不会有结果，当然也有幸存者偏差，对于天生聪明，基础好的人，可能有些时候会听到这样说：没那个必要，这个也没什么实际意义。但是我始终会坚持自己的理念：当我定下大目标的时候，就意味着必须付出比别人更多的努力。幸运其实是充分准备加上努力工作的结果。</p><h2 id="九-克服畏惧心理"><a href="#九-克服畏惧心理" class="headerlink" title="(九)克服畏惧心理"></a>(九)克服畏惧心理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恐惧总是在我们设想事情会如何不顺利的时候出现，我们对失败的可能性想得越多，就越害怕，当你朝着积极地目标去思考的时候，就不会心生畏惧，我从小一直到现在，都没有真正意义上上台讲演过，我永远都是那个坐在台下为他人喝彩的观众，感叹她们真有魄力啊，就连在班级里做个自我介绍我都会脸红，我害怕面对很多人，害怕出糗，也不是没有过讲演的机会，因为我的畏惧，我也不知道我什么时候能踏出这一步，但是我会尽力克服自己的恐惧，等下次机会到来的时候，我不会拱手让人的。</p><h2 id="十-72定理"><a href="#十-72定理" class="headerlink" title="(十)72定理"></a>(十)72定理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72定理：用72除以投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所需要的年数，用72除以通货膨胀率的百分比，得出的数字就是这笔钱贬值一倍所需要的年数。还补充一点就是挑选基金时注意哪些问题：<br>1.基金至少有十年历史，也就是所谓的老基金<br>2.选择大型的跨国股票基金，以分散投资风险<br>3.了解基金的走势图，合理利用72定理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实之前说看完这本书，我并没有学到多少知识，这句话太过于自大，文章写到这里，我才发现，原来小狗钱钱教会我的东西并不少。去合理利用自己的<code>money</code>吧！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在B站看了半佛仙人一期关于理财的视频，视频里面也推荐了很多值得一看的书，有《小狗钱钱》，《海龟交易法则》，《经济学原理》，我首先看的是小狗钱钱，写下了这篇读后感。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读后感" scheme="http://daqwt.top/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>try-catch-finally总结</title>
    <link href="http://daqwt.top/2774241439/"/>
    <id>http://daqwt.top/2774241439/</id>
    <published>2020-03-24T01:42:10.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>在日常编译运行程序出错的时候，编译器就会抛出异常，抛出异常要比终止程序灵活的多，这是因为Java提供了一个”捕获”异常的处理器对异常情况进行处理，如果没有提供处理器机制，程序就会终止，try-catch-finally可以保证程序发生错误的时候继续执行下去。下面就谈一下使用的总结，和注意事项。</p><a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>try，catch，finally语句中，如果try语句有return语句，此后做任何修改，都不影响try中return的返回值。</li><li>如果finally块中有return语句，则try或catch中中的返回语句忽略。</li><li>如果finally块中抛出异常，则整个try，catch，finally块中抛出异常。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>在使用try- catch-finally的时候，要注意以下问题：<br>①尽量在try或者catch中使用return语句。通过finally块中达到对try或者catch返回值修改是不可行的。<br>②finally块中避免使用return语句，因为finally块中如果使用return语句，会显式的消化掉try，catch块中的异常信息，屏蔽错误的发生。<br>③finally块中避免再次抛出异常，否则整个包含try语句块的方法会抛出异常，并且会消化掉try，catch块中的异常。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常编译运行程序出错的时候，编译器就会抛出异常，抛出异常要比终止程序灵活的多，这是因为Java提供了一个”捕获”异常的处理器对异常情况进行处理，如果没有提供处理器机制，程序就会终止，try-catch-finally可以保证程序发生错误的时候继续执行下去。下面就谈一下使用的总结，和注意事项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统---中断机制</title>
    <link href="http://daqwt.top/1622515277/"/>
    <id>http://daqwt.top/1622515277/</id>
    <published>2020-03-23T15:07:08.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断机制可以说是操作系统里程碑上最划时代的一次变革。它在系统中起着通信网络的作用，协调系统对各种外部事件的响应和处理，中断是实现多道程序设计的必要条件，中断是CPU 对系统发生的某个事件作出的一种反应。因为有了它，我们才可以有条不紊的使用电脑！</p><a id="more"></a><ul><li><p>举个例子，CPU老板是一家公司的光杆司令，所有的顾客都要他亲自跑去处理，还要跟有关部门打点关系，CPU觉得顾客和公关这两样事它一个人搞不来，这就是轮询；终于这家公司升级发展了，CPU老板请了一个秘书，所有的顾客都先由秘书经手，CPU心情好的时候就去看一下，大部分时间都忙着去公关了，这时它觉得轻松了很多，这就是中断了~~</p></li><li><p>也就是说，中断和轮询是从CPU老板的角度来看的，不管怎样，事件都还是有人来时刻跟踪才能被捕获处理，不过是老板还是秘书的问题。所有的中断（或者异步，回调等）背后都有一个轮询（循环，listener）。</p></li><li><p><strong>中断机制的本质：CPU执行完每条指令时，都会去检查一个中断标志位</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200312181724601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312182615189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt=" "></p><p><img src="https://img-blog.csdnimg.cn/20200312182607627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312183153533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312183251723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;中断机制可以说是操作系统里程碑上最划时代的一次变革。它在系统中起着通信网络的作用，协调系统对各种外部事件的响应和处理，中断是实现多道程序设计的必要条件，中断是CPU 对系统发生的某个事件作出的一种反应。因为有了它，我们才可以有条不紊的使用电脑！&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---文件系统</title>
    <link href="http://daqwt.top/2892727560/"/>
    <id>http://daqwt.top/2892727560/</id>
    <published>2020-03-22T15:04:29.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>正在更新中。。。。</p><a id="more"></a><h1 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h1><ul><li><p>常见的文件系统有：：FAT、NTFS、ExtFAT、ext2、ext3、reiserFS、VFAT、APFS</p></li><li><p><strong>FAT:</strong> FAt12、FAT16、FAT32均是Fat文件系统，最初是为软盘设计的文件系统，但是后来随着微软推出dos和win 9x系统，FAT文件系统经过适配被逐渐用到了硬盘上。</p></li><li><p><strong>NTFS：</strong> 对FAT和HPFS作了若干改进，例如，支持元数据，并且使用了高级数据结构，以便于改善性能、可靠性和磁盘空间利用率，并提供了若干附加扩展功能。NTFS是一个<strong>日志文件系统</strong>，这意味着除了向磁盘中写入信息，该文件系统还会为所发生的所有改变保留一份日志。这一功能让NTFS文件系统在发生错误的时候（比如系统崩溃或电源供应中断）更容易恢复，也让这一系统更加强壮。在这些情况下，NTFS能够很快恢复正常，而且不会丢失任何数据。在很少出错情况下，微软表示你需要运行CHKDSK修复程序来对磁盘卷进行维护的概率特别低，其概率不到1%。</p></li><li><p><strong>ExFAT：</strong> 也是微软开发的文件系统，它是专门为闪存盘设计的文件系统，单个文件突破了4G的限制，而且分区的最大容量可达64ZB，建议512TB。 ExFAT在windows，Linux以及Mac系统上，都可以读写，<strong>作为U盘或者是移动硬盘的格式还是比较合适的。</strong></p></li></ul><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p><strong>EFI 系统分区：</strong> 通常指数据存储介质中的一个分区，通常用于硬盘或固态硬盘。它通常应用于 Unified Extensible Firmware Interface (UEFI)。当电脑通电启动时，UEFI会读取ESP 用来安装操作系统和各种实用工具。ESP需要格式化成FAT文件系统并且挂载至UEFI指定的位置。<br><strong>UEFI：</strong> <strong>统一可扩展固件接口</strong>（Unified Extensible Firmware Interface）是一种个人<strong>电脑系统规格</strong>，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正在更新中。。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---虚拟内存</title>
    <link href="http://daqwt.top/1080640073/"/>
    <id>http://daqwt.top/1080640073/</id>
    <published>2020-03-21T15:00:41.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是经常听到虚拟内存这个名词，尤其是在玩Linux的时候，其实不然，哪个是交换分区，跟虚拟内存还是有差别的。</p><a id="more"></a><ul><li><p>对一个程序来说，他在某一段时间内，只有某一些部分是需要在内存里面的。（局部性原理），虚拟内存管理，属于一个完全黑盒的封装，我们在使用的时候，几乎不需要考虑他的存在。</p></li><li><p>虚拟内存的两种实现方式：请求页，请求段。</p></li><li><p>请求页：如果有一个页面，只有当你真正需要他的时候，才把他加载到内存中来，有很多好处：降低IO操作，</p></li><li><p><strong>虚拟内存也是一种缓存思想</strong>：虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</p></li><li><p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘(较低层L5，参见我们上篇文章图4)的数据被分割成块(block)，这些块作为和主存(较高层,L4)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。</p></li><li><p>虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。</p></li><li><p>在任意时刻，虚拟页面都分为三个不相交的部分：<br>①<strong>未分配的(Unallocated)</strong> ：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。<br>②<strong>缓存的(Cached)</strong>： 当前已缓存在物理内存中的已分配页。<br>③<strong>未缓存的(UnCached)</strong> ：该页已经映射到磁盘上了，但是还没缓存在物理内存中。</p></li></ul><h2 id="swap分区的作用"><a href="#swap分区的作用" class="headerlink" title="swap分区的作用"></a>swap分区的作用</h2><ul><li><p>linux有一个swap分区。Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间中的信息被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。系统总是在物理内存不够时，才进行Swap交换。</p></li><li><p>电脑开着一个进程，几天不关机，也一直没关闭这个进程，随着运行的程序越来越多，内存快不够用了，所以操作系统就选择将这个音乐播放器的内存状态(包括堆栈状态等)都写到磁盘上的swap区进行保存。这样就腾出来一部分内存供其他需要运行的程序使用。等你要使用到这个进程了。此时， 系统会从磁盘中的swap区重新读取该进程的相关信息，送回内存接着运行。</p></li></ul><h2 id="补充注意"><a href="#补充注意" class="headerlink" title="补充注意"></a>补充注意</h2><p><strong>在window下也有类作用的硬盘空间，属于对用户不可见的匿名磁盘空间(在C盘)。</strong></p><p>特别注意：按照字面意思，swap交换区也可以称为虚拟内存<br>硬盘上的swap交换区，其实就相当于承担了内存的作用(只是速度很慢罢了)。swap交换区起到了扩大内存的作用。所以从某些意义上来讲，swap区也可以叫做虚拟内存，但是这个虚拟内存是字面意思。和我们本文当中站在计算机系统的角度来解释的虚拟内存不是一个概念。所以特别注意这一点。因为有些人理解的虚拟内存，就是swap交互区。此虚拟内存非彼虚拟内存，所以明白各自的概念和作用。</p><p><strong>linux环境下叫做swap分区，window下这块区域不叫swap分区，就直接按照字面意思叫做”虚拟内存”了。所以两个含义不同的虚拟内存</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;是不是经常听到虚拟内存这个名词，尤其是在玩Linux的时候，其实不然，哪个是交换分区，跟虚拟内存还是有差别的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---内存管理</title>
    <link href="http://daqwt.top/4128545857/"/>
    <id>http://daqwt.top/4128545857/</id>
    <published>2020-03-20T14:56:13.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习计算机操作系统的时候，CPU调度，进程管理，内存管理，是最最重要的，尤其是内存管理，要领悟这其中的理念。对编程来讲，代码实际没有问题了，而且经常要考虑的就是内存了。</p><a id="more"></a><h2 id="一、小知识"><a href="#一、小知识" class="headerlink" title="一、小知识"></a>一、小知识</h2><ul><li><p><code>socket</code>是指套接字，原义是接口。</p></li><li><p><code>Agent</code>：智能体</p></li><li><p><code>Architect</code>：架构师</p></li><li><p>每个进程都有一个系统给定的权限，不能做超出自己权限的事。</p></li><li><p>cpu，内存，文件：是操作系统最具代表性的资源。</p></li><li><p><strong>逻辑地址（虚拟地址，偏移地址）</strong> 这个地址都是由cpu发出的地址（程序运行的时候，我们看的到的地址）</p></li><li><p><strong>物理地址：</strong> 真实存在的，计算机里实实在在的内存，从0开始。</p></li><li><p><strong>MMU内存管理单元：</strong> (Memory Management Unit)作用：把逻辑地址映射到物理地址，是CPU内部的一个小部件。</p></li><li><p>cpu只能访问（内存/寄存器）。所以对内存的管理很重要。</p></li><li><p>内存管理的主要问题：给每个进程分配内存的时候，内存怎么放？放多少？</p></li></ul><h2 id="二、内存分配策略"><a href="#二、内存分配策略" class="headerlink" title="二、内存分配策略"></a>二、内存分配策略</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li>每个进程的寄存器中都包括<code>Base</code>（基质寄存器和<code>Limit</code>（内存地址上限寄存器）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200328101305708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>当进程发出访问地址请求的时候，就要做两次验证，这就是安全保护的基本策略，限制了访问范围只能在（base-limit）。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200328101818474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>但是这样每次访问都要验证，会带来很大速度时间延迟，怎么解决呢？</li><li>每一个进程，每个程序的每次运行，被放在内存中的位置是不固定的。这怎么解决呢？<br>这就涉及到一个，指令和数据在内存当中地址绑定的一个问题。</li></ul><h3 id="加载时刻（Load-time）"><a href="#加载时刻（Load-time）" class="headerlink" title="加载时刻（Load time）"></a>加载时刻（Load time）</h3><ul><li><code>Load time</code>（加载时刻）编译器编译运行的时候，并不知道程序会被放在内存的哪个位置。我们可以通过设定一些标记。当程序被加载到内存的时候，这个加载程序（loader）知道要放在哪个位置，放入之后，他就对这个程序里的所有（对地址访问的代码的数值）进行一个完整的修改，修改为目前放的位置。这个策略（由loader做动态的复制）很好的解决了多进程同时存在的问题。</li></ul><h3 id="执行时处理（Execution-time）"><a href="#执行时处理（Execution-time）" class="headerlink" title="执行时处理（Execution time）"></a>执行时处理（Execution time）</h3><ul><li>最好的策略：<code>Execution time</code>（执行时处理）不仅可以在内存中放多个进程。而且这个程序已经在内存的时候，甚至可以挪动他。但需要硬件支持，通过修改base的值，就可以实现挪动进程在内存中的位置。</li></ul><h2 id="三、内存管理策略"><a href="#三、内存管理策略" class="headerlink" title="三、内存管理策略"></a>三、内存管理策略</h2><ul><li>目的是是内存空间利用率最大化，尽量让他放更多的进程，为了做到这一点，设计了很多策略<h3 id="动态加载（Dynamic-Loading）"><a href="#动态加载（Dynamic-Loading）" class="headerlink" title="动态加载（Dynamic Loading）"></a>动态加载（Dynamic Loading）</h3></li><li>解决的问题：程序运行到退出，并不会把所有的代码都执行一遍，总有一些用不到的。那为什么要把所有的程序代码都加载到内存呢？<strong>动态加载</strong> 就可以很好的解决这个问题，只加载要用的部分，不用的部分不加载。这样使得内存空间利用率获得很大的提升。</li><li>局部性原理</li><li>DLL:动态链接库（Dynamic Link Library），可以看到我们下载的许多软件中，有很多后缀名为<code>.dll</code>的文件，这就是动态链接库。使用有很多好处。<br>①需要使用某个功能的时候，就去加载这个<code>.dll</code>文件。这就实现了动态加载。<br>②很好的实现了共享，他在内存中只存在一份，但是很多程序都可以使用他。<br>③很容易更新，windows主要更新的漏洞就是这个<code>.dll</code>文件。</li></ul><h3 id="交换技术（Swapping）"><a href="#交换技术（Swapping）" class="headerlink" title="交换技术（Swapping）"></a>交换技术（Swapping）</h3><ul><li>解决的问题：系统中有好多进程在运行，但是有些时候有的进程已经占据了内存，由于各种原因，这个进程属于休眠状态，好长时间不会运行，但是又有进程要进来，却没有空间。这就形成了内存空间的浪费。怎么解决呢？</li><li>将这个占着茅坑不拉屎的进程写到硬盘上去，这个内存空间就腾出来了。过一会儿时间，它又具备了运行条件，就把他写进来。</li><li>好处：用硬盘做他的补充，就好像内存变大了一样，可以放更多的进程。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200328140456436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="连续分配（Contiguous-Allocation）"><a href="#连续分配（Contiguous-Allocation）" class="headerlink" title="连续分配（Contiguous Allocation）"></a>连续分配（Contiguous Allocation）</h3><ul><li>现在操作系统中已经很少用了</li><li>首次适应算法（使用最多），下次适应算法，最佳适应算法，最差适应算法</li><li>最大的问题：对内存的申请释放的随机性， 无法很好的适应它，就不能保证用量很好。</li><li>对编程人员：对内存的使用可以是随机的，也可以自己来设定，总结出来规律之后，就能更好的管理这块儿空间。但是<strong>你申请到了内存，其实你并没有得到她，当你真正访问它的时候，才得到</strong></li><li>碎片（外部碎片&amp;内部碎片）</li></ul><h2 id="四、页式存储管理（重点）"><a href="#四、页式存储管理（重点）" class="headerlink" title="四、页式存储管理（重点）"></a>四、页式存储管理（重点）</h2><ul><li>内部碎片：页式存储管理是产生外部碎片的罪魁祸首。因为计算机分配内存是按照2的指数次幂个字节来分配，比如说，4字节，8字节，16字节，但是进程有的时候用不完这些，比如只需要5字节，就会多出来3字节，这就成了碎片。</li><li>特点：<br>①非连续性：（<strong>物理空间非连续</strong>）进程在物理内存中占据哪些内存，是不连续的，会把进程切成小碎片，散落在各个区域，（<strong>逻辑空间非连续</strong>）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200330210147149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>从图中可以看出，进程在内存中保存的位置是散乱的，这样带来的好处就是，每一个页面都会被利用到，不会产生外部碎片，使得物理内存管理起来非常方便。但是这样做还是很麻烦。</li><li><strong>为什么页面大小是2的整数次幂？</strong><br>如果不是2的整数次幂，就没有办法计算偏移地址，没办法从中间分隔开， 神奇的二进制。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200330215903204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200330215821402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>页式存储管理：也许这图只有我自己才能看懂吧，口头概述加深记忆，从<strong>逻辑地址</strong> 中拿出编号，写成四位二进制数，因为每页是四个字节（2的2次幂），所以要从第二位切一刀，（如果每页面是八字节，2的3次方，就要从第三位切）前面的是虚页号，后面的是页内偏移地址，根据虚页号，在页表中找到对应的物理页号，在将物理页号写成二进制数，加在虚页号前面，拼接成一个新的二进制数，然后再转化为十进制数，根据得到的数字，就可以找到<strong>物理地址</strong> 中对应的数据<br><img src="https://img-blog.csdnimg.cn/20200330222802562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>这个页面越大越好吗？</strong> （页面的大小是2的整数次幂）<br>①页面小的话，内部碎片越少，但是会增加页表的大小（有多少个页面，页表里就要有多少个项），每一个页表项都是要占空间的，他在内存中。这样的话虚拟地址到物理地址的映射就会慢。<br>②页面大的话，内部碎片就变多了，页表会减少。虚拟地址到物理地址的映射会很快。<br>③折中（4k的页面用的多），所以要看使用情况的不同了，对大进程来说，页表的体积就会缩小，从内部碎片来看，进程也不多，浪费就浪费吧。<br>④在未来开发或者管理过程中，都可以通过改变页面大小调优，从而提高系统效率，内存使用更充分。（调整一定要遵从硬件的架构）<br><img src="https://img-blog.csdnimg.cn/20200331094630441.png" alt="在这里插入图片描述"></p></li><li><p><strong>页表是怎么实现的？</strong><br>在内存中，有两个参数，放在寄存器中，一个叫页表基址寄存器（指向页表起始位置），页表长度寄存器（页表的长度），这两个地址都是绝对的物理地址，不跟虚拟进程有任何的瓜葛。</p></li><li><p><strong>问题：数据，指针每次都要访问两次内存。</strong>（先进内存查页表，得到物理地址，再进内存中查到该数据。）怎么解决？<br>用<strong>TLB（ranslation look-aside buffers）</strong> 快表—相当于硬件的cache，思想也是跟cache一样（加快访问内存的速度）。cache是将当前最热的数据放在里面。TLB也是如此，把你当前用到的，最热的拿过来放入表中，就省去了根据虚页号去查物理页号。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200330230414986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>在快表中，存储的多了，查找起来也费时间，那么怎么加快查找速度呢？</strong><br>使用硬件<strong>并行搜索</strong> （涉及到电路问题），软件实现并行很麻烦，但硬件很简单。只用查找一次。如果一次没找到（未命中），就会去普通的页表查找，并且更新到快表中。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200330231019913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><ul><li>如何实现多个进程互相之间不能访问到彼此的内存？<br>对指令严加把控，读，写，执行。<strong>Valid-invalid bit（有效无效位）</strong> 有效V即可访问。无效i触发一个中断，操作系统意识到这个进程执行了一个非法操作，就会杀死该进程。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331102926413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li>在页式存储管理中，实现内存共享是简单的。该共享的就共享，该私有就私有</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331103841486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Copy-on-write(写时复制)<h3 id="两级-三级页表结构（Two-Level-Page-Table-Scheme）"><a href="#两级-三级页表结构（Two-Level-Page-Table-Scheme）" class="headerlink" title="两级/三级页表结构（Two-Level Page-Table Scheme）"></a>两级/三级页表结构（Two-Level Page-Table Scheme）</h3></li><li>由外层页表算出来，对应的是哪个项，再根据这个项，找到对应的内存页表，再根据虚页号，找到物理页号，进而找到对应的实际物理地址。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331105513611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>4k物理页面的页内偏移是12位（因为4k=2的12次方），剩下的20位属于页面号。然后再将这20位页面号分割成两部分。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331110258645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>在根据p1（前面页面号）和p2（内存页面号），查找。<br><img src="https://img-blog.csdnimg.cn/20200331110450735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>64位系统如果采用两级页面的话，就要维护42位的前面页面号。这是一个很大的开销，所以出现了三级页表，再将页面好进行划分。64位系统的开销比32位的大。<strong>现在的64位系统采用的就是三级页表。</strong></p></li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>页表耗费的时间还是挺大的，出现了哈希表，这样在内存中维护的就不是页表，而是哈希表。但是哈希表存在碰撞。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331113521429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="反表（Inverted-Page-Table）"><a href="#反表（Inverted-Page-Table）" class="headerlink" title="反表（Inverted Page Table）"></a>反表（Inverted Page Table）</h3><ul><li><p>这是64位系统使用的方法，因为我们实际上要管理的是物理内存，如果把系统中所有进程的所有列表项放在一起看的话，这些页表项里，有用的，有价值的，只是那些和物理内存相对应的，没有对应关系的页表项是没有存在价值的。如果我们把所有没价值的列表项都扔掉，那么页表的体积就可以得到控制了。控制到：有多少个物理内存，有多少个物理页面，那么就有多少个页表项，一一对应。</p></li><li><p>全系统中只有一张页表。<strong>但是！！！</strong> 这种方法cpu不支持，我们现在用的方法就是多级页表。因为要兼容32位，64位。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200331114757184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="五、段式内存管理（Segmentation）"><a href="#五、段式内存管理（Segmentation）" class="headerlink" title="五、段式内存管理（Segmentation）"></a>五、段式内存管理（Segmentation）</h2><ul><li>把程序分成若干段，程序段，代码段，栈，等等等等。在进程的逻辑空间中，自己划分出若干块，每块放不同的东西，执行不同的功能。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200331120344173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="六、段页式管理"><a href="#六、段页式管理" class="headerlink" title="六、段页式管理"></a>六、段页式管理</h2><ul><li>inter的cpu做得非常强大，你可以段式管理，页式管理，也可以段页式管理。</li><li>这是，我们目前cpu里面的机制，每执行一个指令，就要执行这个过程。<img src="https://img-blog.csdnimg.cn/20200331121145800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在学习计算机操作系统的时候，CPU调度，进程管理，内存管理，是最最重要的，尤其是内存管理，要领悟这其中的理念。对编程来讲，代码实际没有问题了，而且经常要考虑的就是内存了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---备份本地站点到github上</title>
    <link href="http://daqwt.top/3220545803/"/>
    <id>http://daqwt.top/3220545803/</id>
    <published>2020-03-20T09:12:35.000Z</published>
    <updated>2020-05-06T12:25:42.114Z</updated>
    
    <content type="html"><![CDATA[<p>试想一下，就你自己的电脑上配置了hexo，平时写博客，部署都是在自己电脑上，那万一有一天，用的不是自己电脑，又想要写博客，那怎么办呢？此时就要用到git了，将你的站点配置等信息备份到github上，要用的时候，用 git clone到本地。而且好处不仅如此，万一哪天出了问题，有个备份，岂不美哉？</p><a id="more"></a><h2 id="一、本地配置"><a href="#一、本地配置" class="headerlink" title="一、本地配置"></a>一、本地配置</h2><ul><li>由于是在个人电脑上配置的<code>hexo</code>，部署也不方便，如果在另外一台机子上写博客，没有<code>hexo</code>的配置也不行，另一方面出于备份项目的目的，最好的办法是将本地<code>hexo</code>站点备份到<code>Github</code>上。</li></ul><p>1.新建<code>hexo</code>文件夹存放分支工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br></pre></td></tr></table></figure><p>2.把你的GitHub的远程仓库克隆到<code>hexo</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/DAQ121/DAQ121.github.io hexo</span><br></pre></td></tr></table></figure><p>3.删除除了版本管理的<code>.git</code>之外的所有文件和文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">rm -r *</span><br></pre></td></tr></table></figure><p>4.把要备份的文件复制到<code>hexo</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaffolds/</span><br><span class="line"><span class="built_in">source</span>/</span><br><span class="line">themes/</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><p>5.如果使用的主题是从Github克隆的，那么使用命令删除它的Git文件（以next主题为例）,否则无法将主题文件<code>push</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -R themes/next/.git*</span><br></pre></td></tr></table></figure><h2 id="二、github配置"><a href="#二、github配置" class="headerlink" title="二、github配置"></a>二、github配置</h2><p>1.github创建一个<code>hexo</code>分支 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>2.保存所有文件到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><p>3.提交变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"创建hexo分支"</span></span><br></pre></td></tr></table></figure><p>4.推送到github，并用<code>--set-upstream</code>与<code>origin</code>创建关联，将<code>hexo</code>设置为默认分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure><h2 id="三、合并管理"><a href="#三、合并管理" class="headerlink" title="三、合并管理"></a>三、合并管理</h2><ul><li>现在有两个需要管理的文件夹，一个是<code>blog</code>，一个是<code>hexo</code>，但是每次发布文章的时候如果要提交两次就很失效率，</li></ul><p>1.将本地<code>hexo</code>分支中的<code>.git</code>文件夹复制到<code>blog</code>根目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a .git ../blog</span><br></pre></td></tr></table></figure><p>2.<code>master</code>分支的文件则由<code>hexo</code>管理，编辑<code>hexo</code>配置文件<code>_config.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   <span class="built_in">type</span>: git</span><br><span class="line">   repo: https://github.com/DAQ121/DAQ121.github.io</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure><h2 id="四、发布文章"><a href="#四、发布文章" class="headerlink" title="四、发布文章"></a>四、发布文章</h2><p>1.新建文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.将相关更改推送到<code>hexo</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"发表文章test"</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>3.将静态文件推送到<code>master</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h2 id="五、使用的时候如何迁移"><a href="#五、使用的时候如何迁移" class="headerlink" title="五、使用的时候如何迁移"></a>五、使用的时候如何迁移</h2><p>1.将<code>hexo</code>分支克隆下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo http://github.com/DAQ121/DAQ121.github.io</span><br></pre></td></tr></table></figure><p>2.安装<code>hexo</code>依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure><p>3.只不过每次发文章的时候，要输入用户名和密码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试想一下，就你自己的电脑上配置了hexo，平时写博客，部署都是在自己电脑上，那万一有一天，用的不是自己电脑，又想要写博客，那怎么办呢？此时就要用到git了，将你的站点配置等信息备份到github上，要用的时候，用 git clone到本地。而且好处不仅如此，万一哪天出了问题，有个备份，岂不美哉？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>HTPP中的GET和POST</title>
    <link href="http://daqwt.top/1483407090/"/>
    <id>http://daqwt.top/1483407090/</id>
    <published>2020-03-20T03:50:00.000Z</published>
    <updated>2020-04-17T03:13:58.975Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器点击某个按钮，会向服务器发送一个请求（request），服务器收到请求之后，会返回给我们一个响应（response），那这个请求是如何发送的呢。</p><a id="more"></a><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><ul><li>HTTP是什么？<br>HTTP基于TCP/IP，它是关于<strong>数据如何在万维网中通讯</strong> 的协议。</li><li>GET和POST是什么？<br>HTTP协议中的两种<strong>发送请求</strong> 的方法。</li></ul><h2 id="二、简单理解"><a href="#二、简单理解" class="headerlink" title="二、简单理解"></a>二、简单理解</h2><ul><li><p>把万维网传输线路比作一条高速公路，公路上的汽车就相当于一个个<strong>TCP</strong> ，用他们来实现可靠数据传输，但是车也有不同车型，如果全都一样，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通就会瘫痪。为了避免这种情况发生，需要制定好交通规则，也就是<strong>HTTP</strong>协议。</p></li><li><p>HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等。<br>①当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。<br>②如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物；也可以在POST的时候在车顶上也放一些数据。<strong>HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</strong></p></li><li><p>不同的浏览器（发起http请求）和服务器（接受http请求），虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是数据量太大对浏览器和服务器都是很大负担。 于是大多数浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分不处理。如果使用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p></li><li><p>所以可以这么理解：GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p></li></ul><h2 id="三、标准答案"><a href="#三、标准答案" class="headerlink" title="三、标准答案"></a>三、标准答案</h2><ul><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ul><h2 id="四、关键区别"><a href="#四、关键区别" class="headerlink" title="四、关键区别"></a>四、关键区别</h2><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li><li>通俗来讲就是：<br>①对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。<br>②对于POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li><li>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。但是！！！！<br>①GET与POST都有自己的语义，不能随便混用。<br>②在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br>③并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在浏览器点击某个按钮，会向服务器发送一个请求（request），服务器收到请求之后，会返回给我们一个响应（response），那这个请求是如何发送的呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="https" scheme="http://daqwt.top/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---进程管理</title>
    <link href="http://daqwt.top/853277148/"/>
    <id>http://daqwt.top/853277148/</id>
    <published>2020-03-19T14:46:46.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程，也就是任务，这里有必要说一下进程和线程的区别：进程是资源分配的最小单位，线程是程序执行的最小单位，通俗来讲，一个爹可以有很多儿子，但儿子之后一个爹，并且还遗传这个爹，爹能做大事，而儿子，做一些杂七杂八的给爹打下手，你细细品。这篇文章主要讲进程管理的策略。</p><a id="more"></a><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ul><li>进程：打开任务管理器，里面正在执行的任务，一个程序运行起来了，它就是一个进程。</li><li><code>jobs</code>是最早的进程原型，也就是单道批处理系统，cpu一次只运行一个程序，其他的程序要事先放在内存中，等待上一个程序执行完了，他再去执行。</li><li>后来出现了分时操作系统，大家轮着执行。使用cpu，称之为任务。</li></ul><h2 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h2><p><img src="https://img-blog.csdnimg.cn/20200319160008644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>程序计数器（pc）和各种寄存器</li><li>数据段</li><li>代码段</li><li>栈</li><li>堆</li><li>栈内存，堆内存慢慢增长，到一定程度，会导致内存不足的情况。</li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li>操作系统就是通过切换进程的状态，达到进程控制的目的。也实现了很多进程同时运行，周而复始。有条不紊</li></ul><p><img src="https://img-blog.csdnimg.cn/20200319161707691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>new（新建）</li><li>ready（就绪态）：一个进程是完全可以运行的，万事俱备，只差cpu。</li><li>running（运行态）：拥有cpu的进程，一个cpu上只能运行一个进程，什么时候它会把cpu交出去？<br>①中断interrupt：她本可以继续运行下去的，但是操作系统觉得它运行的太久了。或者是有更重要的要做，所以就把他给中断了，打回到就绪态。<br>②主动让出cpu：这个进程要去做一个io操作，或者是等待一个事件（等不到这个指令，他就不知道要做什么），这个时候就会让出cpu。进入就绪状态。</li><li>waiting（等待态）：被唤醒（有响应了，知道自己该做什么了）之后进入就绪态。</li><li>terminated（结束）</li></ul><h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><ul><li>进程控制块PCB（Process Control  Block）是一个结构体，通过它来控制进程。每个进程都有一个PCB。通过PCB能找到这个进程的位置，状态，信息。</li><li>进程1切换的时候，将这个进程的所有信息保存到PCB寄存器中，以保证下次在运行的时候，就是上次停止的状态。</li><li>如何挑选下一个进程来执行呢，这就涉及到内核的调度算法了。</li><li>所有的PCB结构体，在一起构成了一个队列。</li><li>进程是在不同的队列之间，来回迁移。例如：就绪队列，I/O等待队列。</li><li>用一个大数组来装所有的PCB结构体，用一个指针来指向PCB数组中的这个进程。</li><li>软件做不了的事，硬件可以做。</li></ul><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><ul><li>一开机就会发现有进程，这些都是系统级的进程 ，如shell，资源管理器，一些应用程序设置的开机自启动就是通过shell来启动的，相当于捆绑销售一样 。</li><li>打开应用程序，双击，这个命令给了资源管理器，或者命令行下，是把指令给了shell</li><li>父进程与子进程</li><li>unix创建进程：fork（）生成一个子进程 </li><li>top 命令，监视现在所有进程的状态，每隔一秒种刷新一次。</li><li>windows创建进程：create process </li><li>msdn—微软的百科全书。 </li><li>杀死进程：kill</li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>多进程模式模块化</p><ul><li><strong>消息传递（Mwssage passing）</strong> ：A进程把消息从自己的内存空间复制一份到内核中，然后内核再把消息复制一份给进程B。用系统调用进行信息传递。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200319194014153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>共享内存（Shared memory）：</strong> 每个进程都有自己独立的地址空间，但是两个进程，甚至更多的进程通过协商（也是系统调用来协商）划分出来一块儿共享内存。在每个进程的地址空间都有。A在这块儿空间里一写数据，B马上就可以读取到。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200319194244682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>共享内存在协商的时候，要经过一系列的系统调用。而且还要约定好，过程很麻烦。如果进程之间共享内存，就要负责任，实现同步，不要同时写在同一个地方。</li><li><strong>消息传递</strong> 很方便。经常用到。分为两种：<br>①阻塞型：（更好用）<br>当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么你当前这个进程就会被挂起，被放到等待状态，被阻塞。<br>②非阻塞型：（考虑的比较多 ）<br>当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么这个请求会在后台去操作，同时这个系统调用会返回，空闲时候会回到你的进程，这个系统调用的返回值会告诉你，这个操作没有完成，进程根据这个返回值来判断是否完成操作，并做其他操作。</li></ul><h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><ul><li>父进程会把所有的信息复制一份给子进程，自此变成两个独立的进程，互相不影响。</li><li>以我们的角度来看，这样的子进程，父进程是不是太浪费内存了，但是，操作系统只是表面上让你看到它是把父进程复制给了子进程，但其实，他可以做到父进程和子进程之间完全相同的部分之间共享内存。所以大可不必担心这个问题。</li><li>多进程编程最重要的一个特性，也是我们首先要了解到的，独立性，直观上来看，他们两个进程之间互相不干扰。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><p>进程的特点是分离，而线程就是不分离。 互相协作的关系</p></li><li><p>线程有： 线程ID，PC寄存器，栈 。。。 </p></li><li><p>引入进程的目的就是让一个进程里面同时有多条执行路线，同时发挥作用。</p></li><li><p>多线程优点：<br>①快速的响应能力：有比较耗时的操作是，创建线程去做，主线程用来和用户 交互。<br>②资源共享：协作更方便，数据传递更方便<br>③经济实惠：线程更加节约资源。 </p></li><li><p>用户级线程：<br>①优点：效率高，可定制性好，。<br>②缺点：用户线程中任何一个线程，如果调用了阻塞性的系统调用，那么所有用户线程就全被阻塞。因为在操作系统看来，这么这个线程就是同一个线程，就会被阻塞掉。用户线程不能在多个处理器上并行运行。</p></li><li><p>内核级线程：操作系统提供的线程。</p></li><li><p>线程池：先创建多少个线程，要用的时候 就去拿，但是也有缺点。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;进程，也就是任务，这里有必要说一下进程和线程的区别：进程是资源分配的最小单位，线程是程序执行的最小单位，通俗来讲，一个爹可以有很多儿子，但儿子之后一个爹，并且还遗传这个爹，爹能做大事，而儿子，做一些杂七杂八的给爹打下手，你细细品。这篇文章主要讲进程管理的策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---部署网站到云服务器</title>
    <link href="http://daqwt.top/3010328778/"/>
    <id>http://daqwt.top/3010328778/</id>
    <published>2020-03-19T08:49:31.000Z</published>
    <updated>2020-05-06T12:25:55.921Z</updated>
    
    <content type="html"><![CDATA[<p>由于这次的疫情，最爱的马云爸爸的阿里云推出了学生在家上机实践的活动，免费领六个月的ECS云服务器，天呐，2核4G啊，六个月之后还可续费六个月，整整一年呐，市场价780软妹币呢，不过投放量少，而且还是每天早上八点领，连续7:55闹钟起早，终于，在第三个早上，马云爸爸眷顾了我，我领到了。领到了就不能让他吃灰吧，于是先部署个博客再说。因为之前博客是托管在github上面的。而github的服务器又在国外，所以访问速度十分感人，但是有了国内的服务器就不一样了，瞬间嗖嗖嗖。。。</p><a id="more"></a><p><strong>写在开头的话：</strong> 对于一个刚接触的门外汉来说，搭建博客，到部署到服务器真的让人崩溃，但是在不断地排错过程中，也渐渐弄懂了一些东西。很值得！由于我的域名还在备案中，DNS解析已经停掉了，所以暂时只能用公网IP访问：<a href="https://123.57.60.151">123.57.60.151</a>，后期等备案成功后再做修改，并且进一步优化。还想做一点SEO的东西。</p><h1 id="一、云服务器配置"><a href="#一、云服务器配置" class="headerlink" title="一、云服务器配置"></a>一、云服务器配置</h1><h2 id="①建立博客存放的目录"><a href="#①建立博客存放的目录" class="headerlink" title="①建立博客存放的目录"></a>①建立博客存放的目录</h2><ul><li>我的目录是：<code>home/www/blog</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> /www</span><br><span class="line">mkdir /blog</span><br></pre></td></tr></table></figure><h2 id="②安装nginx"><a href="#②安装nginx" class="headerlink" title="②安装nginx"></a>②安装nginx</h2><ul><li><strong>搭建服务器环境，以nginx做服务器。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.安装</span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line">2.启动服务器</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line">3.在浏览器地址栏中输入你的公网ip，如果打开了有内容网页，说明成功了。</span><br></pre></td></tr></table></figure><ul><li><strong>配置服务器的路由：</strong><br>通过公网ip访问，这个地址指向的是nginx，得让他指向我们的博客，就要修改配置文件，找到配置文件<code>etc/nginx/nginx.conf</code>,并不建议直接修改配置文件，应该先创建一个新的文件，然后采用<code>include</code>的方式，将这个文件包含进<code>nginx.conf</code>中。</li></ul><p>1.新建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/</span><br><span class="line">mkdir vhost</span><br><span class="line"><span class="built_in">cd</span> vhost</span><br><span class="line">vim blog.conf</span><br></pre></td></tr></table></figure><p>2.编写配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编辑blog.conf 如下：</span><br><span class="line">server&#123;</span><br><span class="line">listen  80;</span><br><span class="line">root /home/www/blog;这里填博客目录存放的地址</span><br><span class="line">server_name 这里填域名如(www.baidu.com) 如果暂时没有域名就填阿里云的公网ip，以后有了再改回来;</span><br><span class="line">location /&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.用<code>include</code>插入到<code>nginx.conf</code>中</p><p><img src="https://img-blog.csdnimg.cn/20200317193028631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4.如果以后还想添加新的网站，也可以在vhost目录下新建一个conf配置文件。然后再用<code>include</code>装入到<code>nginx.conf</code>中。<br>5.（<strong>先跳过这一步，等到最后有问题了，再回来</strong>）最后可能会出现只能访问centOS的怪相，所以，如果出现那个问题了，请你回到这一步，增加一个操作，就是上图中那个<code>server</code>里面的<code>root</code>后面的路径，替换成你的博客存放位置：例如我的是<code>/home/www/blog</code>（这是我经验所得，可能你就会卡在这一步）。</p><h2 id="③安装Nodejs"><a href="#③安装Nodejs" class="headerlink" title="③安装Nodejs"></a>③安装Nodejs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.换源</span><br><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line"></span><br><span class="line">2.安装</span><br><span class="line">yum install -y nodejs</span><br><span class="line"></span><br><span class="line">3.检查版本</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="④安装Git以及配置仓库"><a href="#④安装Git以及配置仓库" class="headerlink" title="④安装Git以及配置仓库"></a>④安装Git以及配置仓库</h2><ul><li><strong>目的：</strong> 使本地主机可以通过<code>ssh</code>方式连接到云服务器，我们就可以在本地使用<code>git</code>将我们的博客部署到服务器上。</li></ul><p>1.安装<code>git</code>并查看版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.安装</span><br><span class="line">yum install git</span><br><span class="line">2.查看版本</span><br><span class="line">git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure><p>2.新建<code>git</code>用户，并修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.新建git用户</span><br><span class="line">adduser -m  git</span><br><span class="line">2.修改用户权限</span><br><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>3.添加<code>Git  ALL=(ALL)   ALL</code></p><p><img src="https://img-blog.csdnimg.cn/20200317200019229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4.保存退出后，将权限改回去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure><p>5.设置<code>git</code>密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure><p>6.切换到<code>git</code>用户，在<code>~</code>目录下，可以看到有一个<code>.ssh</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir .ssh</span><br><span class="line"><span class="built_in">cd</span> /.ssh</span><br></pre></td></tr></table></figure><p>7.生成公钥密钥文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">此时在目录下就会有两个文件，分别是id_rsa 和 id_rsa.pub</span><br></pre></td></tr></table></figure><p>8.id_rsa.pub 就是公钥文件，将他复制一份。目录下就会多出一个authorized_keys文件，它和id_rsa.pub一模一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp id_rsa.pub authorized_keys</span><br></pre></td></tr></table></figure><p>9.修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>10.在<strong>本地主机</strong>上打开<code>cmd</code>，使用<code>ssh</code>方式连接云服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -v git@123.57.60.151(这里填的是服务器公网ip)</span><br></pre></td></tr></table></figure><p>11.输入密码之后，看到如图，即代表成功！！！！</p><p><img src="https://img-blog.csdnimg.cn/20200317202421490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>12.创建一个<code>git</code>的仓库，并且新建一个<code>post-receive</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.创建并初始化Git仓库</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git init --bare blog.git</span><br><span class="line"></span><br><span class="line">2.新建post—receive文件</span><br><span class="line">vi ~/blog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">3.输入以下内容：</span><br><span class="line">git --work-tree=/home/www/website --git-dir=/home/git/blog.git checkout -f</span><br><span class="line"></span><br><span class="line">4.保存退出之后赋予可执行权限</span><br><span class="line">chmod +x ~/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p><strong>至此，服务器端的配置完成！！！！！！！！</strong></p><h1 id="二、本地主机配置"><a href="#二、本地主机配置" class="headerlink" title="二、本地主机配置"></a>二、本地主机配置</h1><p><strong>说明：</strong> 因为我之前没有云服务器的时候，是把博客部署在<strong>github</strong>仓库中的，所以，在下面的<code>config.yml</code>中会出现两个仓库，这并不影响，他会同时部署到<code>github</code>中和云服务器上，想要了解的话可以去看这篇文章：<a href="https://blog.csdn.net/weixin_44861399/article/details/104673527">https://blog.csdn.net/weixin_44861399/article/details/104673527</a>，下面就是正式的，将本地主机与服务器连接起来的具体步骤了。</p><h2 id="①安装git"><a href="#①安装git" class="headerlink" title="①安装git"></a>①安装git</h2><p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><h2 id="②安装Node-js"><a href="#②安装Node-js" class="headerlink" title="②安装Node.js"></a>②安装Node.js</h2><p>下载地址：<a href="http://nodejs.org/download/">http://nodejs.org/download/</a></p><ul><li>安装的时候，选择<code>add to path</code>，他会自动配置环境变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">出现版本号说明安装成功</span><br></pre></td></tr></table></figure><ul><li>换镜像（亲身体验，可以省去以后好多麻烦）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="③安装Hexo"><a href="#③安装Hexo" class="headerlink" title="③安装Hexo"></a>③安装Hexo</h2><ul><li>用cnpm全局安装，在桌面右键打开<code>Git bash here</code>输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装完成后，在命令行里输入<code>hexo -v</code>检查是否安装成功。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305155050299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④hexo本地部署"><a href="#④hexo本地部署" class="headerlink" title="④hexo本地部署"></a>④hexo本地部署</h2><ul><li>在本地新建一个文件夹，我命名它为blog</li><li>在这个文件夹下，右键打开<code>Git Bash here</code>，输入<code>hexo init</code>，我在这个地方出现了一个<code>WARN</code>，暂时不用管它。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305135143147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>继续输入<code>cnpm install</code>可以看到blog文件夹里出现：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305155919286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>输入：<code>hexo g</code></li><li>输入：<code>hexo s</code> </li></ul><p><img src="https://img-blog.csdnimg.cn/20200305135917128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>打开浏览器输入<code>localhost：4000</code>，可以看到部署好了，有一篇<code>hello World</code>的博客</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305154439378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑤连接到远端服务器"><a href="#⑤连接到远端服务器" class="headerlink" title="⑤连接到远端服务器"></a>⑤连接到远端服务器</h2><ul><li>安装 <code>deployer</code> 插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>打开<code>F:\blog\_config.yml</code>,找到 <code>deploy</code>。填写你自己的仓库名字。不能同时又相同的<code>repo</code>，需要删除一个。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200317204903306.png" alt="在这里插入图片描述"><br><strong>至此，本地主机的配置也完毕了！！！！</strong></p><h1 id="三、发布文章"><a href="#三、发布文章" class="headerlink" title="三、发布文章"></a>三、发布文章</h1><ul><li>写一篇文章：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.新建文章，并编写，如何编写，百度</span><br><span class="line">hexo new <span class="string">"Hello My First Blog"</span></span><br><span class="line"></span><br><span class="line">2. 发布(要在blog文件夹下打开git)</span><br><span class="line">hexo clean &amp;&amp; hexo generate --deploy</span><br></pre></td></tr></table></figure><ul><li>重启服务器的nginx</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><ul><li>浏览器地址栏中输入公网ip查看成果。</li></ul><h1 id="四、美化博客"><a href="#四、美化博客" class="headerlink" title="四、美化博客"></a>四、美化博客</h1><p>请参考我的这篇文章：<a href="https://blog.csdn.net/weixin_44861399/article/details/104646946">https://blog.csdn.net/weixin_44861399/article/details/104646946</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于这次的疫情，最爱的马云爸爸的阿里云推出了学生在家上机实践的活动，免费领六个月的ECS云服务器，天呐，2核4G啊，六个月之后还可续费六个月，整整一年呐，市场价780软妹币呢，不过投放量少，而且还是每天早上八点领，连续7:55闹钟起早，终于，在第三个早上，马云爸爸眷顾了我，我领到了。领到了就不能让他吃灰吧，于是先部署个博客再说。因为之前博客是托管在github上面的。而github的服务器又在国外，所以访问速度十分感人，但是有了国内的服务器就不一样了，瞬间嗖嗖嗖。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---死锁</title>
    <link href="http://daqwt.top/1179211128/"/>
    <id>http://daqwt.top/1179211128/</id>
    <published>2020-03-18T14:41:37.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br><strong>简单理解就是：</strong> 我想要你手里的东西，同时你也想要我手里的资源，我俩同时都不让出来，谁也拿不到。</p><a id="more"></a><h2 id="为什么会产生死锁？"><a href="#为什么会产生死锁？" class="headerlink" title="为什么会产生死锁？"></a>为什么会产生死锁？</h2><ul><li><strong>系统资源的竞争：</strong> 当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。</li><li><strong>进程运行推进顺序不当引起死锁：</strong> 　　若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。</li></ul><h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ol><li><p><strong>互斥条件：</strong> 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p><strong>请求与保持条件：</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p><strong>不可剥夺条件：</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p></li><li><p><strong>循环等待条件：</strong> 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></li></ol><ul><li>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</li></ul><h2 id="解决策略："><a href="#解决策略：" class="headerlink" title="解决策略："></a>解决策略：</h2><h3 id="死锁的避免与预防"><a href="#死锁的避免与预防" class="headerlink" title="死锁的避免与预防"></a>死锁的避免与预防</h3><p>死锁避免的基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁,则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。只要打破四个必要条件之一就能有效预防死锁的发生：</p><ol><li><p>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</p></li><li><p>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</p></li><li><p>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p></li><li><p>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</p></li><li><p>死锁预防和避免的区别</p></li></ol><ul><li>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。</li><li>死锁避免则不那么严格的限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</li></ul><h3 id="死锁的检测和恢复"><a href="#死锁的检测和恢复" class="headerlink" title="死锁的检测和恢复"></a>死锁的检测和恢复</h3><ul><li>并没有实际卵用</li></ul><h3 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h3><ul><li><strong>核心思想：</strong> 装作没看见</li><li><strong>为什么会用鸵鸟算法？</strong><br>上面的一些做法，组织啊，恢复啊，无一例外会给系统带来很多沉重的负担。一方面给系统添加，另一方面解决的问题发生的概率不大，吃力还不讨好。而且，死锁发生的原因是由于程序设计人员写出来的问题，操作系统当然不会予以理会。所以死锁的问题都是交给程序设计人员来解决。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。&lt;br&gt;&lt;strong&gt;简单理解就是：&lt;/strong&gt; 我想要你手里的东西，同时你也想要我手里的资源，我俩同时都不让出来，谁也拿不到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---网站安全配置</title>
    <link href="http://daqwt.top/hexo/"/>
    <id>http://daqwt.top/hexo/</id>
    <published>2020-03-18T12:28:01.000Z</published>
    <updated>2020-05-06T12:41:06.474Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建站并没有那么容易，搭建起来之后，还要考虑各种问题，例如网站安全，加载速度，资源压缩，用户体验之类的，虽然只是一个静态网站，但是能够做好一点也是挺不错的。</p><a id="more"></a><h2 id="一、添加备案号"><a href="#一、添加备案号" class="headerlink" title="一、添加备案号"></a>一、添加备案号</h2><ul><li>我是在阿里云APP上备案成功的，等的时间也不长，六天左右，最后短信收到了工信局发来的备案号，需要把这个备案号添加在网站底部，并且指向工信局官网。</li><li>找到<code>F:\blog\themes\next\layout\_partials</code>下的<code>footer.swig</code>文件，添加如下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.beian.miit.gov.cn/"</span>&gt;备案号&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200321110819179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二、安装SSL证书"><a href="#二、安装SSL证书" class="headerlink" title="二、安装SSL证书"></a>二、安装SSL证书</h2><p>① <strong>购买证书：</strong> 阿里云提供的免费证书服务，购买页面：<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.2.15a156a7lzZrki&commodityCode=cas#/buy">阿里云ssl证书购买</a>选择免费的。足够个人博客用了。购买好了之后，按步骤申请验证</p><p><img src="https://img-blog.csdnimg.cn/20200321184319504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>②  <strong>下载证书：</strong> 进入阿里云证书控制台，选择下载证书<code>for nginx</code> ，下载好之后可以看到有两个文件夹，分别是：<code>.key</code>和<code>.pem</code>文件。</p><p><img src="https://img-blog.csdnimg.cn/20200321184329138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>③<strong>安装证书：</strong></p><ul><li><p>服务器放置证书：创建目录:  <code>/etc/nginx/cert</code>,用于存放证书文件。我用的软件是<code>finalshell</code>。<br><img src="https://img-blog.csdnimg.cn/20200321185907359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>修改<code>nginx</code>配置，在<code>/etc/nginx/nginx.conf</code>在里面添加443端口，443端口用于https协议。不建议直接修改<code>nginx.conf</code>,可以在<code>nginx</code>目录下新建一个文件夹<code>vhost</code>，里面用来编写新加的修改，在<code>vhost</code>中新建<code>SSL.conf</code>写入以下内容：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name staunchkai.com;     <span class="comment"># 填写绑定证书的域名</span></span><br><span class="line">    ssl_certificate /home/SSL/1_bundle.crt;<span class="comment">#这里填写你.pem文件的路径。</span></span><br><span class="line">    ssl_certificate_key /home/SSL/2_key.key;<span class="comment">#这里填写.key文件的路径。</span></span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    <span class="comment"># 按照这个协议配置</span></span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;     <span class="comment"># 按照这个套件配置</span></span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /home/www/blog;    <span class="comment"># 站点目录</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后用一句代码将<code>SSL.conf</code>链入到<code>nginx.conf</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /etc/nginx/vhost/*.conf;</span><br></pre></td></tr></table></figure><p>这里的vhost是我自己创建的用来存放修改的参数，这句话的意思就是，将vhost中所有的配置文件加入进来。所以我的修改，一般都是在这个文件里面添加之后再链入。</p><p><img src="https://img-blog.csdnimg.cn/20200321193156899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如果用户使用<code>http协议</code>访问网站，要进行301跳转，以https协议访问，所以要修改原有端口80的监听位置。我是采用链入的方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200321194946704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">return</span> 301 https://daqwt.top<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><ul><li>配置完成后，使用 <code>nginx -t</code> 命令检测是否有误，正确无误后，使用 <code>systemctl restart nginx.service</code> 重启 Nignx。再使用带 https 的域名进行访问即可。</li></ul><h2 id="三、站点地图"><a href="#三、站点地图" class="headerlink" title="三、站点地图"></a>三、站点地图</h2><ul><li>站点地图是一种文件，可以通过该文件列出您网站上的网页，从而将网站组织内容，高速其他浏览器。以便更加智能的抓取您的网站。</li><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-generator-sitemap --save</span><br><span class="line">cnpm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><ul><li>在站点配置文件中添加以下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自动生成sitemap</span></span><br><span class="line">sitemap: </span><br><span class="line">    path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure><ul><li>编译博客</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>如果在<code>public</code>文件夹下发现了<code>sitemap.xml</code>就代表成功了。</li></ul><h2 id="四、谷歌收录"><a href="#四、谷歌收录" class="headerlink" title="四、谷歌收录"></a>四、谷歌收录</h2><ul><li>注册<a href="https://search.google.com/search-console">google站长工具</a></li><li>验证通过后，点击抓取–&gt;站点地图–&gt;添加新的站点题图–&gt;填入<code>https://daqwt.top/sitemap.xml</code>,很快谷歌就会收录。</li></ul><h2 id="五、百度收录"><a href="#五、百度收录" class="headerlink" title="五、百度收录"></a>五、百度收录</h2><ul><li>注册<a href="https://ziyuan.baidu.com/">百度站长统计</a></li><li>登录之后，找到用户中心，添加站点，按照提示完成验证，推荐使用<code>CNAME</code>验证。</li><li>完成之后进入站点管理，找到网页抓取的<code>链接提交图</code>，点击详情</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;建站并没有那么容易，搭建起来之后，还要考虑各种问题，例如网站安全，加载速度，资源压缩，用户体验之类的，虽然只是一个静态网站，但是能够做好一点也是挺不错的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>操作系统---CPU调度</title>
    <link href="http://daqwt.top/789539749/"/>
    <id>http://daqwt.top/789539749/</id>
    <published>2020-03-17T14:30:59.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机的三大核心部件：CPU，存储器，I/O设备，其中CPU作为操作系统的运算和控制核心，是信息处理、程序运行的最终执行单元，起到了大脑的作用。CPU又包括两部分：控制器、运算器。众所周知，在某一个时间段，CPU只能被一个进程占用，这篇文章就认识一下CPU的调度策略。</p><a id="more"></a><h2 id="小概念"><a href="#小概念" class="headerlink" title="小概念"></a>小概念</h2><ul><li>我们所做的多进程，多线程，多道程序设计，批处理等等一些操作的目的就是为了最大化cpu的利用率。</li><li>用一会cpu，等待一会IO，循环往复，交替执行（通过IO获得数据，再通过CPU对数据进行处理，在通过IO将结果输出）</li><li>通过考虑CPU和IO的占用，我们还可以将进程划分为两大类：<br>①：CPU绑定进程（对CPU使用的比较多，很少量的时间使用IO）<br>②：IO绑定进程（与之相反）</li><li>调度：队列里面有好多个进程，选择哪一个去运行，决定下一个是谁。<br>①抢占式：（被动的）<br>②非抢占式：（自愿让出CPU）</li><li>CPU的利用率：占了百分之多少，越多越好。</li><li>吞吐率：单位时间内完成了多少进程。越多，效率越高。</li><li>周转时间：一个进程从创建到结束，一共用了多少时间。</li><li>等待时间：一个进程在等待状态多长时间，这个时间越短越好。</li><li>响应时间：正在等待的进程，对已经发生的事件，的响应速度，越快越好。</li></ul><h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><ul><li>但是看得不是单个进程的性能指标，看得是所有进程加在一起，算出来的平均周转时间，平均等待时间，平均响应时间。才能看出调度能力。</li><li><strong>最短作业优先（SJF）</strong> ：谁运行时间最短谁来使用CPU。</li><li><strong>最短剩余时间优先：</strong> 不看他以前运行了多久，只看他剩下多少时间。</li><li>上面这两种调度策略是在已知需要在CPU上运行多少时间的情况，但是这个运行时间未知呢？调度最有效的依据是进程将来在CPU上消耗的时间，并期望用时最短的进程最优先执行。</li><li><strong>预测未来：</strong> 基于统计过去这个进程对CPU的使用情况来 预测。根据统计IO的时间多，还是使用CPU的时间多。</li><li><strong>先来先服务（FCFS）</strong> ：谁优先级高运行谁。会导致优先级低的进程饿死。</li><li><strong>时间片轮转算法（Round Robin）</strong> ：广泛采用，给定每个进程一个时间片，用完了就去等待。这个时候就要考虑时间片的设置大小。越合理越好。如果时间片太大，那么他就近似成了一个先来先服务算法。</li><li>将时间片轮转和优先级结合起来：时间片轮转就在就绪队列里选择优先级高的进程先运行。</li><li><strong>多级队列（Multilevel  Queue）</strong> ：把整个系统所有的进程放在好多个队列中，这个队列里面的进程优先级是一样的，调度的时候，就按着这个队列找。<br>①系统级队列（最高优先级）：系统进程要应对很关键的问题，它负责系统的中断处理的。（中断指令一定要及时响应，否则下一个中断进来了，就会丢失一个中断）<br>② 交互式的进程：属于IO绑定的进程，很少使用CPU，随时给用户一个反馈。响应速度必须得快。<br>③批处理进程：频繁使用CPU的进程。</li><li><strong>多级反馈队列（普遍采用）：</strong> 根据这个进程以前的行为的统计来预测以后怎么处置他，这个预测就是由反馈实现的。<br>①反馈怎么实现？：新来的进程首先设置他的优先级为最高，来根据他的行为，表现，来确定他的优先级，降级。<br>②只要长时间使用了CPU，就把你优先级降低，只要你做过一次IO操作，就把你优先级提一级，形成一个<strong>动态的变换</strong>。</li></ul><h2 id="多CPU调度"><a href="#多CPU调度" class="headerlink" title="多CPU调度"></a>多CPU调度</h2><ul><li>多核，重核。每一个内核在任意时刻只能运行一个进程。未来可能会出现128核，实际上，会有备用的核，因为出厂的时候，也许会有坏核，备用核就顶上。</li><li>特别之处：调度问题的复杂度增加了，如何去做负载均衡（比如说一个CPU太忙，一个CPU太闲,那这样多核就没有意义了）。</li><li>同构（CPU完全一样的）<br>①非对称式的多处理器管理（现阶段用不到）：（每个内核的作用是不同的）让一个内核只运行操作系统，其他的内核只运行应用程序。好处：对操作系统简单多了，只用管理自己的内核。<br>②对称式的多处理器管理：所有的处理机都是完全平等的，每个内核既运行操作系统，也运行应用程序，完全由繁忙程度来决定。每一个处理器都有私有的队列。</li><li>异构（CPU有不同之处，特别复杂，基本上用不到）</li><li>负载均衡：通过迁移进程来实现，会产生cache刷新，但是利大于弊。</li></ul><h2 id="操作系统是如何实现多级反馈的"><a href="#操作系统是如何实现多级反馈的" class="headerlink" title="操作系统是如何实现多级反馈的"></a>操作系统是如何实现多级反馈的</h2><ul><li>太难了，不想了解！！！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算机的三大核心部件：CPU，存储器，I/O设备，其中CPU作为操作系统的运算和控制核心，是信息处理、程序运行的最终执行单元，起到了大脑的作用。CPU又包括两部分：控制器、运算器。众所周知，在某一个时间段，CPU只能被一个进程占用，这篇文章就认识一下CPU的调度策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---更换icarus主题</title>
    <link href="http://daqwt.top/hexo/"/>
    <id>http://daqwt.top/hexo/</id>
    <published>2020-03-17T12:08:40.000Z</published>
    <updated>2020-05-06T12:22:22.630Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看惯了next的主题，出现了审美疲劳，在逛知乎的时候，发现了一款很不错的主题<code>icarus</code>，就试着更换了主题，发现还真挺漂亮的，于是就在做一个主题吧，哪天审美又疲劳了，再换回来呗。</p><a id="more"></a><h2 id="页面点击出现爱心"><a href="#页面点击出现爱心" class="headerlink" title="页面点击出现爱心"></a>页面点击出现爱心</h2><ul><li>在<code>F:\blog\themes\icarus\source\js</code>下，新建<code>clicklove.js</code>，写入以下代码。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),</span><br><span class="line">        o(),</span><br><span class="line">        r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)</span><br><span class="line">            d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;</span><br><span class="line">        e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            t&amp;&amp;t(),i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);</span><br><span class="line">            a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(t)&#123;</span><br><span class="line">            a.styleSheet.cssText=e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d=[];</span><br><span class="line">    e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(),</span><br><span class="line">    n()</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><ul><li>修改<code>layout.ejs</code>，找到<code>F:\blog\themes\icarus\layout\layout.ejs</code>,添加：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js/clicklove.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="给文章添加目录"><a href="#给文章添加目录" class="headerlink" title="给文章添加目录"></a>给文章添加目录</h2><ul><li>在主题配置文件中，添加如下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">-</span><br><span class="line">    <span class="built_in">type</span>: toc</span><br><span class="line">    position: left</span><br></pre></td></tr></table></figure><ul><li>在每次写文章的时候都要添加<code>toc： true</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">toc： <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h2><ul><li>在<code>_config.yml</code>中开启画廊功能：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugines:</span><br><span class="line">gallery: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="模块布局"><a href="#模块布局" class="headerlink" title="模块布局"></a>模块布局</h2><ul><li>初始的页面有很多模块，例如归档，标签云，最近文章，乱七八糟的，可以选择饿在左侧栏还是右侧栏显示这些模块，当然也可以隐藏这些模块。要在主题的配置文件修改。找到<code>widget</code>字样，例如下面有，分别有：左（<code>lift</code>），右（<code>right</code>），隐藏（<code>false</code>）。左右栏固定，不随着滑轮滑动。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">    <span class="comment"># left sidebar settings</span></span><br><span class="line">    left:</span><br><span class="line">        <span class="comment"># Whether the left sidebar is sticky when page scrolls</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        sticky: <span class="literal">true</span></span><br><span class="line">    <span class="comment"># right sidebar settings</span></span><br><span class="line">    right:</span><br><span class="line">        <span class="comment"># Whether the right sidebar is sticky when page scrolls</span></span><br><span class="line">        <span class="comment"># https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        sticky: <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"> <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: category</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: left</span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: tagcloud</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: recent_posts</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: archive</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: <span class="literal">false</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="built_in">type</span>: tag</span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        position: lift</span><br></pre></td></tr></table></figure><h2 id="开启评论系统"><a href="#开启评论系统" class="headerlink" title="开启评论系统"></a>开启评论系统</h2><ul><li>在<a href="https://leancloud.cn/">leancloud官网</a>注册账号，详情请看：<a href="https://valine.js.org/quickstart.html">参考书</a></li><li>在主题配置文件中找到<code>comment</code>字样，添加如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment:</span><br><span class="line">    <span class="built_in">type</span>: valine</span><br><span class="line">    app_id: 你的id</span><br><span class="line">    app_key: 你的key</span><br><span class="line">    notify: <span class="literal">false</span></span><br><span class="line">    verify: <span class="literal">false</span></span><br><span class="line">    placeholder:</span><br></pre></td></tr></table></figure><h2 id="valine域名绑定"><a href="#valine域名绑定" class="headerlink" title="valine域名绑定"></a>valine域名绑定</h2><ul><li>因为要使用到valine的数据库存储功能，就得在leancloud备案域名。</li><li>先给域名创建一个二级域名</li></ul><h2 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">donate:</span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="built_in">type</span>: alipay</span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        qrcode: <span class="string">'/images/alipay.jpg'</span></span><br><span class="line">    -</span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="built_in">type</span>: wechat</span><br><span class="line">        <span class="comment"># Qrcode image URL</span></span><br><span class="line">        qrcode: <span class="string">'/images/wechatpay.jpg'</span></span><br><span class="line">    <span class="comment">#-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment">#type: paypal</span></span><br><span class="line">        <span class="comment"># Paypal business ID or email address</span></span><br><span class="line">        <span class="comment">#business: ''</span></span><br><span class="line">        <span class="comment"># Currency code</span></span><br><span class="line">        <span class="comment">#currency_code: USD</span></span><br><span class="line">    <span class="comment">#-</span></span><br><span class="line">        <span class="comment"># Donation entry name</span></span><br><span class="line">        <span class="comment">#type: patreon</span></span><br><span class="line">        <span class="comment"># URL to the Patreon page</span></span><br><span class="line">        <span class="comment">#url: ''</span></span><br></pre></td></tr></table></figure><h2 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h2><ul><li>找到<code>search</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search</span><br><span class="line"><span class="built_in">type</span>： insight</span><br></pre></td></tr></table></figure><h2 id="首页三栏，阅读两栏"><a href="#首页三栏，阅读两栏" class="headerlink" title="首页三栏，阅读两栏"></a>首页三栏，阅读两栏</h2><ul><li>找到<code>F:\blog\themes\icarus\includes\helpers\layout.js</code>，第24行开始修改如下：+代表增加，-代表删除</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">const</span> widgets = hexo.extend.helper.get(<span class="string">'get_config'</span>).bind(<span class="keyword">this</span>)(<span class="string">'widgets'</span>);</span><br><span class="line">-    <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; widget.position === position);</span><br><span class="line">+    <span class="keyword">if</span> (<span class="keyword">this</span>.page.layout !== <span class="string">'post'</span>) &#123;</span><br><span class="line">+        <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; widget.position === position);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span> (position === <span class="string">'left'</span>) &#123;</span><br><span class="line">+        <span class="keyword">return</span> widgets.filter(<span class="function"><span class="params">widget</span> =&gt;</span> widget.hasOwnProperty(<span class="string">'position'</span>) &amp;&amp; (widget.type === <span class="string">'toc'</span> || widget.type === <span class="string">'profile'</span>));</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+        <span class="keyword">return</span> []</span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure><ul><li>找到<code>layout/common/widget.ejs</code>修改第五行如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;% <span class="function"><span class="keyword">function</span> <span class="title">side_column_class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (column_count()) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">-            <span class="keyword">return</span> <span class="string">'is-4-tablet is-4-desktop is-4-widescreen'</span>;</span><br><span class="line">+            <span class="keyword">return</span> <span class="string">'is-4-tablet is-4-desktop is-3-widescreen'</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br></pre></td></tr></table></figure><ul><li>找到<code>layout/layout.ejs</code>修改如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"is-&lt;%= column_count() %&gt;-column"</span>&gt;</span></span></span><br><span class="line">+&lt;body class="is-3-column"&gt;</span><br><span class="line">     &lt;%- partial('common/navbar', &#123; page &#125;) %&gt;</span><br><span class="line">     &lt;% function main_column_class() &#123;</span><br><span class="line">         switch (column_count()) &#123;</span><br><span class="line">             case 1:</span><br><span class="line">                 return 'is-12';</span><br><span class="line">             case 2:</span><br><span class="line">-                return 'is-8-tablet is-8-desktop is-8-widescreen';</span><br><span class="line">+                return 'is-8-tablet is-8-desktop is-9-widescreen';</span><br></pre></td></tr></table></figure><ul><li>找到<code>source/css/style/styl</code>,在不同屏幕下的大小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     .is<span class="number">-2</span>-column .container</span><br><span class="line">         max-width: screen-desktop - <span class="number">2</span> * gap</span><br><span class="line">         width: screen-desktop - <span class="number">2</span> * gap</span><br><span class="line">+    .is<span class="number">-3</span>-column .container</span><br><span class="line">+        max-width: screen-widescreen - gap</span><br><span class="line">+        width: screen-widescreen - gap</span><br><span class="line"> @media screen and (min-width: screen-fullhd)</span><br><span class="line">+    .is<span class="number">-3</span>-column .container</span><br><span class="line">+        max-width: screen-fullhd - <span class="number">2</span> * gap</span><br><span class="line">+        width: screen-fullhd - <span class="number">2</span> * gap</span><br><span class="line">     .is<span class="number">-2</span>-column .container</span><br><span class="line">         max-width: screen-widescreen - <span class="number">2</span> * gap</span><br><span class="line">         width: screen-widescreen - <span class="number">2</span> * gap</span><br></pre></td></tr></table></figure><h2 id="目录固定"><a href="#目录固定" class="headerlink" title="目录固定"></a>目录固定</h2><ul><li>找到<code>layout/widget/toc.ejs</code>，增加<code>column-left is-sticky</code>类，在第28行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card widget"</span> <span class="attr">id</span>=<span class="string">"toc"</span>&gt;</span></span></span><br><span class="line">+&lt;div class="card widget column-left is-sticky" id="toc"&gt;</span><br></pre></td></tr></table></figure><h2 id="默认开启目录"><a href="#默认开启目录" class="headerlink" title="默认开启目录"></a>默认开启目录</h2><ul><li>找到<code>includes/helpers/config.js</code>，修改第33行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> property = readProperty(specs, configName);</span><br><span class="line">-       <span class="keyword">return</span> property === <span class="literal">null</span> ? <span class="literal">null</span> : property[descriptors.defaultValue];</span><br><span class="line">+       <span class="keyword">const</span> result = property === <span class="literal">null</span> ? <span class="literal">null</span> : property[descriptors.defaultValue];</span><br><span class="line">+       <span class="keyword">return</span> (configName === <span class="string">'toc'</span> &amp;&amp; <span class="keyword">this</span>.page.layout === <span class="string">'post'</span> &amp;&amp; result === <span class="literal">null</span>) ? <span class="literal">true</span> : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="个人信息布局"><a href="#个人信息布局" class="headerlink" title="个人信息布局"></a>个人信息布局</h2><ul><li>找到<code>layout/widget/profile.ejs</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-    <span class="xml"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"level is-mobile"</span>&gt;</span></span></span><br><span class="line">+    &lt;nav class="level menu-list is-mobile" style="margin-bottom:1rem"&gt;</span><br><span class="line">         &lt;div class="level-item has-text-centered is-marginless"&gt;</span><br><span class="line">-            &lt;div&gt;</span><br><span class="line">+            &lt;a href="&lt;%- url_for('/archives/') %&gt;"&gt;</span><br><span class="line">                 &lt;p class="heading"&gt;</span><br></pre></td></tr></table></figure><h2 id="移动端优化"><a href="#移动端优化" class="headerlink" title="移动端优化"></a>移动端优化</h2><ul><li>在移动端，隐藏<code>archive</code> 和 <code>tagcloud</code>。</li><li>找到<code>layout/widget/archive.ejs</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card widget"</span>&gt;</span></span></span><br><span class="line">+&lt;div class="card widget is-hidden-mobile"&gt;</span><br></pre></td></tr></table></figure><ul><li>找到<code>layout/widget/recent_posts.ejs</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card widget is-hidden-mobile"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"card-content"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="增加版权说明"><a href="#增加版权说明" class="headerlink" title="增加版权说明"></a>增加版权说明</h2><ul><li>找到<code>layout/common/article.ejs</code>，在第50行修改如下：</li></ul><p>2020/5/6 20:21:35 2020/5/6 20:21:36 2020/5/6 20:21:38 2020/5/6 20:21:39 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">         &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">+    &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) &#123; %&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;ul class="post-copyright"&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文标题：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文作者：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= theme.url %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">theme.author</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;本文链接：&lt;/</span>strong&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.permalink</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;发布时间：&lt;/</span>strong&gt;&lt;%= post.date.format(<span class="string">"YYYY-MM-DD"</span>) %&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;li&gt;&lt;strong&gt;版权声明：&lt;/</span>strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=<span class="string">"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"</span> rel=<span class="string">"external nofollow"</span> target=<span class="string">"_blank"</span>&gt;CC BY-NC-SA <span class="number">4.0</span>&lt;<span class="regexp">/a&gt; 许可协议。转载请注明出处！</span></span><br><span class="line"><span class="regexp">+        &lt;/</span>li&gt;</span><br><span class="line">+        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">+    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">     &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) &#123; %&gt;</span></span><br></pre></td></tr></table></figure><ul><li>版权说明的样式：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+.post-copyright</span><br><span class="line">+    font-size: <span class="number">1</span>rem</span><br><span class="line">+    letter-spacing: <span class="number">0.02</span>rem</span><br><span class="line">+    word-<span class="keyword">break</span>: <span class="keyword">break</span>-all</span><br><span class="line">+    margin: <span class="number">2.5</span>rem <span class="number">0</span> <span class="number">0</span></span><br><span class="line">+    padding: <span class="number">1</span>rem <span class="number">1</span>rem</span><br><span class="line">+    border-left: 3px solid #FF1700</span><br><span class="line">+    background-color: #F9F9F9</span><br></pre></td></tr></table></figure><h2 id="增加busuanzi统计"><a href="#增加busuanzi统计" class="headerlink" title="增加busuanzi统计"></a>增加busuanzi统计</h2><ul><li>在<code>_config.yml</code>中，找到<code>busuanzi</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busuanzi: <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>打开<code>layout/common/footer.ejs</code>文件，找到<code>&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</code>，在下方添加：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;% <span class="keyword">if</span> (busuanzi) &#123; %&gt;</span><br><span class="line">   &lt;br&gt;</span><br><span class="line">-  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">-  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">_p</span>('<span class="attr">plugin.visitor</span>', '&lt;<span class="attr">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>') %&gt;</span></span><br><span class="line"><span class="xml">-  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">+  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span>来访<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>0人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">+  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>总访问<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>0次<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">   &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h2 id="使用阿里巴巴图标库"><a href="#使用阿里巴巴图标库" class="headerlink" title="使用阿里巴巴图标库"></a>使用阿里巴巴图标库</h2><ul><li>由于icarus默认使用的图标库是 <code>font Awesome</code>，里面的图标只有600多个，而且都是黑白的，并且有的时候还加载不出来（墙的原因），所以我换做用<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">阿里巴巴矢量图标库</a>。</li><li>首先登陆，将喜欢的图标添加到购物车，记得要一次添加完，提前看好你需要哪些图标，然后在右上角购物车里找到最下房<code>下载代码</code>，下载到本地。</li><li>在本地打开下载好的文件夹，找到<code>iconfont.css</code>，添加到<code>F:\blog\themes\icarus\source\css</code>。</li><li>找到<code>F:\blog\themes\icarus\layout\widget\profile.ejs</code>,添加一行代码，引入<code>iconfont.css</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> socialLinks) &#123;</span><br><span class="line">     <span class="keyword">let</span> link = socialLinks[name]; %&gt;</span><br><span class="line">+    <span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/iconfont.css"</span>&gt;</span></span></span><br><span class="line">     &lt;a class="level-item button is-white is-marginless" target="_blank" title="&lt;%= name %&gt;" href="&lt;%= url_for(typeof(link) === 'string' ? link : link.url) %&gt;"&gt;</span><br><span class="line">     &lt;% if (typeof(link) === 'string') &#123; %&gt;</span><br><span class="line">     &lt;%= name %&gt;</span><br><span class="line">     &lt;% &#125; else &#123; %&gt;</span><br><span class="line">     &lt;i class="&lt;%= link.icon %&gt;"&gt;&lt;/i&gt;</span><br><span class="line">     &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ul><li>修改主题配置文件，这次主要改图标名字，图标名字也可以打开<code>iconfont.css</code>查看。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">  Github:</span><br><span class="line">      icon: iconfont icon-git</span><br><span class="line">      url: <span class="string">'https://github.com/DAQ121'</span></span><br></pre></td></tr></table></figure><ul><li>像有些内嵌的图标，比如说目录啊，标签啊这些。就要找到对应的<code>.js</code>文件，添加代码。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020032720501748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">- 如果使用的是<code>font awesome图标库的话</code>，就添加<code>&lt;i class=&quot;fas fa-guidang&quot;&gt;&lt;/i&gt;</code>,如果使用的是<code>阿里云图标库</code>的话，就添加<code>&lt;i class=&quot;iconfont icon-guidang&quot;&gt;&lt;/i&gt;</code>，注意，要添加在<code>&lt;h3&gt;&lt;/h3&gt;</code>内部。</p><p><img src="https://img-blog.csdnimg.cn/20200327205203894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="按钮背景颜色"><a href="#按钮背景颜色" class="headerlink" title="按钮背景颜色"></a>按钮背景颜色</h2><ul><li>找到<code>style.styl</code>，添加两行代码。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.menu-list</span> <span class="selector-tag">li</span> ul</span><br><span class="line">        <span class="attribute">margin-right</span>: <span class="number">0</span></span><br><span class="line">+    <span class="selector-class">.menu-list</span> a</span><br><span class="line">+       <span class="attribute">transition</span>: background-color <span class="number">0.3s</span> ease-in-out</span><br><span class="line">    <span class="selector-class">.menu-list</span> <span class="selector-tag">a</span>.level</span><br><span class="line">        <span class="attribute">display</span>: flex</span><br><span class="line">    <span class="selector-class">.has-text-centered</span> <span class="selector-tag">figure</span>.image</span><br><span class="line">        <span class="attribute">margin</span>: auto</span><br></pre></td></tr></table></figure><h2 id="网站运行时间"><a href="#网站运行时间" class="headerlink" title="网站运行时间"></a>网站运行时间</h2><ul><li>找到<code>/themes/icarus/layout/common/footer.ejs</code>，在合适位置添加以下代码</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> Date(); </span><br><span class="line">  <span class="function">function <span class="title">createtime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> grt= <span class="keyword">new</span> Date(<span class="string">"12/28/2018 12:49:00"</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间 </span></span><br><span class="line">  now.setTime(now.getTime()+<span class="number">250</span>); </span><br><span class="line">  days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = Math.floor(days); </span><br><span class="line">  hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = Math.floor(hours); </span><br><span class="line">  <span class="keyword">if</span>(String(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span><br><span class="line">  mnum = Math.floor(minutes); <span class="keyword">if</span>(String(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span><br><span class="line">  seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum); </span><br><span class="line">  snum = Math.round(seconds); <span class="keyword">if</span>(String(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span><br><span class="line">   document.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"本站已安全运行 "</span>+dnum+<span class="string">" 天 "</span>; </span><br><span class="line">  document.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span><br><span class="line">                &#125; </span><br><span class="line">   setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a>添加RSS订阅</h2><ul><li>安装feed插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><ul><li>打开站点配置文件,添加如下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line">plugin:</span><br><span class="line">    - hexo-generator-feed</span><br><span class="line">    <span class="comment">#Feed.Atom</span></span><br><span class="line">    feed:</span><br><span class="line">    <span class="built_in">type</span>: atom</span><br><span class="line">    path: rss.xml</span><br><span class="line">    <span class="built_in">limit</span>: 0</span><br><span class="line">    hub:</span><br><span class="line">  content: <span class="string">'true'</span></span><br><span class="line"> order_by: -date</span><br></pre></td></tr></table></figure><ul><li>打开主题配置文件,找到<code>rss</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSS:</span><br><span class="line">    icon: fas fa-rss</span><br><span class="line">    url: /rss.xml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看惯了next的主题，出现了审美疲劳，在逛知乎的时候，发现了一款很不错的主题&lt;code&gt;icarus&lt;/code&gt;，就试着更换了主题，发现还真挺漂亮的，于是就在做一个主题吧，哪天审美又疲劳了，再换回来呗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的结构与功能</title>
    <link href="http://daqwt.top/3546768407/"/>
    <id>http://daqwt.top/3546768407/</id>
    <published>2020-03-16T14:17:18.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对操作系统的种类和发展历史有了一个基本了解之后，就正式开始学习操作系统了，首先要明白操作系统是做什么的，它的结构是什么样的，我粗略总结出以下知识点。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在此推荐一个B站视频，是哈工大的一位叫孙志岗的老师，讲课很幽默，而且干货很多，他的视频是平时上课时候得一些录播，虽然播放量不是很理想，但我个人觉得，比那些照着PPT念，播放量动辄几十万的老师强太多。课程链接：<a href="https://www.bilibili.com/video/av13169670?from=search&seid=5921511433085032320">点我直达！</a></p><h1 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h1><h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><ul><li>系统调用：可以理解为在操作系统内核当中的一个函数，这个函数对应用程序来说，是不可以被直接访问的。应用程序可以访问的是<code>API</code>接口，API有办法进系统内核中去执行相应的程序</li><li><code>windows</code>操作系统提供出<code>API</code>应用编程接口，但是<code>linux</code>不一样，<code>linux</code>不需要通过这个接口来调用。</li><li>目前世界上有三套<code>API</code>接口，<code>WIN32 API，POSIX API</code>（被<code>unix</code>广泛应用，很多应用程序是针对他编写的，就要提供相应的接口，以及参数），<code>JAVA API(JVM)</code>。</li><li>系统中就像是有一条分割线，上面是用户模式（运行的都是应用程序），下面是内核模式（操作系统的内核）。分割起到保护作用，用户态里的应用程序，不可能随便访问内核里的资源。交互就要用到系统调用了。</li><li>例如C语言里面的<code>printf（）</code>，它就是调用了系统程序<code>write（）</code>，</li><li>应用程序不可以访问内核，但是系统可以访问应用程序的内核。只不过要多一些步骤。</li><li>系统程序通常和系统中的功能比较近，帮助我们完成系统里的重要职能。</li><li>比较常用的系统程序：复制拷贝文件（属于资源管理器就是系统程序）</li><li>一般很少用到的系统程序（磁盘分区，系统快照，磁盘碎片整理）</li></ul><h2 id="操作系统的设计之道"><a href="#操作系统的设计之道" class="headerlink" title="操作系统的设计之道"></a>操作系统的设计之道</h2><ul><li>软件的<strong>体系结构</strong>是根据操作系统来的，操作系统就是早期最大的软件。</li><li>而操作系统的体系结构是从<strong>建筑学</strong>中学来的</li></ul><h2 id="操作系统的结构-1"><a href="#操作系统的结构-1" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><ul><li>由于用户应用程序可以直接调用系统程序，所以 <code>DOS</code>系统结构很惧怕病毒。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318224419770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>做到了对内核的保护，应用层和系统层分离，但是在内核中是没有结构的，就造成了内核中错综复杂混乱的局面，牵一发而动全身，有一点出问题，内核全完蛋。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318224549638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>层次结构：上层调用下层的功能，下层向上层返回数据，不允许跨层访问。这种理念也映射到信息封装，隐藏，方方面面都有。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020031822495696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>微内核，相比以前的大内核，有了很多好处，把更多的功能分给了用户空间（磁盘，网络管理都放到了用户空间）。这样的微内核带来了系统的稳定和安全，但是做什么都要经过内核，这样就导致效率低下。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020031823005218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>Solaris Modular</code>系统，无可比拟，强大，比<code>uniux，</code>  <code>linux</code>强很多。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318231401137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>Macos</code>，混合系统，两个内核<code>BSD</code>（聚内核）+<code>Mach</code>（微内核）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318231729175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>虚拟机结构（在操作系统之上装一个虚拟机，虚拟机中又可以再装不同的操作系统。）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318232414868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>未来的虚拟机结构（在硬件之上直接装一个虚拟机，在虚拟机中装不同的内核），集群系统，大型机房常用。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200318232434438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h2><ul><li>最初设计<code>unix</code>的时候，是用汇编语言写的，但是太费劲了，于是找人开发出了C语言，所以<code>uniux</code>和<code>c语言</code>就像鸡和蛋的关系，不知道谁先有，而最初设计<code>uniux</code>就是为了玩游戏。所以说<code>C语言</code>非常适合用来编写操作系统。</li><li>跟硬件实打实的打交道的程序，只能用汇编语言来编写，其他语言更别说了，C语言也不行。</li></ul><h1 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h1><h2 id="一、进程管理（cpu管理）"><a href="#一、进程管理（cpu管理）" class="headerlink" title="一、进程管理（cpu管理）"></a>一、进程管理（cpu管理）</h2><ul><li>进程控制：（创建，暂停，唤醒，撤销）</li><li>进程调度：调度策略，优先级</li><li>进程撤销：进程间通信</li></ul><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><ul><li>内存分配</li><li>内存共享</li><li>内存保护</li><li>虚拟内存管理</li></ul><h2 id="三、设备管理"><a href="#三、设备管理" class="headerlink" title="三、设备管理"></a>三、设备管理</h2><ul><li>设备的分配和调度</li><li>设备的无关性</li><li>设备传输控制</li><li>设备驱动</li></ul><h2 id="四、文件管理"><a href="#四、文件管理" class="headerlink" title="四、文件管理"></a>四、文件管理</h2><ul><li>存储空间管理</li><li>文件的操作</li><li>目录的操作</li><li>文件和目录存取权限的管理</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>提供接口供用户使用</li><li>分配和管理资源</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对操作系统的种类和发展历史有了一个基本了解之后，就正式开始学习操作系统了，首先要明白操作系统是做什么的，它的结构是什么样的，我粗略总结出以下知识点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---美化网站</title>
    <link href="http://daqwt.top/551144596/"/>
    <id>http://daqwt.top/551144596/</id>
    <published>2020-03-16T09:05:16.000Z</published>
    <updated>2020-04-17T03:13:59.025Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明：</strong> 展现在你眼前的，只是部分功能，很基础的，根据个人喜好，如果说追求美观，那么多去找一些方案，网上很多美化小技巧，装饰在自己博客上面，看着也赏心悦目，但是装饰太对，终究会拖加载速度的后腿，这就需要更多的技术来优化，例如SEO优化，但是博客嘛，以简洁为主还是很好的。不要太多了累赘，反而看着很舒服！</p><a id="more"></a><h2 id="更换Next主题"><a href="#更换Next主题" class="headerlink" title="更换Next主题"></a>更换Next主题</h2><ul><li>在<code>blog</code>文件夹下，右键打开<code>git bash here</code>，输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>可以看到<code>themes</code>文件夹下多了一个<code>next</code>文件，这就是next主题文件。</p><ul><li>启用主题：打开<code>F: \ blog \ _config.yml</code>,找到 <code>theme</code> 标签，更改为：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><ul><li>打开<code>F:\blog\themes\next\_config.yml</code>,找到<code>scheme</code>，启用<code>pisices</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><h2 id="网站基本设置"><a href="#网站基本设置" class="headerlink" title="网站基本设置"></a>网站基本设置</h2><ul><li>打开<code>F: \ blog \ _config.yml</code>,找到 <code>Site</code> 标签</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">Site</span></span><br><span class="line">title: 代澳旗's Blog</span><br><span class="line"><span class="selector-tag">subtitle</span>: <span class="selector-tag">Welcome</span> <span class="selector-tag">to</span> <span class="selector-tag">my</span> <span class="selector-tag">World</span>！！！</span><br><span class="line"><span class="selector-tag">description</span>: 这是我在学习过程中用<span class="selector-tag">hexo</span>搭建的一个基于<span class="selector-tag">github</span>的个人博客网站，用来存储学习笔记！</span><br><span class="line">keywords: ''</span><br><span class="line"><span class="selector-tag">author</span>: 代澳旗</span><br><span class="line"><span class="selector-id">#avatar</span>: 网站头像外部链接 </span><br><span class="line"><span class="selector-tag">language</span>: <span class="selector-tag">zh-Hans</span></span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><h2 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h2><ul><li>打开站点配置文件，修改如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /about/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><ul><li>打开命令行，输入：<code>hexo  n page categories</code>其他的页面也是如此。会看到<code>source</code>文件夹下有相应的文件生成。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305221225718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>打开里面的<code>index.md</code>，添加一个字段<code>type： categories</code>，其他的也是如此</li></ul><h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><ul><li>找到主题文件<code>F:\blog\themes\next\_config.yml</code>改为 true</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">Canvas-nest</span></span><br><span class="line"><span class="selector-tag">canvas_nest</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure><h2 id="鼠标点击效果图"><a href="#鼠标点击效果图" class="headerlink" title="鼠标点击效果图"></a>鼠标点击效果图</h2><ul><li>在<code>F:\blog\themes\next\source\js\src</code>里新建<code>love.js</code>，写入以下内容</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure><ul><li>打开<code>F:\blog\themes\next\layout\_layout.swig</code>,在末尾添加代码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击效果 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/love.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h2><ul><li>找到主题文件<code>F:\blog\themes\next\_config.yml</code>，找到<code>since</code>标签</li></ul><h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><ul><li>将头像图片放到<code>F:\blog\themes\next\source\images</code></li><li>打开<code>F:\blog\themes\next\_config.yml</code>，找到<code>avatar</code>，修改如下代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">avatar: /images/touxiang.jpg</span><br></pre></td></tr></table></figure><h2 id="修改网站图标"><a href="#修改网站图标" class="headerlink" title="修改网站图标"></a>修改网站图标</h2><ul><li>图标素材网站：<a href="https://www.iconfont.cn/collections/index?spm=a313x.7781069.1998910419.d2b281273&type=2">iconfont</a></li><li>下载16x16以及32x32大小的PNG格式图标，置于<code>/themes/next/source/images/</code>下</li><li>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>favicon</code>，修改要更换的图标名字即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/wangzhantubiao-16.png</span><br><span class="line">  medium: /images/wangzhantubiao-32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加<code>RSS</code></h2><ul><li>在<code>Git bash here</code>中添加插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><ul><li>在站点配置文件中添加如下代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line">plugin: hexo-generator-feed</span><br></pre></td></tr></table></figure><ul><li>在主题配置文件下添加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><h2 id="添加fork-me-Github"><a href="#添加fork-me-Github" class="headerlink" title="添加fork me Github"></a>添加fork me Github</h2><ul><li><p>点击<a href="https://github.blog/2008-12-19-github-ribbons/">http://tholman.com/github-corners/</a>挑选自己喜欢的样式，并复制代码。</p></li><li><p>找到<code>themes/next/layout/_layout.swig</code>文件，(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>改为你的<code>github</code>地址。</p><h2 id="修改文章底部带-号的标签"><a href="#修改文章底部带-号的标签" class="headerlink" title="修改文章底部带#号的标签"></a>修改文章底部带#号的标签</h2></li><li><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i <span class="class"><span class="keyword">class</span>="<span class="title">fa</span> <span class="title">fa</span>-<span class="title">tag</span>"&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><ul><li>在 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code><br>文件,添加你想说的内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;-------------结束啦&lt;i class=<span class="string">"fa fa-paw"</span>&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>打开<code>\themes\next\layout\_macro\post.swig</code>文件，在 <code>&lt;footer class=&quot;post-footer&quot;&gt;</code> 之后， <code>post-footer</code> 之前添加：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &#123;% include <span class="string">'passage-end-tag.swig'</span> %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h2><ul><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install gulp -g</span><br><span class="line">cnpm install gulp-minify-css gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure><ul><li>在<code>blog</code>下面新建<code>gulpfile.js</code>,写入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(<span class="string">'gulp'</span>);</span><br><span class="line">var minifycss = require(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line">var uglify = require(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">var htmlmin = require(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line">var htmlclean = require(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line">// 压缩 public 目录 css</span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public 目录 html</span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/js 目录 js</span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><ul><li>以后在生成博文是执行 <code>hexo g &amp;&amp; gulp</code>就会根据 <code>gulpfile.js</code> 中的配置，对 <code>public</code> 目录中的静态资源文件进行压缩。</li></ul><h2 id="修改代码块自定义样式"><a href="#修改代码块自定义样式" class="headerlink" title="修改代码块自定义样式"></a>修改代码块自定义样式</h2><ul><li>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//代码块自定义样式</span><br><span class="line">// Custom styles. </span><br><span class="line">code &#123;</span><br><span class="line">    color: <span class="comment">#ff7600;</span></span><br><span class="line">    background: <span class="comment">#fbf7f8;</span></span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid <span class="comment">#d6d6d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侧边栏社交链接小图标"><a href="#侧边栏社交链接小图标" class="headerlink" title="侧边栏社交链接小图标"></a>侧边栏社交链接小图标</h2><ul><li>打开<code>F:\blog\themes\next\_config.yml</code>,搜索<code>social_icons:</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/DAQ121 || github</span><br><span class="line">  csdn: https://blog.csdn.net/weixin_44861399 || crosshairs</span><br><span class="line">  weibo: https://weibo.com/呜啦啦咦1 || weibo</span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#weibo: weibo</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  csdn: crosshairs</span><br><span class="line"></span><br><span class="line">  icons_only: <span class="literal">false</span></span><br><span class="line">  transition: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><ul><li>打开<code>/themes/next/layout/_macro/post.swig</code>,加上<code>&lt;span&gt;°C&lt;/span&gt;</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20200306112055151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>打开<code>/themes/next/languages/zh-Hans.yml</code>，找到<code>visitors</code>标签，改为热度。</li></ul><h2 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h2><ul><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-dplayer</span><br><span class="line">npm install hexo-tag-aplayer</span><br></pre></td></tr></table></figure><ul><li>在网易云音乐生成外链，复制代码</li><li>打开<code>F:\blog\themes\next\layout\_macro</code>里的<code>sidebar.swig</code>，在此处添加复制胡链接</li></ul><p><img src="https://img-blog.csdnimg.cn/20200308110931114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h2><ul><li>安装插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><ul><li>在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"theme-info"</span>&gt;</span><br><span class="line">  &lt;div class=<span class="string">"powered-by"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=<span class="string">"post-count"</span>&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="实现统计功能"><a href="#实现统计功能" class="headerlink" title="实现统计功能"></a>实现统计功能</h2><ul><li>在主题配置文件中，配置：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: <span class="literal">true</span></span><br><span class="line">  wordcount: <span class="literal">true</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  totalcount: <span class="literal">false</span></span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><ul><li>打开：<code>/themes/next/layout/_partials/head.swig</code>，添加代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="修改网页底部的桃心"><a href="#修改网页底部的桃心" class="headerlink" title="修改网页底部的桃心"></a>修改网页底部的桃心</h2><ul><li>打开：<code>/themes/next/layout/_partials/footer.swig</code>，修改你想用的图标</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=<span class="string">"with-love"</span>&gt;</span><br><span class="line">   &lt;i class=<span class="string">"far fa-grin-tongue-wink"</span>&gt;&lt;/i&gt;</span><br><span class="line"> &lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="添加百度分享"><a href="#添加百度分享" class="headerlink" title="添加百度分享"></a>添加百度分享</h2><ul><li>给next主题添加了百度分享功能,在本地一切正常,但是当发布到github的时候,却不能正常显示，因为github上百度分享不支持在https上使用。</li><li>所以将主题配置<code>_config.yml</code>文件中关于<code>baidushare</code>部分的内容改为（其中<code>type</code>亦可以选择<code>button</code>）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  <span class="built_in">type</span>: slide</span><br><span class="line">  baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>下载<code>static</code>文件夹，地址：<a href="https://github.com/hrwhisper/baiduShare">https://github.com/hrwhisper/baiduShare</a>，将<code>static</code>文件夹保存至<code>themes\next\source</code>目录下。</li><li>修改文件：<code>themes\next\layout_partials\share\baidushare.swig</code><br>末尾部分的代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.src=<span class="string">'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='</span>+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.src=<span class="string">'/static/api/js/share.js?v=89860593.js?cdnversion='</span>+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt; 展现在你眼前的，只是部分功能，很基础的，根据个人喜好，如果说追求美观，那么多去找一些方案，网上很多美化小技巧，装饰在自己博客上面，看着也赏心悦目，但是装饰太对，终究会拖加载速度的后腿，这就需要更多的技术来优化，例如SEO优化，但是博客嘛，以简洁为主还是很好的。不要太多了累赘，反而看着很舒服！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>了解操作系统</title>
    <link href="http://daqwt.top/1988581478/"/>
    <id>http://daqwt.top/1988581478/</id>
    <published>2020-03-15T14:02:48.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机三件套之一：计算机操作系统，我刚开始看学校发的教材的时候，根本看不进去，一是知识太过于理论化，而且关于底层的东西，动手实践起来真的很难。但是一些简单的东西还是要了解一下的。其实在我看来，没有太大追求的话，就了解一些基本的就可以了，操作系统就那点儿东西：CPU调度，死锁，中断机制，进程管理，内存管理，文件系统，虚拟内存，就没了<del>~</del></p><a id="more"></a><h1 id="操作系统有哪些？"><a href="#操作系统有哪些？" class="headerlink" title="操作系统有哪些？"></a>操作系统有哪些？</h1><h2 id="1-简单的批处理操作系统"><a href="#1-简单的批处理操作系统" class="headerlink" title="1.简单的批处理操作系统"></a>1.简单的批处理操作系统</h2><p>一批一批处理任务的系统，用户将一批作业提交给操作系统后便不再干预，由操作系统控制它们自动运行。用户一次可以提交多个作业，但系统一次只处理一个作业，处理完一个作业后，再调入下一个作业进行处理。这些调度、切换系统自动完成。</p><h2 id="2-多道程序批处理操作系统"><a href="#2-多道程序批处理操作系统" class="headerlink" title="2.多道程序批处理操作系统"></a>2.多道程序批处理操作系统</h2><p>简单批处理系统一次只能处理一个作业，系统资源的利用率就不高，因此出现<strong>多道程序</strong>批处理系统。把同一个批次的作业调入内存，存放在内存的不同部分，当一个作业由于等待输入输出操作而让<strong>处理机</strong>出现空闲，系统自动进行切换，处理另一个作用，这就是多道程序批处理系统。相对简单批处理系统，由于充分利用了处理机的空闲时间，因此多道程序批处理系统的<strong>资源利用效率</strong>要高。</p><h2 id="3-分时操作系统"><a href="#3-分时操作系统" class="headerlink" title="3.分时操作系统"></a>3.分时操作系统</h2><p>分时操作系统：“分时”的含义是指多个用户使用同一台计算机，多个程序分时（分时间片）共享硬件和软件资源。分时操作系统是指在一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户通过主机的终端，以<strong>交互</strong>方式使用计算机，共享主机中的资源。分时操作系统将CPU的时间划分成若干个片段，称为<strong>时间片</strong>，操作系统以时间片为单位，轮流为每个终端用户服务 。</p><ul><li>总结：一个作业只能在<strong>一个</strong>时间片的时间内使用CPU,时间到时，系统将剥夺作业CPU的使用权，然后根据一定的算法将CPU分配给其他作业使用。</li></ul><h2 id="4-实时操作系统"><a href="#4-实时操作系统" class="headerlink" title="4.实时操作系统"></a>4.实时操作系统</h2><p>指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的操作系统。</p><h2 id="5-网络操作系统"><a href="#5-网络操作系统" class="headerlink" title="5.网络操作系统"></a>5.网络操作系统</h2><p>指的是一台计算机通过一个<strong>网络接口控制器</strong>(网卡)连接到网络上，可以进行网络通信功能，网络资源的管理和使用。根据使用环境的不同，操作系统又可以分为<strong>服务器操作系统</strong>、<strong>桌面操作系统</strong>、<strong>嵌入式操作系统</strong>等</p><h1 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h1><h2 id="一、手工操作"><a href="#一、手工操作" class="headerlink" title="一、手工操作"></a>一、手工操作</h2><p><img src="https://img-blog.csdnimg.cn/20200312165529351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二、单道批处理"><a href="#二、单道批处理" class="headerlink" title="二、单道批处理"></a>二、单道批处理</h2><p><img src="https://img-blog.csdnimg.cn/20200312165540713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312165607449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、多道批处理操作系统"><a href="#三、多道批处理操作系统" class="headerlink" title="三、多道批处理操作系统"></a>三、多道批处理操作系统</h2><p><img src="https://img-blog.csdnimg.cn/20200312165604663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312165623503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312165626625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312173008164.png" alt="在这里插入图片描述"></p><h2 id="四、分时操作系统"><a href="#四、分时操作系统" class="headerlink" title="四、分时操作系统"></a>四、分时操作系统</h2><p><img src="https://img-blog.csdnimg.cn/20200312173731270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312173737316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200312173740994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算机三件套之一：计算机操作系统，我刚开始看学校发的教材的时候，根本看不进去，一是知识太过于理论化，而且关于底层的东西，动手实践起来真的很难。但是一些简单的东西还是要了解一下的。其实在我看来，没有太大追求的话，就了解一些基本的就可以了，操作系统就那点儿东西：CPU调度，死锁，中断机制，进程管理，内存管理，文件系统，虚拟内存，就没了&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机操作系统" scheme="http://daqwt.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://daqwt.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>建站系列之---基于github搭建hexo网站</title>
    <link href="http://daqwt.top/167674660/"/>
    <id>http://daqwt.top/167674660/</id>
    <published>2020-03-15T08:11:58.000Z</published>
    <updated>2020-04-17T03:13:59.026Z</updated>
    
    <content type="html"><![CDATA[<p>日常在网上找答案的时候，发现了一种干干净净的，类似于个人主页的网站，就很好奇，后来深入了解了一下，原来这是基于hexo博客框架搭建起来的网站，用github的page服务托管博文，于是我也想上手整一个，于是乎，就花了前前后后大概半个月的时间，搭建起来网站，并买了域名部署到了服务器上面，此时怀着欣慰的心情，写下了这个系列！！！！</p><a id="more"></a><p><strong>概述：</strong> 本文主要讲的是基于github，利用hexo博客框架搭建网站。购买域名（9块）并绑定。实现效果：可以看到网站首页。</p><h2 id="一、下载安装Git"><a href="#一、下载安装Git" class="headerlink" title="一、下载安装Git"></a>一、下载安装Git</h2><p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>安装过程就不赘述了！</p><h2 id="二、下载安装Node-js"><a href="#二、下载安装Node-js" class="headerlink" title="二、下载安装Node.js"></a>二、下载安装Node.js</h2><p>下载地址：<a href="http://nodejs.org/download/">http://nodejs.org/download/</a><br>安装的时候，选择<code>add to path</code>，他会自动配置环境变量。</p><ul><li>换镜像（亲身体验，可以省去以后好多麻烦）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><ul><li>用cnpm全局安装，在桌面右键打开<code>Git bash here</code>输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>安装完成后，在命令行里输入<code>hexo -v</code>检查是否安装成功。</li></ul><p> <img src="https://img-blog.csdnimg.cn/20200305155050299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、配置hexo"><a href="#四、配置hexo" class="headerlink" title="四、配置hexo"></a>四、配置hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基本命令了解：</span><br><span class="line">1. hexo -v//查看版本</span><br><span class="line">2. hexo init//初始化一个项目</span><br><span class="line">3. cnpm install</span><br><span class="line">4. hexo clean//清理生成的文件</span><br><span class="line">5. hexo g//生成静态网页文件，g是generate的缩写</span><br><span class="line">6. hexo s//运行到服务器端，s是server的缩写</span><br><span class="line">7. hexo d//部署到远端GitHub, d是deploy的缩写</span><br><span class="line">8. hexo s -p 5000//在4000端口被占用的时候，修改指定端口</span><br><span class="line">9. cnpm uninstall hexo-cli -g       //卸载hexo</span><br></pre></td></tr></table></figure><ul><li>在本地新建一个文件夹，我命名它为blog</li><li>在这个文件夹下，右键打开<code>Git Bash here</code>，输入<code>hexo init</code>，我在这个地方出现了一个<code>WARN</code>，暂时不用管它。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305135143147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>继续输入<code>cnpm install</code>可以看到blog文件夹里出现：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305155919286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">目录介绍：</span><br><span class="line">1. node_modules <span class="comment">#本地依赖模块</span></span><br><span class="line">2. public <span class="comment">#hexo g生成的目录，包含静态网页文件，就是看到的博客</span></span><br><span class="line">2. <span class="built_in">source</span> <span class="comment">#源文件，用来存放我们的写好的博客源文件</span></span><br><span class="line">3. themes <span class="comment">#主题文件夹，里面存放主题</span></span><br><span class="line">4. _config.yml <span class="comment">#站点配置文件，用来配置博客具体的显示内容等</span></span><br><span class="line">5. db.json <span class="comment">#存储一些用到的数据</span></span><br><span class="line">6.package.json <span class="comment">#依赖配置</span></span><br><span class="line"></span><br><span class="line">.deploy_git <span class="comment">#hexo s部署到远端的时候会生成的文件夹，是根据public文件夹生成的，内容是差不多的</span></span><br></pre></td></tr></table></figure><ul><li>输入：<code>hexo g</code></li><li>输入：<code>hexo s</code> </li></ul><p><img src="https://img-blog.csdnimg.cn/20200305135917128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>打开浏览器输入<code>localhost：4000</code>，可以看到部署好了，有一篇<code>hello World</code>的博客</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305154439378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>到这一步，本地部署就已经成功了！！</li></ul><h2 id="五、连接到远端Github"><a href="#五、连接到远端Github" class="headerlink" title="五、连接到远端Github"></a>五、连接到远端Github</h2><ul><li>安装 <code>deployer</code> 插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>打开<code>F:\blog\_config.yml</code>,找到 <code>deploy</code>。修改如下，其中<code>repo</code>填写你自己的仓库名字。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305161344694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>生成公私钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"注册git使用的邮箱"</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200305161705454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>找到生成的 <code>id_rsa.pub</code> 公钥文件（在<code>C:\Users\pc\.ssh</code>下），复制公钥内容。</li><li>到Github你的网站仓库界面：<code>Setting -&gt; Deploy keys -&gt; add deploy key -&gt; Addkey</code>，选择<code>Allow write access</code>（允许推送），这样方便以后推送的时候，不用每次都输入密码。</li><li>开始推送</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这样在博客和github都可以看到推送的内容。</p><h2 id="六、购买绑定域名"><a href="#六、购买绑定域名" class="headerlink" title="六、购买绑定域名"></a>六、购买绑定域名</h2><p>阿里云：<a href="https://wanwang.aliyun.com/domain/">https://wanwang.aliyun.com/domain/</a></p><ul><li>在阿里云或者腾讯云购买一个域名，我买的是阿里云的<code>.top</code>后缀名的，后缀名不同，价格不同，top最便宜，一年只要九块。</li><li>如何买域名以及解析域名不做描述，注意要是实名认证，解析域名的意思就是，把ip地址和域名做一个映射，它让你填的<code>ip地址</code>就是你github网站仓库的<code>ip</code>。如何得到这个<code>ip</code>：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305163101123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>填入<code>ip</code>，完成解析。</li><li>在<code>F:\blog\source</code>下新建一个<code>CNAME.txt</code>,在里面写入你的域名，不要前缀，如：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305163539152.png" alt="在这里插入图片描述"></p><ul><li>去掉<code>.txt</code>后缀</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305163544455.png" alt="在这里插入图片描述"></p><ul><li>绑定域名，到github，找到你的仓库，找到<code>Setting</code>，一直拉到最先面下面。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200305164627522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020030516473779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>这样就绑定好了。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每次部署的执行次序</span><br><span class="line">1. hexo clean</span><br><span class="line"> 2. hexo g</span><br><span class="line">3. hexo d</span><br></pre></td></tr></table></figure><ul><li>执行一次，查看效果。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常在网上找答案的时候，发现了一种干干净净的，类似于个人主页的网站，就很好奇，后来深入了解了一下，原来这是基于hexo博客框架搭建起来的网站，用github的page服务托管博文，于是我也想上手整一个，于是乎，就花了前前后后大概半个月的时间，搭建起来网站，并买了域名部署到了服务器上面，此时怀着欣慰的心情，写下了这个系列！！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo建站系列" scheme="http://daqwt.top/categories/Hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="hexo" scheme="http://daqwt.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="http://daqwt.top/3524511244/"/>
    <id>http://daqwt.top/3524511244/</id>
    <published>2020-03-15T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略来建立连接。通过四次挥手来释放连接。</p><a id="more"></a><ul><li>用<code>wireshark</code>抓包分析一次连接的报文信息</li></ul><p><img src="https://img-blog.csdnimg.cn/20200409123355146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>这是tcp报文的数据包格式。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315135901175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>序列号seq：</strong> 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</li></ul><ul><li><strong>确认号ack：</strong> 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li></ul><ul><li><strong>确认ACK：</strong> 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</li></ul><ul><li><strong>同步SYN：</strong> 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</li></ul><ul><li><strong>终止FIN：</strong> 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</li></ul><ul><li><strong>补充：</strong> ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</li></ul><h2 id="三次握手过程与作用"><a href="#三次握手过程与作用" class="headerlink" title="三次握手过程与作用"></a>三次握手过程与作用</h2><p>刚开始客户端处于<code>CLOSE</code>的状态，服务端处于<code>LISTEN</code>状态。<br><strong>第一次握手：</strong></p><ul><li>建立连接时，客户端发送SYN包（同时随机生成初始序列号seq=x，并进入<code>SYN_SENT</code>状态，等待服务器确认。</li><li>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</li></ul><p> <strong>第二次握手：</strong></p><ul><li>服务器收到SYN包，发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要<strong>为自己</strong>随机初始化一个序列号 seq=y，此时服务器进入<code>SYN_RECV</code>状态。</li><li>这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</li></ul><p><strong>第三次握手：</strong></p><ul><li>客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。</li></ul><ul><li>第三次的ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315113736297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>三次握手的作用</strong></p><ol><li>确认双方的接受能力，发送能力是否正常。</li><li>指定自己的初始化序列号，为后面的可靠传送做准备。</li><li>如果是Https协议的话，三次握手这个过程，还会进行数字证书的验证，以及加密秘钥的生成。</li></ol><h2 id="面试常见问题："><a href="#面试常见问题：" class="headerlink" title="面试常见问题："></a>面试常见问题：</h2><h3 id="①（ISN）是固定的吗？"><a href="#①（ISN）是固定的吗？" class="headerlink" title="①（ISN）是固定的吗？"></a>①（ISN）是固定的吗？</h3><ul><li>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number，初始序列号), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</li><li>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</li></ul><h3 id="②什么是半连接队列？"><a href="#②什么是半连接队列？" class="headerlink" title="②什么是半连接队列？"></a>②什么是半连接队列？</h3><ul><li>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</li><li>补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</li></ul><h3 id="③三次握手过程中可以携带数据吗？"><a href="#③三次握手过程中可以携带数据吗？" class="headerlink" title="③三次握手过程中可以携带数据吗？"></a>③三次握手过程中可以携带数据吗？</h3><ul><li><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，<strong>而第三次握手是可以携带数据的</strong>。</p></li><li><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p></li><li><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p></li></ul><h3 id="④为什么要三次握手呢？有人说两次握手就好了"><a href="#④为什么要三次握手呢？有人说两次握手就好了" class="headerlink" title="④为什么要三次握手呢？有人说两次握手就好了"></a>④为什么要三次握手呢？有人说两次握手就好了</h3><ul><li><p>举例：已失效的连接请求报文段。</p></li><li><p>客户端发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。</p></li></ul><h2 id="四次挥手过程详解"><a href="#四次挥手过程详解" class="headerlink" title="四次挥手过程详解"></a>四次挥手过程详解</h2><p><strong>第一次挥手：</strong></p><ul><li>TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态。</li><li>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ul><p><strong>第二次挥手</strong></p><ul><li>​ 服务端收到这个FIN，他发回一个<strong>ACK报文</strong> 确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。​ 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态。</li><li>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ul><p><strong>第三次挥手：</strong></p><ul><li>​ 服务端发送一个<strong>FIN(结束)</strong>到客户端，服务端关闭客户端的连接。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</li></ul><p><strong>第四次挥手：</strong></p><ul><li>​ 客户端发送<strong>ACK</strong> 报文确认，并将确认的序号+1，这样关闭完成。​ 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。此时TCP连接还没有释放，必须经过<code>2∗∗MSL</code>（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200315131718947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="面试常问："><a href="#面试常问：" class="headerlink" title="面试常问："></a>面试常问：</h2><h3 id="①为什么是4次挥手呢？"><a href="#①为什么是4次挥手呢？" class="headerlink" title="①为什么是4次挥手呢？"></a>①为什么是4次挥手呢？</h3><ul><li>为了确保数据能够完成传输。关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</li></ul><h3 id="②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？"><a href="#②tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送呢？" class="headerlink" title="②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？"></a>②tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？</h3><ul><li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，<strong>“你发的FIN报文我收到了”</strong>。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul><h3 id="③客户端突然挂掉了怎么办？"><a href="#③客户端突然挂掉了怎么办？" class="headerlink" title="③客户端突然挂掉了怎么办？"></a>③客户端突然挂掉了怎么办？</h3><ul><li>正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现长时期的空闲。解决办法是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。</li></ul><h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><p><strong>背景：</strong></p><ul><li>初始化连接的 SYN 超时问题Client发送SYN包给Server后挂了，Server回给Client的SYN-ACK一直没收到Client的ACK确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让Server将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的SYN连接队列耗尽。</li></ul><p><strong>让正常的连接无法得到处理。</strong></p><ul><li>​ 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。</li></ul><p><strong>什么是 SYN 攻击？</strong></p><ul><li>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。</li></ul><p><strong>如何检测 SYN 攻击？</strong></p><ul><li>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的netstats 命令来检测 SYN 攻击。</li></ul><p><strong>如何防御 SYN 攻击？</strong></p><ul><li>​ SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：<br>①缩短超时（SYN Timeout）<br>②时间增加最大半连接数<br>③过滤网关防护SYN<br>④cookies技术</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略来建立连接。通过四次挥手来释放连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="TCP" scheme="http://daqwt.top/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>一、HashMap的底层实现原理</title>
    <link href="http://daqwt.top/2744944506/"/>
    <id>http://daqwt.top/2744944506/</id>
    <published>2020-03-14T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.975Z</updated>
    
    <content type="html"><![CDATA[<p>HeshMap是基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。在面试中也经常出现这道考题，记录一下！</p><a id="more"></a><h1 id="HsahMap的实现原理"><a href="#HsahMap的实现原理" class="headerlink" title="HsahMap的实现原理"></a>HsahMap的实现原理</h1><h2 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h2><ul><li>HashMap 基于 Hash 算法实现的，底层是由数组+链表/红黑树构成的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表，否则使用红黑树。</li></ul><h2 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h2><ul><li>HashMap通过<strong>键值对</strong>实现存取。</li><li><code>put（）</code>方法：对key做null检查。如果key是null，会被存储到table[0]，因为null的hash值总是0。 key的hashcode()方法会被调用，然后计算hash值。hash值用来找到存储Entry对象的数组的索引。有时候hash函数可能写的很不好，所以JDK的设计者添加了另一个叫做hash()的方法，它接收刚才计算的hash值作为参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt;[] tab; </span><br><span class="line">   Node&lt;K,V&gt; p; </span><br><span class="line">   <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><code>Get（）</code>：对key进行null检查。如果key是null，table[0]这个位置的元素将被返回。<br>key的hashcode()方法被调用，然后计算hash值。indexFor(hash,table.length)用来计算要获取的Entry对象在table数组中的精确的位置，使用刚才计算的hash值。在获取了table数组的索引之后，会迭代链表，调用equals()方法检查key的相等性，如果equals()方法返回true，get方法返回Entry对象的value，否则，返回null。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="built_in">return</span> (e = getNode(<span class="built_in">hash</span>(key), key)) == null ? null : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Implements Map.get and related methods.</span><br><span class="line">    *</span><br><span class="line">    * @param <span class="built_in">hash</span> <span class="built_in">hash</span> <span class="keyword">for</span> key</span><br><span class="line">    * @param key the key</span><br><span class="line">    * @<span class="built_in">return</span> the node, or null <span class="keyword">if</span> none</span><br><span class="line">    */</span><br><span class="line">   final Node&lt;K,V&gt; getNode(int <span class="built_in">hash</span>, Object key) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">           (first = tab[(n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == <span class="built_in">hash</span> &amp;&amp; // always check first node</span><br><span class="line">               ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="built_in">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != null) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first instanceof TreeNode)</span><br><span class="line">                   <span class="built_in">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(<span class="built_in">hash</span>, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="built_in">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>补充：</p><ol><li>HashMap有一个叫做Entry的内部类，它用来存储key-value对。</li><li>上面的Entry对象是存储在一个叫做table的Entry数组中。</li><li>table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。</li><li>key的hashcode()方法用来找到Entry对象所在的桶。</li><li>如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。</li><li>key的equals()方法用来确保key的唯一性。</li></ol><h1 id="有关知识的具体解析"><a href="#有关知识的具体解析" class="headerlink" title="有关知识的具体解析"></a>有关知识的具体解析</h1><h2 id="一、Map的几种类型"><a href="#一、Map的几种类型" class="headerlink" title="一、Map的几种类型"></a>一、Map的几种类型</h2><p><img src="https://img-blog.csdnimg.cn/20200314144530842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Map就是一个值key对应一个value。</li><li>Hashtable（线程安全）和HashMap（非线程安全）在代码实现上，基本上是一样的。现在Hashtable已经过时了(小写的t，因为sun当时的一个失误，因为是JDK1.0的产物，所以不方便改)。</li><li>ConcurrentHashMap也是线程安全的，但性能比HashTable好很多，Hashtable是锁整个Map对象，而ConcurrentHashMap是锁Map的部分结构。</li></ul><h2 id="二、什么是哈希表？"><a href="#二、什么是哈希表？" class="headerlink" title="二、什么是哈希表？"></a>二、什么是哈希表？</h2><ul><li>利用<strong>数组</strong>寻址容易，但插入和删除困难。而<strong>链表</strong>是：寻址困难，插入和删除容易。而<strong>哈希表</strong>便综合两者的特性，是一种寻址容易，插入删除也容易的数据结构。</li><li>哈希表有多种不同的实现方法，最常用的方法—— 拉链法，可以理解为“链表的数组”<br><img src="https://img-blog.csdnimg.cn/20200314161134205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>一个长度为16的数组中，每个元素存储的是一个链表的头结点。这些元素是按照什么样的规则存储到数组中呢？一般情况是通过<code>hash(key)%len</code>获得，也就是元素的key的哈希值对数组长度取模得到。</li><li>比如上述哈希表中12%16=12 , 28%16=12 , 108%16=12 , 140%16=12。所以12、28、108，140都存储在数组下标为12的位置。</li><li><strong>HashMap其实也是一个线性数组（<code>Entry[]</code>）实现的,所以可以理解为其存储数据的容器就是一个线性数组。但是一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap是做了一些处理的。</strong></li></ul><h2 id="三、什么是哈希算法？"><a href="#三、什么是哈希算法？" class="headerlink" title="三、什么是哈希算法？"></a>三、什么是哈希算法？</h2><ul><li>Hash算法虽然被称为算法，但实际上它更像是一种思想。Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法。</li><li>哈希（hash）算法又称为散列算法，通过hash算法，可以将任意长度的信息转换成一个固定长度的二进制数据，我们经常会使用十六进制值来表示转换后的信息。</li><li>比如，数字123，使用md5的hash算法后，得到十六进制的值：202cb962ac59075b964b07152d234b70</li><li>哈希算法的特点：<br>（1）不同的信息，理论上得到的hash值不同，我们称之为“无碰撞”，或者发生“碰撞”的概率非常小。<br>（2）不可逆，hash算法是单向的，从hash值反向推导出原始信息是很困难的。所以，有些系统中，我们可以使用hash算法对密码进行处理后保存。</li><li>哈希算法的应用<br>①</li></ul><h2 id="四、什么是红黑树？"><a href="#四、什么是红黑树？" class="headerlink" title="四、什么是红黑树？"></a>四、什么是红黑树？</h2><ul><li><strong>二叉树（BST）</strong>：<br>①左子树结点的值小于等于根节点的值。<br>②右子树结点的值大于等于根节点的值。<br>③左右子树分开来也是单独的二叉树。<br><img src="https://img-blog.csdnimg.cn/20200314174010980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul><li><strong>红黑树（RBT）</strong>：红黑树是一种自平衡的二叉树，除了符合二叉树的基本特征之外还引入了一些附加的条件。<br>①节点是红色或黑色。<br>②根节点是黑色。<br>③每个叶子节点都是黑色的空节点（NIL节点）。<br>④每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。<br>⑥从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br><img src="https://img-blog.csdnimg.cn/20200314174041551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="五、HashMap-和-Hashtable-有什么区别？"><a href="#五、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="五、HashMap 和 Hashtable 有什么区别？"></a>五、HashMap 和 Hashtable 有什么区别？</h2><ul><li>HashMap是非线程安全的，HashMap是Map的一个实现类，是将键映射到值的对象，不允许键值重复。允许空键和空值；由于非线程安全，HashMap的效率要较 Hashtable 的效率高一些。</li><li>Hashtable 是线程安全的一个集合，不允许 null 值作为一个 key 值或者value 值。             </li><li>Hashtable是sychronized，多个线程访问时不需要自己为它的方法实现同步，而HashMap 在被多个线程访问的时候需要自己为它的方法实现同步。</li><li>一般现在不建议用Hashtable：<br>①注意是小写的t，这是sun公司的一个失误，但是由于是JDK1.0的产物，所以没有改<br>②是Hashtable是遗留类，内部实现很多没优化和冗余。<br>③即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</li></ul><h1 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h1><h2 id="产生hash冲突的原因"><a href="#产生hash冲突的原因" class="headerlink" title="产生hash冲突的原因"></a>产生hash冲突的原因</h2><ul><li>当我们通过put(key, value)向hashmap中添加元素时，需要通过hash函数确定元素究竟应该放置在数组中的哪个位置，因为不同的元素可能通过hashcode（）计算得到的哈希值相同，那么不同的元素被放置在了数据的同一个位置时，后放入的元素会以链表的形式，插在前一个元素的尾部，这个时候我们称发生了hash冲突。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>事实上，想让hash冲突完全不发生，是不太可能的，我们能做的只是尽可能的降低hash冲突发生的概率。<br>①开放定址法<br>②链地址法（拉链法）<br>Java 中 HashMap 解决 Hash 冲突就是利用了这个方法，具体实现这里暂时不做详解，可以参考 Jdk HashMap 源码进行理解。<br>③再哈希法<br>④建立公共溢出区</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HeshMap是基于哈希表的Map接口的实现，此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。在面试中也经常出现这道考题，记录一下！&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="HashMap" scheme="http://daqwt.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---泛型</title>
    <link href="http://daqwt.top/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://daqwt.top/%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-03-12T05:45:03.000Z</published>
    <updated>2020-04-18T07:40:45.119Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JDK1.5，引进泛型这个概念。是指在创建对象或者调用方法的时候，再去明确类型。即参数化类型，简单来说，就是把类型当作一种参数来传递，只不过一般情况下参数写在（）中，而类型写在&lt;&gt;中。并且在&lt;&gt;中只能是引用类型。</p><a id="more"></a><h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><ul><li><strong>泛型本质：</strong> 在创建对象或者调用方法的时候，再去明确类型。</li><li><strong>引用类型（reference type）：</strong> 指向一个对象，而不是原始值，指向对象的变量是引用变量。在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。</li></ul><ul><li><p><strong>泛型的设计原则：</strong>  只要在编译时期没有出现警告，那么运行时期就不会出现<code>ClassCastException</code>异常。</p></li><li><p><strong>一些常用的泛型类型变量：</strong></p></li></ul><pre><code>E：元素（Element），多用于java集合框架K：关键字（Key）N：数字（Number）T：类型（Type）V：值（Value）</code></pre><h2 id="泛型对比测试"><a href="#泛型对比测试" class="headerlink" title="泛型对比测试"></a>泛型对比测试</h2><ul><li>首先来看不加泛型的情况下，在list集合中添加不同类型的数据，并且在遍历的时候强转，编译的时候注定会报<code>ClassCastException</code>异常的。这就是由于集合中元素类型不统一造成的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//添加一个String类型的元素</span></span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line"><span class="comment">//添加一个Integer类型的元素</span></span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line"><span class="comment">//都强转成String类型</span></span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加上泛型之后的，就规定了，这个集合中只能装这个类型的元素，要是装别的，在敲代码的时候就会报错，因为你加入的元素，跟规定的类型不一致，不让你加。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><h2 id="为什么要使用泛型？"><a href="#为什么要使用泛型？" class="headerlink" title="为什么要使用泛型？"></a>为什么要使用泛型？</h2><ul><li>早期用Object来代替任意类型，但是这样做，有的时候就要进行向下强转，这样做不太安全。</li><li>没有泛型的话，像<code>Collection</code>，<code>Map</code>这种不限制元素类型的集合，你可以往里面丟任何元素，并且不会报语法错误，但是集合不知道这个元素是什么类型的，默认都是<code>Object</code>类型，等你取出来的时候，就给你返<code>Object</code>类型的，可谓乱丢一时爽，<code>get</code>火葬场。</li><li>有了泛型呢，就不用强制转换了，因为你在事先就规定好了，这个集合中装什么类型的元素，使代码更加简洁。程序也更加健壮（这才是猛男该做得事），因为只要编译没有警告，那么运行的时候就不会出现<code>ClassCastException</code>异常了。</li></ul><h2 id="使用泛型有什么好处？"><a href="#使用泛型有什么好处？" class="headerlink" title="使用泛型有什么好处？"></a>使用泛型有什么好处？</h2><ul><li>上面通过对比已经看出，泛型有哪些好处，这里在总结一下。<br>①代码更简洁<br>②程序更健壮<br>③可读性和稳定性<br>④配合增强for循环遍历集合</li></ul><h2 id="怎么使用泛型？"><a href="#怎么使用泛型？" class="headerlink" title="怎么使用泛型？"></a>怎么使用泛型？</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li>把泛型定义在类上，也可以定义在方法上，在使用该类或者方法的时候，才根据自己的需要，将类型明确下来。<strong>注意：</strong> <strong>类上声明的泛型，只对非静态成员有效。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.定义</span><br><span class="line"><span class="comment">//把泛型定义在类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTool</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> object;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T object)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.object=object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>.使用</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）&#123;</span><br><span class="line"><span class="comment">//创建对象，并指定其元素类型(这里是String型)</span></span><br><span class="line">ObjectTool&lt;String&gt; tool1 = <span class="keyword">new</span> ObjectTool&lt;&gt;();</span><br><span class="line"></span><br><span class="line">tool1.setObj(<span class="keyword">new</span> String(<span class="string">"张三"</span>));</span><br><span class="line">String s=tool.getObj();</span><br><span class="line">System.Out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象，并指定其元素类型(这里是Integer型)</span></span><br><span class="line">ObjectTool&lt;Integer&gt; tool2 = <span class="keyword">new</span> ObjectTool&lt;&gt;();</span><br><span class="line"></span><br><span class="line">tool2.setObj(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> i=tool2.getObj();</span><br><span class="line">System.Out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>如果外界仅仅对一个方法感兴趣，而不关心类中的其他属性，那么将泛型定义在类上就有些小题大做，这里直接定义在方法上，精准打击！！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.定义泛型方法</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">System.Out.println(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>.泛型方法的使用</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">ObjectTool obj = <span class="keyword">new</span> ObjectTool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法，传进来什么类型，返回值就是什么类型</span></span><br><span class="line">obj.show(<span class="string">"hello"</span>);</span><br><span class="line">obj.show(<span class="number">4</span>);</span><br><span class="line">obj.show(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类派生出的子类"><a href="#泛型类派生出的子类" class="headerlink" title="泛型类派生出的子类"></a>泛型类派生出的子类</h3><ul><li>换上马甲他还是王八，虽然加了泛型，但说到底，他还是个类，既然是个类，那么他就可以被继承。然而泛型类的继承也分两种。</li></ul><p>①<strong>子类明确泛型类的类型参数变量(泛型接口)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把泛型定义在接口上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类明确泛型类的类型参数变量:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②<strong>子类不明确泛型类的类型参数变量</strong></p><ul><li>此时，外界使用子类的时候，也需要传递类型参数变量进来，在实现类上需要定义出类型参数变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现类要定义出&lt;T&gt;类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><ul><li><strong>问题：</strong> 方法接收一个集合参数，遍历集合并把集合元素打印出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通解决办法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加类型通配符？</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就加了一个问号？，能有什么作用<br>答案是：更优雅~</li><li>还有一个问题是设置通配符上限和下限。这个问题很绕，搞不清楚，当然，大多时候，使用泛型方法来替代通配符，条条大路通罗马嘛。</li><li><strong>注意：加了？就只能调用与对象无关的方法，不能调用对象与类型有关的方法。因为直到外界使用才知道具体的类型是什么。也就是说，在上面的List集合，是不能使用add()方法的。因为add()方法是把对象丢进集合中，而现在不知道对象的类型。</strong></li></ul><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul><li>因为泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即<strong>挡住向集合中插入非法数据</strong>。但编译器编译完带有泛形的java程序后，生成的class文件中将不再带有泛形信息，以此使程序运行效率不受到影响，这个过程称之为“泛型擦除”。这一点应用在兼容老版本上，因为JDK1.5之前没有泛型，当把带有泛型特性的集合赋值给老版本的集合时候，就会把泛型擦除掉，amazing！</li></ul><h2 id="应用场景有哪些？"><a href="#应用场景有哪些？" class="headerlink" title="应用场景有哪些？"></a>应用场景有哪些？</h2><ul><li><strong>场景一：</strong>最常用的还是应用于限制集合的参数类型。</li><li><strong>场景二：</strong>项目中，每次都要写好几个DAO，会显得臃肿。</li><li><strong>优化办法–抽象DAO：</strong> 在抽象DAO中，是不知道哪一个DAO会继承它，所以是不知道其具体的类型的。而泛型就是在创建的时候才指定其具体的类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">抽象DAO</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="keyword">private</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哪个子类调的这个方法，得到的class就是子类处理的类型（非常重要）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = <span class="keyword">this</span>.getClass();  <span class="comment">//拿到的是子类</span></span><br><span class="line">        ParameterizedType  pt = (ParameterizedType) clazz.getGenericSuperclass(); </span><br><span class="line">         <span class="comment">//BaseDao&lt;Category&gt;</span></span><br><span class="line">        clazz = (Class) pt.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        session.save(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) session.get(clazz, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        session.update(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        T t = (T) session.get(clazz, id);</span><br><span class="line">        session.delete(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">继承抽象DAO</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Category</span>&gt; </span>&#123;</span><br><span class="line">将抽象DAO中的方法继承了下来</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在JDK1.5，引进泛型这个概念。是指在创建对象或者调用方法的时候，再去明确类型。即参数化类型，简单来说，就是把类型当作一种参数来传递，只不过一般情况下参数写在（）中，而类型写在&amp;lt;&amp;gt;中。并且在&amp;lt;&amp;gt;中只能是引用类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE---集合</title>
    <link href="http://daqwt.top/%E9%9B%86%E5%90%88/"/>
    <id>http://daqwt.top/%E9%9B%86%E5%90%88/</id>
    <published>2020-03-11T03:35:14.000Z</published>
    <updated>2020-04-26T05:34:14.454Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要用集合？因为以前用数组存储数据，因为创建数组的时候就要初始化数组的长度，由于这个长度是不可变的，这就导致两个问题：定义数组长度值太大，实际用不了那么多，就会造成内存的浪费，那定义的太小了，不够用了又得扩容，这就得不偿失了，所以这个时候，集合横空出世，相当于一个没有上限的盒子，数据直接丢进去。</p><a id="more"></a><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><img src="https://img-blog.csdnimg.cn/20200415200516371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="它有什么好处？"><a href="#它有什么好处？" class="headerlink" title="它有什么好处？"></a>它有什么好处？</h2><ul><li>集合包括了各种常用的数据结构：List表，Set集合，Map映射等等。</li><li>封装成了一个工具类，使用者不必了解底层实现，方便使用。</li><li>从JavaSE5.0，使用了泛型，这样集合中对象的数据类型就可以被记住，使用者不用担心，把对象丢进集合中，就丢失了他的数据类型。</li></ul><h2 id="特点在哪里？"><a href="#特点在哪里？" class="headerlink" title="特点在哪里？"></a>特点在哪里？</h2><p><img src="https://img-blog.csdnimg.cn/20200415120759134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>java集合框架采用接口与实现相分离（就是面向接口编程的理念）。图中最底层的都是实现类，其他的都是接口，实现了接口中的方法，可以直接拿来用</li><li>java的集合中只能存储对象，而不能存储基本数据类型。</li><li>根据Colletion和Map框架，可以将集合分为三大类：</li></ul><table><thead><tr><th align="center"></th><th align="right"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">list集合</td><td align="right">有序集合</td><td align="center">元素可以重复</td></tr><tr><td align="center">set集合</td><td align="right">无序集合</td><td align="center">元素不可以重复</td></tr><tr><td align="center">Map集合</td><td align="right">键值对集合</td><td align="center">key是无序集合Set，value是有序集合List</td></tr></tbody></table><h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><ul><li>通过分析源码，可以看到collection集合继承了Iterable接口，这里注意是Iterable而不是Iterator。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415140320803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h2><ul><li><p><code>Iterator iterator()</code>方法是<code>Collection</code>从<code>Iterable</code>(可迭代的)接口继承下来，用于返回一个<code>Iterator</code>对象，<code>Iterator</code>也是接口，而且是集合框架的成员，他的作用不是用来存放对象，而是遍历集合中的元素，所以称之为迭代器。</p></li><li><p><strong>使用迭代器的好处：</strong><br>迭代模式是访问集合类的通用方法，只要集合类实现了Iterator接口，就可以用迭代的方式来访问集合类内部的数据，Iterator访问方式把对不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。 <code>Iterator接口屏蔽了迭代的底层实现，向用户提供了遍历Collection的统一接口</code>。</p></li><li><p><strong>为什么会有迭代器？</strong><br>如果没有使用Iterator，遍历一个数组的方法是使用索引，这种方法的缺点就是事先必须知道集合的数据结构，而且当我换了一种集合的话代码不可重用，要修改，比如我用set，就不能通过索引来遍历了。访问代码和集合是紧耦合，无法将访问逻辑从集合类和客户端代码中剥离出来，每一种集合类对应一种访问方式，代码不可重用。 </p></li><li><p>为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合， 每一种集合类返回的Iterator具体类型可能不同，Array可能返回ArrayIterator，Set可能返回SetIterator，Tree 可能返回TreeIterator，但是它们都实现了Iterator接口，因此，客户端不关心到底是哪种Iterator，它只需要获得这个 Iterator接口即可，<code>这就是面向对象的威力。 针对抽象编程的原则：对具体类的依赖性最小。</code></p></li><li><p>查看Iterable接口源码：可以看到有iterator这个方法，还有一个forEach（）方法，也就是我们所说的增强for循环，这也是javaSE5.0以后，for循环一种优雅的写法。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200415140947956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如上面所看到的，iterable接口里面，还有一个Iterator接口，点进去是这样的：这里面的方法就是日常所用到的：hasNext()，next()，remove()方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415140954694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>iterator迭代器怎么用？<br>说到底，迭代器的最大作用就是遍历集合。但是他可以在遍历的时候删除元素。注意使用的<code>remove()</code>方法是<code>Iterator</code>的，而不是<code>Collection</code>的。有<code>remove()</code>必有<code>next()</code>在前。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//向ArrayList中添加元素</span></span><br><span class="line">c.add(<span class="string">"DAQ"</span>);</span><br><span class="line">c.add(<span class="string">"LOVE"</span>);</span><br><span class="line">c.add(<span class="string">"WT"</span>);</span><br><span class="line"><span class="comment">//获取到迭代器</span></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String element=(String)it.next();</span><br><span class="line">System.Out.Println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><ul><li>List是线性表结构，包括顺序表Arraylist和链表LinkedList两种实现方式</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415144430273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><ul><li>底层数据结构是数组，线程不安全可以存放null值。因为它有扩容这一概念，可以实现动态增长，就不像原本的数组那样，长度固定不变了。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415144549588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020041514401449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>ArrayList是基于动态数组实现的，在增删的时候，需要数组的拷贝复制。</li><li>ArrayList的默认容量是10，每次扩容的时候，变为原来的1.5倍，也就是15</li><li>删除元素的时候，容量不会减少，需要减少容量的时候，要调用trimToSize（）方法。</li><li>缺点：</li></ul><ol><li>从空间分配来看，除非预知数据的确切量或者近似值，否则频繁的扩容，或者大的容量初始值都会导致时间空间的浪费。</li><li>从运算时间来看，插入和删除的效率非常低。<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3></li></ol><ul><li>底层数据结构是双向链表，采用<strong>“按需分配”</strong>的原则为每个对象分配独立的存储空间，但是线程不安全。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415150446850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>LinkedList还实现了Deque接口，我们就可以像操作栈和队列一样操作LinkedList了。</li><li>只要有了头结点，其他的数据都可以轻松获取。</li></ul><p><strong>总结：</strong> 增删多用LinkedList，查询多用ArrayList。</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><ul><li><p>相比list集合而言，Set看起来清爽多了。<br><img src="https://img-blog.csdnimg.cn/20200415151103807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>Set实现类依赖添加对象的equals（）方法检查对象的唯一性，只要两个对象使用equals比较结果为true，set就会拒绝加入此对象（哪怕他们是不同的对象），只要两个对象使用equals比较结果为false，set就会接受加入此对象（哪怕他们是相同的对象），所以在使用set时，重点就要重写equals（）方法，制定正规的比较规则。</p></li></ul><h3 id="HsahSet"><a href="#HsahSet" class="headerlink" title="HsahSet"></a>HsahSet</h3><p><img src="https://img-blog.csdnimg.cn/20200415152822770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>可以看出HashSet就是封装了HashMap，操作HashSet实际上就是在操作HashMap</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415153157522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>总结下来就是：</li></ul><ol><li>实现了Set接口，底层实际是一个HashMap实例</li><li>不保证迭代顺序，允许元素为null</li><li>非同步</li><li>初始容量影响迭代性能</li></ol><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><img src="https://img-blog.csdnimg.cn/202004151542258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200415154111297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>总结：</li></ul><ol><li>实现了NavigableSet接口，底层实际是一个TreeMap实例</li><li>可以实现排序功能</li><li>非同步</li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ul><li>归纳：</li></ul><ol><li>迭代是有序的</li><li>允许为null</li><li>底层实际上是一个HashMap+双链表实例</li><li>非同步 </li><li>与hashset相比，性能稍微差一点，因为要维护双链表</li><li>初始容量与迭代无关，LinkedHashSet迭代的是双链表</li></ol><h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><ul><li>底层是数组，线程安全</li><li>从源码中看出，他给每个方法都加上了synchronized锁，这样很消耗性能。</li><li>而且Vector初始长度是10，超过这个长度的时候，翻倍增长。这就比ArrayList更加消耗内存。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415145828218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><ul><li>为什么需要map？<br>map在java模型中称为映射，只要知道键值，就可以获取数据值。将键映射到值的对象，一个映射不能包含重复的键，每个键只能映射到一个值。</li><li>Map与Collection的区别：</li></ul><ol><li>Map集合存储元素是成对出现的，Map的键是唯一的，值是可以重复的。</li><li>Collection集合存储元素是单独出现的，set是唯一，list是可重复的。</li><li>Map数据结构针对键有效，跟值无关</li><li>Collection数据结构针对元素有效</li></ol><ul><li>Map的功能</li></ul><p><img src="https://img-blog.csdnimg.cn/2020041519240490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>散列表工作原理</li></ul><ol><li>散列表根据每个对象计算出一个整数，称之为散列码。根据计算出来的散列码，保存在对应的位置上。</li><li>在java中，散列表用链表数组实现，每个链表称为桶。</li><li>很可能有很多元素算出来的hash值（散列码）相同，这就会存储在同一个位置上，这种情况就叫做哈希冲突（散列冲突）。</li><li>但也不可能无限制装下去，在JDK1.8中，桶满时，链表会变成平衡二叉树，也就是所说的红黑树。</li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>在另一篇文章中我有单独将HashMap拿出来分析，并且分为了JDK1.7和JDK1.8时的HashMap的结构，<a href="http://daqwt.top/HashMap/">HashMap源码分析</a></li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><img src="https://img-blog.csdnimg.cn/20200415193829403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>根据源码前的注释可以得出总结:</li></ul><ol><li>TreeMap实现了NavigableMap接口，而NavigableMap接口继承SortedMap接口，这就导致TreeMap是有序的。</li><li>TreeMap底层是红黑树，时间复杂度是<code>log(n)</code></li><li>非同步的</li><li>使用Comparator和Comparable来比较Key是否相等，与排序的问题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么要用集合？因为以前用数组存储数据，因为创建数组的时候就要初始化数组的长度，由于这个长度是不可变的，这就导致两个问题：定义数组长度值太大，实际用不了那么多，就会造成内存的浪费，那定义的太小了，不够用了又得扩容，这就得不偿失了，所以这个时候，集合横空出世，相当于一个没有上限的盒子，数据直接丢进去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JSP模式&amp;&amp;MVC模式</title>
    <link href="http://daqwt.top/2199266903/"/>
    <id>http://daqwt.top/2199266903/</id>
    <published>2020-03-10T00:36:18.000Z</published>
    <updated>2020-04-17T03:13:58.975Z</updated>
    
    <content type="html"><![CDATA[<p>一个项目有一个好的设计模式很重要，有一个好的设计模式，使得开发和维护也变得简单。MVC是一种程序开发设计模式，他实现了显示模块与功能模块分离，提高了程序的可维护性，可移植性，可扩展性，可重用性，降低了程序的开发难度。</p><a id="more"></a><h2 id="JSP模式-amp-MVC模式"><a href="#JSP模式-amp-MVC模式" class="headerlink" title="JSP模式&amp;MVC模式"></a>JSP模式&amp;MVC模式</h2><ul><li>MVC=model（模型）+view（视图）+contorller（控制）</li><li>商城=仓库（模型）+店铺（视图），（控制）店铺去仓库拿货（取数据）</li></ul><p><img src="https://img-blog.csdnimg.cn/20200323093038355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200323093051579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>MVC工作机制</strong></li></ul><ol><li>用户操作，将指令送到Conntoller（控制器）。</li><li>控制器将指令和数据传递给业务模型（model）。</li><li>模型进行业务逻辑判断，数据库存取。</li><li>根据业务逻辑选择不的视图（View）展示给用户</li></ol><ul><li>MVC设计模式可以分为两种：闭环和开放，但是开放派中（controllor）的职责过重。下面是闭环的优点：</li></ul><ol><li>耦合性低，实现了用户显示模块与功能（业务逻辑）模块的分离</li><li>提高应用系统的可维护性，可扩展性，可维护性，以及模块功能的复用性。</li></ol><ul><li><strong>缺点：</strong></li></ul><ol><li>对于简单的页面来说，会增加结构的复杂性，产生过多的更新操作，降低运行效率，而且使用的时候要精心计划，由于模型和视图严格分离，给调试程序带来了一定的困难。</li><li>不适合中小应用程序，设计比较麻烦，用在中小应用上，或者改造一些工具来适应MVC，也是得不偿失的！！  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个项目有一个好的设计模式很重要，有一个好的设计模式，使得开发和维护也变得简单。MVC是一种程序开发设计模式，他实现了显示模块与功能模块分离，提高了程序的可维护性，可移植性，可扩展性，可重用性，降低了程序的开发难度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="MVC" scheme="http://daqwt.top/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://daqwt.top/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://daqwt.top/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-02-27T07:25:31.000Z</published>
    <updated>2020-05-28T08:52:01.088Z</updated>
    
    <content type="html"><![CDATA[<p>git分布式版本控制工具，在日常的开发中起到了非常重要的作用，掌握一些基本的命令也对工作效率的提高有很大的帮助，下面介绍一些基本的git操作。</p><a id="more"></a><h2 id="一、配置相关"><a href="#一、配置相关" class="headerlink" title="一、配置相关"></a>一、配置相关</h2><ul><li>配置全局帐户，该账户对所有git仓库都有效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'你的账户名称'</span></span><br><span class="line">git config --global user.email <span class="string">'你的email'</span></span><br></pre></td></tr></table></figure><ul><li>配置局部账户，该账户只对当前Git仓库有效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'你的账户名称'</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">'你的email'</span></span><br></pre></td></tr></table></figure><ul><li>查看配置情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure><h2 id="二、本地操作"><a href="#二、本地操作" class="headerlink" title="二、本地操作"></a>二、本地操作</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>1.查看变更情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>2.查看当前工作在那个分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>3.切换到指定分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 指定分支名称</span><br></pre></td></tr></table></figure><p>4.把当前目录及子目录下所有变更都加入到<code>暂存区</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>5.把仓库内所有变更都加入到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure><p>6.把指定文件添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure><p>7.创建正式的<code>commit</code>，也就是把当前更改提交，并附加描述</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"本次提交的描述"</span></span><br></pre></td></tr></table></figure><h3 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h3><p>1.比较某文件工作区和暂存区的差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 某文件</span><br></pre></td></tr></table></figure><p>2.比较某文件暂存区和HEAD的差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cache 某文件</span><br></pre></td></tr></table></figure><p>3.比较工作区和暂存区的所欲差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>4.比较暂存区和HEAD的所有差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cache</span><br></pre></td></tr></table></figure><h3 id="暂存区与工作区之间回滚"><a href="#暂存区与工作区之间回滚" class="headerlink" title="暂存区与工作区之间回滚"></a>暂存区与工作区之间回滚</h3><p>1.把工作区指定文件恢复和暂存区一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 文件1 文件2... 文件n</span><br></pre></td></tr></table></figure><p>2.把暂存区指定文件恢复和HEAD一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 文件1 文件2 ... 文件n</span><br></pre></td></tr></table></figure><p>3.把暂存区和工作区所有文件恢复和HEAD一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reaet --head</span><br></pre></td></tr></table></figure><p>4.用<code>difftool</code>比较两个<code>commit</code>的差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git difftool commit1 commit2</span><br></pre></td></tr></table></figure><p>5.查看哪些文件没有被<code>git</code>管控</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure><p>6.补充：从工作区回滚到暂存区用<code>checkout</code>， 否则用reset</p><h2 id="三、-加塞临时任务处理"><a href="#三、-加塞临时任务处理" class="headerlink" title="三、 加塞临时任务处理"></a>三、 加塞临时任务处理</h2><p>1.把未处理完的变更先保存到<code>stash</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>2.临时任务处理处理完之后继续之前的工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash pop //pop相当于出栈和入栈一样，把之前的任务弹出来</span><br><span class="line">或者</span><br><span class="line">git stash apply //与pop不同的是，apply相当于从栈顶把任务取出来，但是不会从栈中把任务移除</span><br></pre></td></tr></table></figure><p>3.查看所有<code>stash</code>的变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>4.取回某次<code>stash</code>的变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash @｛n｝</span><br></pre></td></tr></table></figure><h2 id="四、修改个人分支历史"><a href="#四、修改个人分支历史" class="headerlink" title="四、修改个人分支历史"></a>四、修改个人分支历史</h2><ul><li>仓库在每次变更执行commit的时候，会生成一个新的commit，有时候不想生成新的，只是修改一下之前的，该如何操作呢？</li></ul><p>1.修改最后一次<code>commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在工作区中修改文件 </span><br><span class="line">git add</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>2.修改第（N）次的<code>commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i N前面一个commit的id</span><br><span class="line">在工作区修改文件</span><br><span class="line">git add</span><br><span class="line">git rebase --contiue</span><br></pre></td></tr></table></figure><h2 id="五、查看变更日志"><a href="#五、查看变更日志" class="headerlink" title="五、查看变更日志"></a>五、查看变更日志</h2><p>1.当前分支的各个commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --online</span><br></pre></td></tr></table></figure><p>2.显示最近n个commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n</span><br></pre></td></tr></table></figure><p>3.用图示显示所有的历史分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --online --graph --all</span><br></pre></td></tr></table></figure><p>4.查看涉及到某文件变更的所有commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> 某文件</span><br></pre></td></tr></table></figure><p>5.某文件各行最后修改对应的commit以及作者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame 文件名</span><br></pre></td></tr></table></figure><h2 id="六、分支与标签"><a href="#六、分支与标签" class="headerlink" title="六、分支与标签"></a>六、分支与标签</h2><h3 id="①创建新分支"><a href="#①创建新分支" class="headerlink" title="①创建新分支"></a>①创建新分支</h3><p>1.基于当前分支创建新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支</span><br></pre></td></tr></table></figure><p>2.基于指定分支创建新分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支 已有分支</span><br></pre></td></tr></table></figure><p>3.基于某个commit创建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支 某个commit 的id</span><br></pre></td></tr></table></figure><p>4.创建分支并切换到该分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cheakout -b 新分支</span><br></pre></td></tr></table></figure><h3 id="②列出分支"><a href="#②列出分支" class="headerlink" title="②列出分支"></a>②列出分支</h3><p>1.列出本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>2.列出本地和远端分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p>3.列出远端所有分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv</span><br></pre></td></tr></table></figure><p>4.列出名称符合某样式的远端分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv -l <span class="string">'某样式'</span></span><br></pre></td></tr></table></figure><h3 id="③删除分支"><a href="#③删除分支" class="headerlink" title="③删除分支"></a>③删除分支</h3><p>1.安全删除本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 要删除的分支</span><br></pre></td></tr></table></figure><p>2.强制删除本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D 分支</span><br></pre></td></tr></table></figure><p>3.删除已经合并到master分支的所有本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">'^\*\| master'</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><p>4.删除远端origin已不存在的所有本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><p>5.打标签：从commit上打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 commit 的id</span><br></pre></td></tr></table></figure><h2 id="七、两分支之间的集成"><a href="#七、两分支之间的集成" class="headerlink" title="七、两分支之间的集成"></a>七、两分支之间的集成</h2><p>1.把A分支合入到当前分支，且为merge创建commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A分支</span><br></pre></td></tr></table></figure><p>2.把A分支和入到B分支，且为Merge创建commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A分支 B分支</span><br></pre></td></tr></table></figure><p>3.把当前分支基于B分支作为rebase，以便B分支合入到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B分支</span><br></pre></td></tr></table></figure><p>4.把A分支基于B分支做rebase，以便B分支合入到A分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B分支 A分支</span><br></pre></td></tr></table></figure><h2 id="八、和远端交互"><a href="#八、和远端交互" class="headerlink" title="八、和远端交互"></a>八、和远端交互</h2><p>1.列出所有的remote</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>2.增加remote</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add URL地址</span><br></pre></td></tr></table></figure><p>3.删除remote </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove remote的名称</span><br></pre></td></tr></table></figure><p>4.改变remote的名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rname 旧名称 新名称</span><br></pre></td></tr></table></figure><p>5.把远端所有分支和标签的变更都拉到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch remote</span><br></pre></td></tr></table></figure><p>6.把远端分支变更拉到本地，且merge到本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull remote名称 分支名</span><br></pre></td></tr></table></figure><p>7.把本地分支push到远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote名称 分支名</span><br></pre></td></tr></table></figure><p>8.删除远端分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push remote --delete 远端分支名</span><br><span class="line">或者</span><br><span class="line">git push remote：远端分支名</span><br></pre></td></tr></table></figure><p>9.向远端提交指定标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote 标签名</span><br></pre></td></tr></table></figure><p>10.向远端提交所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push remote --tags</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git分布式版本控制工具，在日常的开发中起到了非常重要的作用，掌握一些基本的命令也对工作效率的提高有很大的帮助，下面介绍一些基本的git操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Git" scheme="http://daqwt.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>手写链表</title>
    <link href="http://daqwt.top/3274828756/"/>
    <id>http://daqwt.top/3274828756/</id>
    <published>2020-02-26T04:15:26.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>看过很多面经，看得出来，数据结构和算法在面试中是很重要的，在之前也听说过，面试过程中，出现手撕代码的场景，而我刚好又看到链表这一章，顺便对链表做一下巩固，也打个预防针，万一真遇到要手写代码的时候，也有了一手准备。</p><a id="more"></a><h2 id="一、链表结构"><a href="#一、链表结构" class="headerlink" title="一、链表结构"></a>一、链表结构</h2><p><img src="https://img-blog.csdnimg.cn/20200325114240567.png" alt="在这里插入图片描述"></p><ul><li>每个节点结构是由数据域和指针域组成，数据域是存放数据的，而指针域存放下一结点的地址。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200325114318953.png" alt="在这里插入图片描述"></p><ul><li>但是不可能只有一个节点呀，这时候就使用 Class 来声明一个类，为类添加两个属性，一个属性是存放数据的属性data，另一个属性是存放指向下一个结点的指针属性next。这样就可以创造出多个结点实例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">   constructor(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、插入删除"><a href="#二、插入删除" class="headerlink" title="二、插入删除"></a>二、插入删除</h2><ul><li>插入到单链表的头部</li><li>插入到中间</li><li>插入到尾部</li><li>删除头部节点</li><li>删除中间节点</li><li>删除尾部节点</li></ul><h2 id="三、边界条件"><a href="#三、边界条件" class="headerlink" title="三、边界条件"></a>三、边界条件</h2><ul><li><p><strong>输入边界：</strong><br>先考虑用户输入的参数，比如传入一个链表，我们首先要判断链表是否为空，如果为空我们就不能让它执行下边的程序。再比如插入一个结点到指定结点的后边，那么你也要判断输入的结点是否为空，而且还要判断该结点是否存在该链表中。对于这些输入值的判断，就叫做输入边界。</p></li><li><p><strong>特殊边界：</strong><br>考虑到一些特殊情况，比如插入数据，我们插入数据一般考虑到插入尾部，但要是插入到头部，插入尾部的代码并不适用于插入到头部，所以呢需要考虑这种情况，删除节点也是同样要考虑这种情况。其实特殊边界最主要考虑到一些逻辑上的特殊情况。</p></li></ul><h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><p><strong>例：在链表中间增加和删除节点</strong></p><h3 id="1-定义节点："><a href="#1-定义节点：" class="headerlink" title="1. 定义节点："></a>1. 定义节点：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">       this.next = null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-增加节点："><a href="#2-增加节点：" class="headerlink" title="2. 增加节点："></a>2. 增加节点：</h3><p>①保存临时地址（4结点的地址）,需要进行遍历查找到3结点，也就是下列代码的currentNode 结点。</p><p><img src="https://img-blog.csdnimg.cn/20200325115953914.gif" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//先查找该元素</span><br><span class="line"><span class="built_in">let</span> currentNode = this.findByValue(element);</span><br><span class="line">// 保存 3 结点的下一结点地址（4 结点的地址）</span><br><span class="line"><span class="built_in">let</span> pre = currentNode.next</span><br></pre></td></tr></table></figure><p>②创建新结点，将新结点（5结点）的指针指向下一结点指针（4结点地址，已经在上一步骤保存下来了）</p><p><img src="https://img-blog.csdnimg.cn/20200325120116456.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.next = pre;</span><br></pre></td></tr></table></figure><p>③将3 的结点地址指向新结点（5结点）</p><p><img src="https://img-blog.csdnimg.cn/20200325120224691.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentNode.next = newNode;</span><br></pre></td></tr></table></figure><h3 id="3-删除节点："><a href="#3-删除节点：" class="headerlink" title="3. 删除节点："></a>3. 删除节点：</h3><p>①断开3结点的指针（断开3结点相当于让2结点直接指向4结点）<br><img src="https://img-blog.csdnimg.cn/20200325120407492.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="comment">// 用来记录 3 结点的前一结点</span></span><br><span class="line">  let preNode = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 遍历查找 3 结点</span></span><br><span class="line">  <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">         <span class="comment">// 3 结点的前一结点</span></span><br><span class="line">         preNode = currentNode;</span><br><span class="line">        <span class="comment">// 3 结点</span></span><br><span class="line">         currentNode = currentNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②让结点2的指针指向4结点，完成删除。<br><img src="https://img-blog.csdnimg.cn/20200325120504135.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preNode.next = currentNode.next;</span><br></pre></td></tr></table></figure><h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能：单链表的插入、删除、查找</span></span><br><span class="line"><span class="comment">   * 【插入】：插入到指定元素后方</span></span><br><span class="line"><span class="comment">   * 1、查找该元素是否存在？</span></span><br><span class="line"><span class="comment">   * 2、没有找到返回 -1</span></span><br><span class="line"><span class="comment">   * 3、找到进行创建结点并插入链表。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 【查找】：按值查找/按索引查找</span></span><br><span class="line"><span class="comment">   * 1、判断当前结点是否等于null，且是否等于给定值？</span></span><br><span class="line"><span class="comment">   * 2、判断是否可以找到该值？</span></span><br><span class="line"><span class="comment">   * 3、没有找到返回 -1；</span></span><br><span class="line"><span class="comment">   * 4、找到该值返回结点；</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 【删除】：按值删除</span></span><br><span class="line"><span class="comment">   * 1、判断是否找到该值？</span></span><br><span class="line"><span class="comment">   * 2、找到记录前结点，进行删除；</span></span><br><span class="line"><span class="comment">   * 3、找不到直接返回-1；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">      constructor(data)&#123;</span><br><span class="line">         <span class="keyword">this</span>.data = data;</span><br><span class="line">         <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//定义链表</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span>&#123;</span><br><span class="line">     constructor()&#123;</span><br><span class="line">         <span class="comment">//初始化头结点</span></span><br><span class="line">         <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据 value 查找结点</span></span><br><span class="line">     findByValue = (value) =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断该结点是否找到</span></span><br><span class="line">         console.log(currentNode)</span><br><span class="line">         <span class="keyword">return</span> currentNode === <span class="keyword">null</span> ? -<span class="number">1</span> : currentNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据 index 查找结点</span></span><br><span class="line">     findByIndex = (index) =&gt;&#123;</span><br><span class="line">         let pos = <span class="number">0</span>;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; pos !== index)&#123;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">             pos++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断是否找到该索引</span></span><br><span class="line">         console.log(currentNode)</span><br><span class="line">         <span class="keyword">return</span> currentNode === <span class="keyword">null</span> ? -<span class="number">1</span> : currentNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">     insert = (value,element) =&gt;&#123;</span><br><span class="line">         <span class="comment">//先查找该元素</span></span><br><span class="line">         let currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">         <span class="comment">//如果没有找到</span></span><br><span class="line">         <span class="keyword">if</span>(currentNode == -<span class="number">1</span>)&#123;</span><br><span class="line">             console.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         let newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">         newNode.next = currentNode.next;</span><br><span class="line">         currentNode.next = newNode;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//根据值删除结点</span></span><br><span class="line">     delete = (value) =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">         let preNode = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">             preNode = currentNode;</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(currentNode == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">         preNode.next = currentNode.next;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//遍历所有结点</span></span><br><span class="line">     print = () =&gt;&#123;</span><br><span class="line">         let currentNode = <span class="keyword">this</span>.head</span><br><span class="line">         <span class="comment">//如果结点不为空</span></span><br><span class="line">         <span class="keyword">while</span>(currentNode !== <span class="keyword">null</span>)&#123;</span><br><span class="line">             console.log(currentNode.data)</span><br><span class="line">             currentNode = currentNode.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看过很多面经，看得出来，数据结构和算法在面试中是很重要的，在之前也听说过，面试过程中，出现手撕代码的场景，而我刚好又看到链表这一章，顺便对链表做一下巩固，也打个预防针，万一真遇到要手写代码的时候，也有了一手准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天一道面试题" scheme="http://daqwt.top/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="链表" scheme="http://daqwt.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>git详解</title>
    <link href="http://daqwt.top/git%E8%AF%A6%E8%A7%A3/"/>
    <id>http://daqwt.top/git%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-25T08:25:03.000Z</published>
    <updated>2020-05-28T08:50:53.020Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。也是程序员最常用工具之一，连接本地仓库与github仓库，提高了开发效率，github也是开源项目宝库。</p><a id="more"></a><h2 id="git原理概述"><a href="#git原理概述" class="headerlink" title="git原理概述"></a>git原理概述</h2><ul><li>工作流程：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200325163944876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>概念：</li></ul><ol><li>Workspace：工作区</li><li>Index/Stage：暂存区</li><li>Respository：仓库区（本地仓库）</li><li>Remote：远程仓库</li></ol><ul><li>SVN与Git的区别</li></ul><ol><li><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，有时就得等很久了。</p></li><li><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li></ol><h2 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h2><p>通过git管理github托管项目代码。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><h2 id="git工作区域"><a href="#git工作区域" class="headerlink" title="git工作区域"></a>git工作区域</h2><ul><li>工作区（Working Directory）： 添加、编辑、修改文件。</li><li>暂存区 ： 暂存已经修改的文件最后统一提交到git仓库中。 留一个回旋的余地，没改好接着改，改好了再提交到仓库。</li><li>Git Repository （Git 仓库）：最终确定的文件保留到仓库，成为一个新的版本，并且对他人可见。</li></ul><h2 id="初始化配置-git"><a href="#初始化配置-git" class="headerlink" title="初始化配置 git"></a>初始化配置 git</h2><ul><li>设置用户名：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'DAQ121'</span></span><br></pre></td></tr></table></figure><ul><li>设置用户名邮箱：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">'2829025551@qq.com'</span></span><br></pre></td></tr></table></figure><ul><li>查看设置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 该设置在github仓库主页显示谁提交了该文件。</p><ul><li>创建相对应的仓库并初始化：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span>;//创建仓库</span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span>;</span><br><span class="line">git init;//初始化仓库</span><br><span class="line">操作完之后会在<span class="built_in">test</span>目录下出现一个.git的隐藏文件。这个git文件就是详细配置</span><br></pre></td></tr></table></figure><p> ##向仓库中添加文件</p><ul><li>在test仓库里新建文件a1.java</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch a1.java//所做的修改</span><br><span class="line">git status //查看是否提交到暂存区中</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200222170530502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>添加到暂存区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add a1.java</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200222170537166.png" alt="在这里插入图片描述"></p><ul><li>将文件从暂存区提交到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'add a1.java'</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200222170859545.png" alt="在这里插入图片描述"></p><h2 id="修改仓库文件"><a href="#修改仓库文件" class="headerlink" title="修改仓库文件"></a>修改仓库文件</h2><ul><li>修改后，a1.java 还要add到暂存区中。</li><li>然后再从暂存区提交到仓库。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200222172151350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="删除仓库文件"><a href="#删除仓库文件" class="headerlink" title="删除仓库文件"></a>删除仓库文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.删除文件</span><br><span class="line">rm a1.java</span><br><span class="line">2.从Git中删除文件</span><br><span class="line">git rm a1.java</span><br><span class="line">3.提交操作</span><br><span class="line">git commit -m <span class="string">'描述'</span></span><br></pre></td></tr></table></figure><p>##忽略文件.gitignore</p><ul><li><code>.gitignore</code>文件，规定哪些文件不必上传。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200516223016438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>.gitignore</code>的写法</li></ul><p><img src="https://img-blog.csdnimg.cn/20200516222813737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="git管理远程仓库"><a href="#git管理远程仓库" class="headerlink" title="git管理远程仓库"></a>git管理远程仓库</h2><ul><li>使用远程仓库的目的：<br>作用：备份，实现代码共享集中化管理。</li><li><strong>git克隆操作</strong><br>目的：将远程仓库（github对应的项目）复制到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200222174133376.png" alt="在这里插入图片描述"></p><ul><li>将仓库里的内容克隆到本地，在本地修改之后，添加到暂存区，然后在提交到仓库。</li><li><strong>将本地仓库同步到git远程仓库</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><ul><li>无法同步，没有权限怎么办？或者想要设置权限，防止乱入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi .git/config</span><br><span class="line">将[remote <span class="string">"origin"</span>]</span><br><span class="line">url = https://github.com/用户名/仓库名.git</span><br><span class="line">修改为：</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">url = https://用户名：密码@github.com/用户名/仓库名.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。也是程序员最常用工具之一，连接本地仓库与github仓库，提高了开发效率，github也是开源项目宝库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Git" scheme="http://daqwt.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git clone加速&amp;IDEA集成</title>
    <link href="http://daqwt.top/git%20clone%E5%8A%A0%E9%80%9F&amp;IDEA%E9%9B%86%E6%88%90/"/>
    <id>http://daqwt.top/git%20clone%E5%8A%A0%E9%80%9F&amp;IDEA%E9%9B%86%E6%88%90/</id>
    <published>2020-02-25T01:36:26.000Z</published>
    <updated>2020-05-28T08:51:25.860Z</updated>
    
    <content type="html"><![CDATA[<p>在github上面找好的开源项目，想要clone到本地，自己调试运行一下，但是由于github的服务器在国外，所以下载速度真的是惊人的慢，有的时候2k/s，这里就介绍一个投机取巧的方法，来加速git clone，还有IDEA集成git</p><a id="more"></a><h2 id="加速clone"><a href="#加速clone" class="headerlink" title="加速clone"></a>加速clone</h2><ol><li>注册好码云，并配置好本地仓库，保证可以从<code>gitee</code>上<code>git clone</code></li><li>在<code>github</code>上复制你要克隆的项目的<code>url</code>。在码云中选择新建仓库的<code>从github/github导入仓库</code>，选择<code>从url导入</code>。粘贴刚才<code>github</code>上的<code>URL</code>到其中，点击导入即可。</li><li>然后在从码云将项目克隆到本地。</li><li>但是现在的项目，关联的是码云，而不是github。所以就要修改配置文件。</li><li>打开项目的<code>.git</code>，找到<code>config</code>文件，找到里面的<code>url</code>关键字，修改<code>gitee</code>为<code>github</code>，即可。</li></ol><h2 id="IDEA集成git"><a href="#IDEA集成git" class="headerlink" title="IDEA集成git"></a>IDEA集成git</h2><ol><li>新建项目，绑定<code>git</code>。</li></ol><ul><li>把仓库的<code>.git</code>文件拷贝到该项目下即可，可以看到文件颜色的变化，代表文件目前的状态。红色代表未提交，绿色代表已经提交。</li></ul><ol start="2"><li>修改文件，使用IDEA操作git。</li></ol><ul><li>一些常用的操作，IDEA都有相对应的工具。也可以在IDEA的终端使用命令行操作。</li></ul><ol start="3"><li>提交测试。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在github上面找好的开源项目，想要clone到本地，自己调试运行一下，但是由于github的服务器在国外，所以下载速度真的是惊人的慢，有的时候2k/s，这里就介绍一个投机取巧的方法，来加速git clone，还有IDEA集成git&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Git" scheme="http://daqwt.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用Github</title>
    <link href="http://daqwt.top/Github/"/>
    <id>http://daqwt.top/Github/</id>
    <published>2020-02-21T08:17:10.000Z</published>
    <updated>2020-05-28T08:49:31.378Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚开始上手使用github的时候，真是一头雾水，不仅看不懂英文，而且也不懂如何使用，一番研究之后，基本了解了如何使用github的功能。要善于使用github，会给你带来不一样的惊喜。</p><a id="more"></a><h1 id="一、使用Github"><a href="#一、使用Github" class="headerlink" title="一、使用Github"></a>一、使用Github</h1><h2 id="1-1-目的"><a href="#1-1-目的" class="headerlink" title="1.1  目的"></a>1.1  目的</h2><p> 借助Github托管项目代码</p><h2 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2  基本概念"></a>1.2  基本概念</h2><ul><li>仓库（Respository）</li><li>收藏（Star） </li><li>复制克隆项目（Fork）</li><li>发起请求（Pull Request）：等待作者查看，如果他觉得不错，他会合并到自己的仓库。</li><li>关注（Watch）：你关注的人或者项目有新动态，你会收到消息。</li><li>事物卡片（Issue）：向作者发送问题，并且可以一起讨论这个问题。</li></ul><h2 id="1-3-创建仓库"><a href="#1-3-创建仓库" class="headerlink" title="1.3  创建仓库"></a>1.3  创建仓库</h2><ul><li>创建账号，验证邮箱</li><li>创建一个test仓库</li><li>readMe：详细描述</li></ul><p><img src="https://img-blog.csdnimg.cn/20200222123314231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-4-仓库管理"><a href="#1-4-仓库管理" class="headerlink" title="1.4  仓库管理"></a>1.4  仓库管理</h2><ul><li><strong>创建新文件</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200222124459789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200222124645965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>修改文件</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20200222125407532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>删除文件</strong></li></ul><p>删除之后可以进入commits查看被删除的文件。</p><ul><li><strong>上传文件</strong></li></ul><p>点击 upload选择要上传的文件，或者将文件拖动到该区域，一次可以选择上传多个文件。<br>填写标题和描述之后，点击提交，就上传完成</p><ul><li><strong>搜索文件</strong></li></ul><p>点击find file，或者按住键盘T。</p><ul><li><strong>下载 / 检出项目</strong></li></ul><p>点击克隆或者下载。</p><p><img src="https://img-blog.csdnimg.cn/20200222131226364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-5-提出问题-Issues"><a href="#1-5-提出问题-Issues" class="headerlink" title="1.5  提出问题 Issues"></a>1.5  提出问题 Issues</h2><p><strong>作用：</strong> 发现代码BUG，但是目前没有成型代码，需要讨论时用，或者使用开源项目，出现问题时用。<br><strong>使用：</strong> 发现别人的项目有bug，提交issue，填写相应的标题和描述，然后提交过去。当作者登录github的时候，可以查看问题并讨论回复，问题解决后，点击close Issue 关闭问题。两方都有关闭Issue的权限。</p><h2 id="1-6-拉取请求（Pull-Request）"><a href="#1-6-拉取请求（Pull-Request）" class="headerlink" title="1.6  拉取请求（Pull Request）"></a>1.6  拉取请求（Pull Request）</h2><p><img src="https://img-blog.csdnimg.cn/2020022213452533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;刚开始上手使用github的时候，真是一头雾水，不仅看不懂英文，而且也不懂如何使用，一番研究之后，基本了解了如何使用github的功能。要善于使用github，会给你带来不一样的惊喜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git+Maven" scheme="http://daqwt.top/categories/Git-Maven/"/>
    
    
      <category term="Git" scheme="http://daqwt.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>抽象类与接口</title>
    <link href="http://daqwt.top/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://daqwt.top/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-02-19T08:18:30.000Z</published>
    <updated>2020-05-28T08:22:12.257Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写代码的时候，我们经常实现一个接口，并实现他的方法，也就是面向接口编程，还有一种就是继承抽象类，我们不仅要会用，还要详细了解他们之间的区别。</p><a id="more"></a><h2 id="相同之处："><a href="#相同之处：" class="headerlink" title="相同之处："></a>相同之处：</h2><p>相同点：都不能被实例化,位于继承树的顶端，都包含抽象方法。</p><h2 id="不同之处："><a href="#不同之处：" class="headerlink" title="不同之处："></a>不同之处：</h2><ol><li><strong>实现：</strong> 抽象类的子类使用 extends 来继承；接口（Interface,对外提供规则）必须使用 implements 来实现接口。</li><li><strong>构造函数：</strong> 抽象类可以有构造函数，接口不能有。</li><li><strong>实现数量：</strong> 类可以实现很多个接口，但是只能继承一个抽象类。</li><li><strong>访问修饰符：</strong> 接口中的方法默认使用 public 修饰，抽象类中的方法可以是任意访问修饰符。</li></ol><h3 id="设计目的和使用方法也不同"><a href="#设计目的和使用方法也不同" class="headerlink" title="设计目的和使用方法也不同"></a>设计目的和使用方法也不同</h3><p><strong>1.设计目的：</strong></p><ul><li><p>接口体现的一种规范，类似与整个 <strong><em>系统的总纲</em></strong> ，制订了系统各模块应该遵循的标准，因此接口不应该经常改变，一旦改变对整个系统是辐射性的。</p></li><li><p>抽象类作为多个子类的共同父类，体现的是一种 <strong><em>模板式设计</em></strong> ，可以当作系统实现过程中的中间产品，已经实现了系统部分功能。</p><p><strong>2.使用不同：</strong><br>（1）接口只能包含抽象方法，抽象类可以包含普通方法。<br>（2）接口里不能定义静态方法，抽象类可以。<br>（3）接口只能定义静态常量属性不能定义普通属性，抽象类可以。</p><pre><code> （4）接口不包含构造器，抽象类可以（不是用于创建对象而是让子类完成初始化）。（5）接口里不能包含初始化块，抽象类完全可以。（6）接口多继承，抽象类但继承（只能有一个直接父类）。</code></pre></li></ul><p><strong>补充：</strong></p><ul><li>接口所有方法全是抽象方法只能 public  abstract修饰 （默认public  abstract修饰 ），属性默认public  static  final修饰。</li><li>抽象类除了包含抽象方法外与普通类无区别。<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2>1.抽象类<strong>被继承</strong>，体现的是 <strong>“is a”</strong> 的关系，抽象类中定义的是该继承体系<strong>共性</strong>功能。<br>2.接口<strong>被实现</strong>，体现的是 <strong>“like a”</strong> 的关系，接口中定义的是该继承体系的<strong>扩展</strong>功能。<br><strong>综上所述：</strong> 共性功能抽取放入抽象类中，接口相当于扩展功能，让某些···去实现。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在写代码的时候，我们经常实现一个接口，并实现他的方法，也就是面向接口编程，还有一种就是继承抽象类，我们不仅要会用，还要详细了解他们之间的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE基础知识" scheme="http://daqwt.top/categories/JavaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JavaSE" scheme="http://daqwt.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>linux安装常用环境</title>
    <link href="http://daqwt.top/2004179649/"/>
    <id>http://daqwt.top/2004179649/</id>
    <published>2020-02-16T15:11:29.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手里有一台免费的阿里云服务器是真的很香，但是我也不能让他就这样只放一个博客网站吧，于是乎，我想在这片几乎空白的区域，开拓出一块儿良好的开发环境，也顺便熟悉一下linux系统的操作。这篇主要就是讲了，如何在云服务器上安装JDK，MySql，Tomcat</p><a id="more"></a><h1 id="一、安装JDK1-8"><a href="#一、安装JDK1-8" class="headerlink" title="一、安装JDK1.8"></a>一、安装JDK1.8</h1><h2 id="①查看有无自带的JDK"><a href="#①查看有无自带的JDK" class="headerlink" title="①查看有无自带的JDK"></a>①查看有无自带的JDK</h2><ul><li>有很多linux系统自带了<code>OpenJDK</code>，<code>OpenJDK</code>不包含<code>Deployment</code>（部署）功能，源代码不完整，而且精简化，只适合个人使用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 查看有无jdk，如果有，则会出现openjdk</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line">2.查看关于java的所有文件</span><br><span class="line">rpm -qa | grep java</span><br><span class="line"></span><br><span class="line">3. 删除掉openjdk（后面跟你自己的版本进行删除）</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="②下载JDK"><a href="#②下载JDK" class="headerlink" title="②下载JDK"></a>②下载JDK</h2><ul><li>去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">ORACLE官网</a>下载对应的linux版本。记得后缀是<code>.tar.gz</code>结尾。先下载到本地，再通过工具上传到linux上。这里推荐使用的工具是finalshell。详情使用请另参考。</li></ul><h2 id="③安装JDK"><a href="#③安装JDK" class="headerlink" title="③安装JDK"></a>③安装JDK</h2><ul><li>在<code>usr/local/src</code>目录下新建一个文件夹<code>jdk</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/src/jdk</span><br></pre></td></tr></table></figure><ul><li>将本地JDK上传到这个目录下。</li><li>进入文件夹，并解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/jdk</span><br><span class="line">tar zvxf 你的压缩包</span><br></pre></td></tr></table></figure><ul><li>安装完成</li></ul><h2 id="④配置环境变量"><a href="#④配置环境变量" class="headerlink" title="④配置环境变量"></a>④配置环境变量</h2><ul><li>进入环境变量的配置文件,编辑</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><ul><li>在最下面添加以下代码：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/src/jdk/jdk1.8.0_161 （这里填写你自己的文件路径）</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><ul><li>编写完之后：<code>ESC-&gt;:wq</code>退出。</li><li>查看是否安装成功</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h1 id="二、安装Tomcat"><a href="#二、安装Tomcat" class="headerlink" title="二、安装Tomcat"></a>二、安装Tomcat</h1><h2 id="①下载tomcat"><a href="#①下载tomcat" class="headerlink" title="①下载tomcat"></a>①下载tomcat</h2><p>我下载的是Tomcat8.5，和安装JDK几乎一样的步骤，<a href="http://mirrors.ustc.edu.cn/apache/tomcat/">点击下载</a>对应的版本。</p><h2 id="②上传，解压"><a href="#②上传，解压" class="headerlink" title="②上传，解压"></a>②上传，解压</h2><ul><li>新建存放目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/src/Tomcat</span><br></pre></td></tr></table></figure><ul><li>用工具上传到该目录中。</li><li>解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> //usr/<span class="built_in">local</span>/src/Tomcat</span><br><span class="line">tar zvxf 你的安装包</span><br></pre></td></tr></table></figure><h2 id="③配置环境变量"><a href="#③配置环境变量" class="headerlink" title="③配置环境变量"></a>③配置环境变量</h2><ul><li>修改/etc/profile，加入Tomcat环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">2.加入以下代码：</span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=你的tomcat路径</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;CATALINA_HOME&#125;</span>/bin</span><br><span class="line"></span><br><span class="line">3.刷新环境变量</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="④启动tomcat"><a href="#④启动tomcat" class="headerlink" title="④启动tomcat"></a>④启动tomcat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/Tomcat/apache-tomcat-8.5.53/bin</span><br><span class="line">sh start.sh</span><br></pre></td></tr></table></figure><ul><li>查看端口号和日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查看端口号</span><br><span class="line">ss -tan</span><br><span class="line"></span><br><span class="line">2.查看日志</span><br><span class="line">tail -f ../logs/catalina.out</span><br></pre></td></tr></table></figure><h1 id="三、安装Mysql"><a href="#三、安装Mysql" class="headerlink" title="三、安装Mysql"></a>三、安装Mysql</h1><h2 id="①查看自带版本"><a href="#①查看自带版本" class="headerlink" title="①查看自带版本"></a>①查看自带版本</h2><ul><li>查看有没有<code>mysql</code>，有则卸载。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 查看</span><br><span class="line">rpm -qa | grep mysql</span><br><span class="line">2. 卸载</span><br><span class="line">rpm -e --nodeps 查出来的mysql</span><br></pre></td></tr></table></figure><h2 id="②命令下载mysql"><a href="#②命令下载mysql" class="headerlink" title="②命令下载mysql"></a>②命令下载mysql</h2><ul><li>如果直接去官网下载，不知道要等多久，于是我找到了一个<a href="http://mirrors.sohu.com/mysql/MySQL-5.6/">镜像网站</a>，点击找到你的对应版本，这里以<code>mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</code>为例</li><li>命令安装：既然找到了具体网址，那我们就用<code>wget</code>命令安装，省去上传的时间。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf mysql-5.6.44-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>创建mysql用户组及用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/mysql/support-files/my-default.cnf /etc/my.cnf</span><br><span class="line">vi my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line"></span><br><span class="line">#设置3306端口 </span><br><span class="line">port = <span class="number">3306</span>  </span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录 根据实际目录进行配置</span><br><span class="line">basedir=/usr/local/mysql </span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录 根据实际目录进行配置</span><br><span class="line">datadir=/usr/local/mysql/data </span><br><span class="line"></span><br><span class="line"># 允许最大连接数 </span><br><span class="line">max_connections=<span class="number">200</span> </span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集 </span><br><span class="line">character-set-server=utf8 </span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎 </span><br><span class="line"><span class="keyword">default</span>-storage-engine=INNODB </span><br><span class="line"></span><br><span class="line">max_allowed_packet=<span class="number">16</span>M</span><br></pre></td></tr></table></figure><ul><li>安装autoconf库，赋权并执行初始化数据库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install autoconf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql.mysql /usr/<span class="built_in">local</span>/src/mysql5.6</span><br><span class="line">/usr/<span class="built_in">local</span>/src/mysql5.6/scripts/mysql_install_db --verbose --user=mysql --defaults-file=/etc/my.cnf --datadir=/usr/<span class="built_in">local</span>/src/mysql5.6/data --basedir=/usr/<span class="built_in">local</span>/src/mysql5.6</span><br></pre></td></tr></table></figure><h2 id="③-启动msyql："><a href="#③-启动msyql：" class="headerlink" title="③ 启动msyql："></a>③ 启动msyql：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><ul><li>如果出现以下情况：请按照以下步骤来</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to start mysql.service: Unit not found.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.查询/etc/init.d/下是否存在mysql，一般都没有，如果有的话，记得备份</span><br><span class="line">ll /etc/init.d/ | grep mysql</span><br><span class="line"></span><br><span class="line">2. 到你的mysql安装目录下，查看是否有mysql.server</span><br><span class="line">find / -name mysql.server</span><br><span class="line"></span><br><span class="line">3.如果有，把他复制到/etc/init.d/mysql</span><br><span class="line">cp /usr/<span class="built_in">local</span>/src/mysql5.6/support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure><ul><li>再次启动mysql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><ul><li>查看mysql运行状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql status</span><br></pre></td></tr></table></figure><ul><li>配置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.vim ~/.bash_profile</span><br><span class="line">添加：<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/src/mysql5.6/bin</span><br><span class="line"></span><br><span class="line">2.source ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="③登录"><a href="#③登录" class="headerlink" title="③登录"></a>③登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p </span><br><span class="line">Enter password: 直接回车</span><br></pre></td></tr></table></figure><p>-出现如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.29</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="④修改密码"><a href="#④修改密码" class="headerlink" title="④修改密码"></a>④修改密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> password <span class="keyword">for</span> root@localhost = password(<span class="string">'new password'</span>);;</span><br><span class="line">new password替换成你要设置的密码</span><br><span class="line">注意:密码设置必须要大小写字母数字和特殊符号（,/<span class="string">';:等）,不然不能配置成功</span></span><br></pre></td></tr></table></figure><h2 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h2><h3 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h3><ul><li>必须要开启了3306端口才可以</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.开启端口</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent </span><br><span class="line"></span><br><span class="line">2.重启</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">3.查看是否有3306</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><h3 id="方法一：（不建议）"><a href="#方法一：（不建议）" class="headerlink" title="方法一：（不建议）"></a>方法一：（不建议）</h3><ul><li>在linux上登陆mysql，登陆成功后，依次执行命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user <span class="built_in">set</span> host = <span class="string">'%'</span> <span class="built_in">where</span> user = <span class="string">'root'</span> and host =<span class="string">'localhost'</span>; </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ul><li>并不建议对root账户进行开启远程访问权限，因为一旦拿到root权限之后，就可以对数据库执行任何操作，不安全。</li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>新建一个用户并开启远程访问权限：</li><li>登录MySQL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">grant all privileges on 库名.表名 to <span class="string">'用户名'</span>@<span class="string">'IP地址'</span> identified by <span class="string">'密码'</span> with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ul><li>详细参数解释<br><code>库名</code>要远程访问的数据库名称,所有的数据库使用<code>*</code><br><code>表名</code>    要远程访问的数据库下的表的名称，所有的表使用<code>*</code><br><code>用户名</code>    要赋给远程访问权限的用户名称（这里写一个你自己创建的用户）<br><code>IP地址</code>    可以远程访问的电脑的IP地址，所有的地址使用<code>%</code><br><code>密码</code>要赋给远程访问权限的用户对应使用的密码</li></ul><h2 id="本地连接"><a href="#本地连接" class="headerlink" title="本地连接"></a>本地连接</h2><ul><li>保证本地mysql服务是打开的，3306端口是开的。</li><li>打开sqlyong，新建连接，填入以下数据</li></ul><p><img src="https://img-blog.csdnimg.cn/20200403172306622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="大功告成！！！"><a href="#大功告成！！！" class="headerlink" title="大功告成！！！"></a>大功告成！！！</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;手里有一台免费的阿里云服务器是真的很香，但是我也不能让他就这样只放一个博客网站吧，于是乎，我想在这片几乎空白的区域，开拓出一块儿良好的开发环境，也顺便熟悉一下linux系统的操作。这篇主要就是讲了，如何在云服务器上安装JDK，MySql，Tomcat&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux学习笔记" scheme="http://daqwt.top/categories/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://daqwt.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux启动过程和目录结构</title>
    <link href="http://daqwt.top/3247955720/"/>
    <id>http://daqwt.top/3247955720/</id>
    <published>2020-02-15T15:04:41.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装好了linux系统之后，第一步当然要对linux有一个基本的了解，它有哪些特点，应用场景有哪些，为什么要用linux，了解了这些，然后在作具体深入的命令行操作。</p><a id="more"></a><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="https://img-blog.csdnimg.cn/20200401183454555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>bin</code>：存放二进制可执行文件</li><li><code>sbin</code>：存放二进制可执行文件，只有<code>root</code>才可以访问。</li><li><code>etc</code>：存放系统配置文件</li><li><code>usr</code>：用于存放共享的系统资源</li><li><code>home</code>：存放用户文件的根目录</li><li><code>root</code>：超级用户目录</li><li><code>dev</code>：用于存放设备文件</li><li><code>lib</code>：存放跟文件系统中的程序运行所需要的共享库以及内核模块</li><li><code>mnt</code>：系统管理员安装临时文件的安装点</li><li><code>boot</code>：存放用于系统引导时使用的各种文件</li><li><code>tmp</code>：用于存放各种临时文件</li><li><code>var</code>：用于存放运行时需要改变数据的文件</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><ol><li>BIOS自检</li><li>启动GRUB 2</li><li>加载内核</li><li>执行systemd进程</li><li>初始化系统环境</li></ol><h1 id="linux和windows的区别？"><a href="#linux和windows的区别？" class="headerlink" title="linux和windows的区别？"></a>linux和windows的区别？</h1><p><strong>从使用情况来看：</strong></p><ul><li>windows比较倾向于给非专业办公人士用，图形化界面使办公更方便。linux面向开发人员。</li><li>windows平台：数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 </li><li>linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。</li></ul><p><strong>从安全性上来看：</strong></p><ul><li>Windows平台：三天两头打补丁安装系统安全更新，还是会中病毒木马什么的，各位用户自己感受。 </li><li>Linux平台：要说linux没有安全问题，那当然是不可能的，不会中病毒什么的，也不可能，这一点仁者见仁智者见智，相对来说肯定比Windows平台要更加安全，使用linux你也不用装杀毒软件了。</li></ul><h1 id="linux的特点是什么？"><a href="#linux的特点是什么？" class="headerlink" title="linux的特点是什么？"></a>linux的特点是什么？</h1><ul><li><strong>稳定的系统 ：</strong>安装Linux的主机连续运行一年以上不曾宕机、不必关机是很平常的事。</li><li><strong>安全性和漏洞的快速修补 ：</strong>Linux是开发人员在使用，所以维护者众多，更新维护很快。</li><li><strong>多任务，多用户 ：</strong>你可以在一个Linux主机上规划出不同等级的用户，而且每个用户登录系统时工作环境可以不同，还可以允许不同用户在同一时间登陆主机以使用主机的资源。</li><li><strong>相对较少的系统资源占用 ：</strong>这是最吸引眼球的地方，目前市面上任何一款个人计算机都可以达到使用Linux搭建一个服务上百人以上的主机。</li><li><strong>模块化程度高：</strong>Linux的内核设计非常精巧，分成进程调度、内存管理、进程间通信、虚拟文件系统和网络接口五大部分;其独特的模块机制可根据用户的需要，实时地将某些模块插入或从内核中移走，使得Linux系统内核可以裁剪得非常小巧，很适合于嵌入式系统的需要。</li></ul><h1 id="linux可以做什么？"><a href="#linux可以做什么？" class="headerlink" title="linux可以做什么？"></a>linux可以做什么？</h1><ul><li>linux简直太适合不过做服务器了，百分之95的服务器都是基于linux平台的，我自己也有一台云服务器，搭载的就是centOS7系统，目前这个博客网站就是运行在这台云服务器上的，它可以保证一年不关机，不宕机。</li><li>当然，除此之外，作为开发人员的开发工具也是很常见的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;安装好了linux系统之后，第一步当然要对linux有一个基本的了解，它有哪些特点，应用场景有哪些，为什么要用linux，了解了这些，然后在作具体深入的命令行操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux学习笔记" scheme="http://daqwt.top/categories/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://daqwt.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04系统安装，修改源</title>
    <link href="http://daqwt.top/linux/"/>
    <id>http://daqwt.top/linux/</id>
    <published>2020-02-14T14:51:27.000Z</published>
    <updated>2020-04-14T15:03:44.318Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于疫情在家，看着家里有一台吃了一两年灰的台式电脑，大概是初三的时候买的，抹一下灰就跟新的一样，哈哈，于是突然心生一计，就开始动手整理这台电脑，首先重装系统，不过这次，我装的是win10+Ubuntu18.04双系统。</p><a id="more"></a><h1 id="一-准备："><a href="#一-准备：" class="headerlink" title="一. 准备："></a>一. 准备：</h1><ul><li><strong>终端如何复制粘贴？</strong><br>在文本区域左键复制，到终端里面直接按下鼠标滚轮即可。</li><li><strong>如何切换root权限？</strong><br>安装之后root是不设置密码的，以普通用户输入su  root按照步骤设置自己的密码</li></ul><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><ul><li>大于4G的U盘一只，事先将里面的文件备份到电脑中。</li></ul><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>下载Ubuntu系统镜像——-后缀.iso的配置文件。因为是外网，所以去官网下载需要自备**（真是把我累伤心了），于是我找到了国内的开源网站：<a href="http://mirrors.163.com/ubuntu-releases/14.04/">https://blog.csdn.net/davidhzq/article/details/102575343</a></p><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>  制作U盘启动盘—–需要下载USBWiter这个工具用来写入ISO镜像，下载地址：<a href="http://mydown.yesky.com/pcsoft/413551662.html">http://mydown.yesky.com/pcsoft/413551662.html</a><br> 解压后打开小工具：</p><p><img src="https://img-blog.csdnimg.cn/20200209220859288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p> 还要在硬盘腾出一块空间用来安装Ubuntu系统，具体操作如下：以管理的身份打开“我的电脑”，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200209221926433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200209222255142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 压缩完之后，就不用管了，会看到你刚才压缩的那个卷之后，会有一块空闲的空间。</p><h1 id="二-开始安装："><a href="#二-开始安装：" class="headerlink" title="二.开始安装："></a>二.开始安装：</h1><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><ul><li>拿着你做好的U盘，插到你要安装系统的电脑上，在开机的时候，会看到：</li></ul><p><img src="https://img-blog.csdnimg.cn/2020021012440214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如果没有的话，可能是你开机设置里不允许用U盘启动，我当时就遇到了这种情况，然后狂点F12，进入BIOS，主要是为了进入BIOS，不同型号的电脑按键不一样，自己上网查，按如下图设置后，按F10，保存并重启。<br><img src="https://img-blog.csdnimg.cn/2020021012462934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h3><p><img src="https://img-blog.csdnimg.cn/202002092238476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209223948185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209224129521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200209224527382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200209224741212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020020922495535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>后面就一步一步点击继续就可以了，最后等待安装完成</strong></p><h2 id="在安装过程中遇到的问题："><a href="#在安装过程中遇到的问题：" class="headerlink" title="在安装过程中遇到的问题："></a>在安装过程中遇到的问题：</h2><p><img src="https://img-blog.csdnimg.cn/20200210125455148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200210125505598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200210125606591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最后的最后，还是一个人抗下了所有，安装崩溃了，我心态也奔溃了，但是重振旗鼓，找到问题：GRUB的引导问题，也找到了解决方案：<a href="https://blog.csdn.net/weixin_44123547/article/details/103243238">https://blog.csdn.net/weixin_44123547/article/details/103243238</a><br>最终还是安装完成了：</p><p><img src="https://img-blog.csdnimg.cn/20200210125944723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-修改源："><a href="#三-修改源：" class="headerlink" title="三. 修改源："></a>三. 修改源：</h1><p>因为Ubuntu默认下载源是国外源，我们修改为国内源，我改的是清华的源。<br>打开终端，<strong>切换到root权限</strong>输入以下命令：</p><h2 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h2 id="2、修改sources-list文件"><a href="#2、修改sources-list文件" class="headerlink" title="2、修改sources.list文件"></a>2、修改sources.list文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi sources.list</span><br></pre></td></tr></table></figure><h2 id="3、修改源（复制进去）"><a href="#3、修改源（复制进去）" class="headerlink" title="3、修改源（复制进去）"></a>3、修改源（复制进去）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><h2 id="4、-更新源"><a href="#4、-更新源" class="headerlink" title="4、 更新源"></a>4、 更新源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>完成后，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="5、大功告成"><a href="#5、大功告成" class="headerlink" title="5、大功告成"></a>5、大功告成</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于疫情在家，看着家里有一台吃了一两年灰的台式电脑，大概是初三的时候买的，抹一下灰就跟新的一样，哈哈，于是突然心生一计，就开始动手整理这台电脑，首先重装系统，不过这次，我装的是win10+Ubuntu18.04双系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux学习笔记" scheme="http://daqwt.top/categories/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://daqwt.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>JSP&amp;EL&amp;JSTL</title>
    <link href="http://daqwt.top/1540231261/"/>
    <id>http://daqwt.top/1540231261/</id>
    <published>2020-02-11T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>JSP，EL表达式，JSTL介绍</p><a id="more"></a><h1 id="一、JSP"><a href="#一、JSP" class="headerlink" title="一、JSP"></a>一、JSP</h1><h2 id="什么是jsp？"><a href="#什么是jsp？" class="headerlink" title="什么是jsp？"></a>什么是jsp？</h2><p><strong>Java Server Page</strong>  从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.</p><h2 id="为什么会有jsp"><a href="#为什么会有jsp" class="headerlink" title="为什么会有jsp?"></a>为什么会有jsp?</h2><p>为了有更好的用户体检，更好的交互效果。因为html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。  这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码  ， <strong>jsp里面可以写java代码。</strong> </p><h2 id="jsp怎么用？"><a href="#jsp怎么用？" class="headerlink" title="jsp怎么用？"></a>jsp怎么用？</h2><h3 id="一、jsp指令"><a href="#一、jsp指令" class="headerlink" title="一、jsp指令"></a>一、jsp指令</h3><p><strong>一、page指令</strong></p><p><img src="https://img-blog.csdnimg.cn/20200229121757727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">指令写法：</span><br><span class="line">&lt;%@ 指令名字 %&gt;</span><br><span class="line"></span><br><span class="line">page指令：</span><br><span class="line">1. language：表明jsp页面中可以写java代码</span><br><span class="line"></span><br><span class="line">2. contentType：其实就是说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码</span><br><span class="line">contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">text/html  MIMEType 这是一个文本，html网页</span><br><span class="line"></span><br><span class="line">3. pageEncoding：jsp内容编码</span><br><span class="line"></span><br><span class="line">4. extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。</span><br><span class="line"></span><br><span class="line">5. import 导包使用的，一般不用手写。</span><br><span class="line"></span><br><span class="line">6. session </span><br><span class="line"> - 值可选的有<span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line"> - 用于控制在这个jsp页面里面，能够直接使用session对象。</span><br><span class="line"> - 具体的区别是，请看翻译后的java文件：</span><br><span class="line">如果该值是<span class="literal">true</span> , 那么在代码里面会有getSession（）的调用，</span><br><span class="line">如果是<span class="literal">false</span> :  那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。</span><br><span class="line"></span><br><span class="line">7. errorPage： 指的是错误的页面， 值需要给错误的页面路径</span><br><span class="line"></span><br><span class="line">8. isErrorPage：上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。</span><br></pre></td></tr></table></figure><p><strong>二、include指令</strong></p><ul><li>包含另外一个jsp的内容进来。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"other02.jsp"</span>%&gt;</span><br></pre></td></tr></table></figure><ul><li>背后细节:<br>把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。</li></ul><p><strong>三、taglib</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">""</span>  uri=<span class="string">""</span>%&gt;  </span><br><span class="line">uri: 标签库路径</span><br><span class="line">prefix : 标签库的别名</span><br></pre></td></tr></table></figure><h3 id="二、jsp动作标签（写在body里面）"><a href="#二、jsp动作标签（写在body里面）" class="headerlink" title="二、jsp动作标签（写在body里面）"></a>二、jsp动作标签（写在body里面）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">""</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">""</span> name=<span class="string">""</span>/&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- jsp:include</span><br><span class="line">&lt;jsp:include page=<span class="string">"other02.jsp"</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 </span><br><span class="line"></span><br><span class="line">- jsp:forward</span><br><span class="line">前往哪一个页面。</span><br><span class="line"> &lt;jsp:forward page=<span class="string">""</span>&gt;&lt;/jsp:forward&gt;</span><br><span class="line">等同于：请求转发</span><br><span class="line">&lt;% request.getRequestDispatcher(<span class="string">"other02.jsp"</span>).forward(request,response);%&gt;</span><br><span class="line"></span><br><span class="line">- jsp:param</span><br><span class="line">第一步：在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</span><br><span class="line">&lt;jsp:forward page=<span class="string">"other02.jsp"</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">"beijing"</span> name=<span class="string">"address"</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line"></span><br><span class="line">第二步：在other02.jsp中获取这个参数</span><br><span class="line">&lt;br&gt;收到的参数是：&lt;br&gt;</span><br><span class="line">&lt;%= request.getParameter(<span class="string">"address"</span>)%&gt;</span><br></pre></td></tr></table></figure><h2 id="jsp内置对象（重点！）"><a href="#jsp内置对象（重点！）" class="headerlink" title="jsp内置对象（重点！）"></a>jsp内置对象（重点！）</h2><p> 所谓内置对象（有九个），就是我们可以直接在jsp页面中使用这些对象。 不用创建。</p><h3 id="作用域对象"><a href="#作用域对象" class="headerlink" title="作用域对象"></a>作用域对象</h3><ul><li><strong>作用域对象有四个：</strong><ol><li><strong>pageContext</strong></li><li><strong>request</strong></li><li><strong>session</strong></li><li><strong>application</strong></li></ol></li></ul><ul><li><strong>作用域 ：</strong> 表示这些对象可以存值，他们的取值范围有限定。<br>用setAttribute   和  getAttribute来进行存取。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用作用域来存储数据&lt;br&gt;</span><br><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">取出四个作用域中的值&lt;br&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br></pre></td></tr></table></figure><ul><li>作用域范围大小：（由小到大）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageContext -- request --- session -- application</span><br></pre></td></tr></table></figure><ul><li>四个作用域的区别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11. pageContext 【PageContext】</span><br><span class="line">作用域仅限于当前的页面，还可以获取到其他八个内置对象。</span><br><span class="line"></span><br><span class="line">12. request 【HttpServletRequest】</span><br><span class="line">作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。</span><br><span class="line"></span><br><span class="line">13. session 【HttpSession】</span><br><span class="line">作用域限于一次会话（多次请求与响应） 当中。 </span><br><span class="line"></span><br><span class="line">14. application 【ServletContext】</span><br><span class="line"> 整个工程都可以访问， 服务器关闭后就不能访问了。</span><br></pre></td></tr></table></figure><h3 id="其他内置对象"><a href="#其他内置对象" class="headerlink" title="其他内置对象"></a>其他内置对象</h3><ul><li>out                 【JspWriter】</li><li>response      【HttpServletResponse】<br><img src="https://img-blog.csdnimg.cn/20200229140948897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>exception  【Throwable】</li><li>page             【Object】 —就是这个jsp翻译成的java类的实例对象</li><li>config         【ServletConfig】</li></ul><h1 id="二、EL表达式"><a href="#二、EL表达式" class="headerlink" title="二、EL表达式"></a>二、EL表达式</h1><ul><li>是为了简化jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写法格式：</span><br><span class="line"><span class="variable">$&#123;表达式 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。  一直把四个作用域取完都没有， 就没有显示。</li></ul><h3 id="EL取值方式"><a href="#EL取值方式" class="headerlink" title="EL取值方式"></a>EL取值方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. 取出4个作用域中存放的值</span><br><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">按普通手段取值：</span><br><span class="line">&lt;%= pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%= application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line"></span><br><span class="line">使用EL表达式取出作用域中的值：</span><br><span class="line"><span class="variable">$&#123; pageScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; requestScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; sessionScope.name &#125;</span></span><br><span class="line"><span class="variable">$&#123; applicationScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. 如果域中所存的是数组</span><br><span class="line">   &lt;%String [] a = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>&#125;;</span><br><span class="line">   pageContext.setAttribute(<span class="string">"array"</span>, a); %&gt;</span><br><span class="line">   </span><br><span class="line">   使用EL表达式取出作用域中数组的值：</span><br><span class="line">   <span class="variable">$&#123;array[0] &#125;</span> , <span class="variable">$&#123;array[1] &#125;</span>,<span class="variable">$&#123;array[2] &#125;</span>,<span class="variable">$&#123;array[3] &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 如果域中存的是集合</span><br><span class="line">使用EL表达式取出作用域中集合的值：</span><br><span class="line"><span class="variable">$&#123;li[0] &#125;</span> , <span class="variable">$&#123;li[1] &#125;</span>,<span class="variable">$&#123;li[2] &#125;</span>,<span class="variable">$&#123;li[3] &#125;</span></span><br><span class="line"></span><br><span class="line">4. 取出Map集合的值</span><br><span class="line">&lt;br&gt;-------------Map数据----------------&lt;br&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">   Map map = new HashMap();</span><br><span class="line">   map.put(<span class="string">"name"</span>, <span class="string">"zhangsna"</span>);</span><br><span class="line">   map.put(<span class="string">"age"</span>,18);</span><br><span class="line">   map.put(<span class="string">"address"</span>,<span class="string">"北京.."</span>);</span><br><span class="line">   map.put(<span class="string">"address.aa"</span>,<span class="string">"深圳.."</span>);</span><br><span class="line">   pageContext.setAttribute(<span class="string">"map"</span>, map);</span><br><span class="line">   %&gt;</span><br><span class="line">   </span><br><span class="line">   使用EL表达式取出作用域中Map的值：</span><br><span class="line">   <span class="variable">$&#123;map.name &#125;</span> , <span class="variable">$&#123;map.age &#125;</span> , <span class="variable">$&#123;map.address &#125;</span>  , <span class="variable">$&#123;map["address.aa"] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="取值细节"><a href="#取值细节" class="headerlink" title="取值细节"></a>取值细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.  从域中取值。  得先存值。</span><br><span class="line"></span><br><span class="line">  &lt;%  //pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">      session.setAttribute(<span class="string">"name"</span>, <span class="string">"lisi..."</span>);  %&gt;</span><br><span class="line">  </span><br><span class="line">   直接指定说了，到这个作用域里面去找这个name</span><br><span class="line">   <span class="variable">$&#123; pageScope.name &#125;</span> </span><br><span class="line"></span><br><span class="line">   //先从page里面找，没有去request找，去session，去application </span><br><span class="line">   <span class="variable">$&#123; name &#125;</span></span><br><span class="line"></span><br><span class="line">   指定从session中取值</span><br><span class="line">   <span class="variable">$&#123; sessionScope.name &#125;</span>  </span><br><span class="line"></span><br><span class="line">2. 取值方式</span><br><span class="line"></span><br><span class="line">- 如果这份值是有下标的，那么直接使用[]</span><br><span class="line">&lt;%String [] array = &#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;</span><br><span class="line">session.setAttribute(<span class="string">"array"</span>,array);  %&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123; array[1] &#125;</span> --&gt; 这里array说的是attribute的name </span><br><span class="line"></span><br><span class="line">- 如果没有下标， 直接使用 .的方式去取</span><br><span class="line">&lt;%User user = new User(<span class="string">"zhangsan"</span>,18);</span><br><span class="line">session.setAttribute(<span class="string">"u"</span>, user);  %&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123; u.name &#125;</span>  , <span class="variable">$&#123; u.age &#125;</span> </span><br><span class="line"></span><br><span class="line">3. 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。</span><br></pre></td></tr></table></figure><h3 id="EL表达式-的11个内置（隐式）对象"><a href="#EL表达式-的11个内置（隐式）对象" class="headerlink" title="EL表达式 的11个内置（隐式）对象"></a>EL表达式 的11个内置（隐式）对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">内置对象：已经存在，不用创建，可以直接获取成员变量或者属性</span><br><span class="line">用法：<span class="variable">$&#123; 对象名.成员 &#125;</span></span><br><span class="line"></span><br><span class="line">JSP相关对象</span><br><span class="line">- pageContext </span><br><span class="line"></span><br><span class="line">作用域相关对象（用的比较多）</span><br><span class="line">- pageScope</span><br><span class="line">- requestScope</span><br><span class="line">- sessionScope</span><br><span class="line">- applicationScope</span><br><span class="line"></span><br><span class="line">请求头信息相关对象</span><br><span class="line">- header</span><br><span class="line">- headerValues</span><br><span class="line"></span><br><span class="line">请求参数信息相关对象</span><br><span class="line">- param</span><br><span class="line">- paramValues</span><br><span class="line"></span><br><span class="line">Cookie</span><br><span class="line">- cookie</span><br><span class="line"></span><br><span class="line">全局初始化参数</span><br><span class="line">- initParam</span><br></pre></td></tr></table></figure><h1 id="三、-JSTL（标准标签库）"><a href="#三、-JSTL（标准标签库）" class="headerlink" title="三、 JSTL（标准标签库）"></a>三、 JSTL（标准标签库）</h1><ul><li>全称 ： JSP Standard Tag Library  ： jsp标准标签库</li><li>简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合</li></ul><h2 id="JSTL使用"><a href="#JSTL使用" class="headerlink" title="JSTL使用"></a>JSTL使用</h2><ol><li>导入jar文件到工程的WebContent/Web-Inf/lib    jstl.jar和standard.jar</li><li>在jsp页面上，使用taglib 指令，来引入标签库</li><li>注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br></pre></td></tr></table></figure><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="built_in">set</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">""</span>&gt;&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:forEach&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. c:<span class="built_in">set</span></span><br><span class="line">&lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt;</span><br><span class="line">&lt;c:<span class="built_in">set</span> var=<span class="string">"name"</span> value=<span class="string">"zhangsan"</span> scope=<span class="string">"session"</span>&gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;sessionScope.name &#125;</span></span><br><span class="line"></span><br><span class="line">2. c:<span class="keyword">if</span></span><br><span class="line"> 判断<span class="built_in">test</span>里面的表达式是否满足，如果满足，就执行c:<span class="keyword">if</span>标签中的输出 ， c:<span class="keyword">if</span> 是没有<span class="keyword">else</span>的。 </span><br><span class="line">&lt;c:<span class="built_in">set</span> var=<span class="string">"age"</span> value=<span class="string">"18"</span> &gt;&lt;/c:<span class="built_in">set</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span>&gt;</span><br><span class="line">年龄大于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &lt;= 26 &#125;</span>"</span>&gt;</span><br><span class="line">年龄小于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">定义一个变量名 flag  去接收前面表达式的值，然后存在session域中</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"<span class="variable">$&#123; age &gt; 26 &#125;</span>"</span> var=<span class="string">"flag"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">年龄大于了26岁...</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. c:forEach</span><br><span class="line">从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， </span><br><span class="line">&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"10"</span> var=<span class="string">"i"</span> step=<span class="string">"2"</span>&gt;</span><br><span class="line"><span class="variable">$&#123;i &#125;</span></span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 </span><br><span class="line">var: 遍历出来的每一个元素用user 去接收。 --&gt;</span><br><span class="line">&lt;c:forEach var=<span class="string">"user"</span> items=<span class="string">"<span class="variable">$&#123;list &#125;</span>"</span>&gt;</span><br><span class="line"><span class="variable">$&#123;user.name &#125;</span> ----<span class="variable">$&#123;user.age &#125;</span></span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSP，EL表达式，JSTL介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="JSP" scheme="http://daqwt.top/tags/JSP/"/>
    
      <category term="EL" scheme="http://daqwt.top/tags/EL/"/>
    
      <category term="JSTL" scheme="http://daqwt.top/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>区块链简单理解</title>
    <link href="http://daqwt.top/2068677160/"/>
    <id>http://daqwt.top/2068677160/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>对近年来很火的区块链的简单了解</p><a id="more"></a><h2 id="区块链是什么："><a href="#区块链是什么：" class="headerlink" title="区块链是什么："></a>区块链是什么：</h2><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。区块链（Blockchain），是比特币的一个重要概念，它本质上是一个<strong>去中心化的数据库</strong>，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。</p><h2 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h2><p>区块链起源于比特币，2008年11月1日，一位自称<strong>中本聪</strong>(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》，阐述了<strong>基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念</strong>，这标志着比特币的诞生。两个月后理论步入实践，2009年1月3日第一个序号为0的创世区块诞生。几天后2009年1月9日出现序号为1的区块，并与序号为0的创世区块相连接形成了链，标志着区块链的诞生。<br>近年来，世界对比特币的态度起起落落，但作为比特币底层技术之一的区块链技术日益受到重视。在比特币形成过程中，区块是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过<strong>随机散列(也称哈希算法)</strong> 实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链 。</p><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul><li><strong>从科技层面来看：</strong> 区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。</li><li><strong>从应用视角来看：</strong> 区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。这些特点保证了区块链的 <strong>“诚实”</strong> 与 <strong>“透明”</strong> ，为区块链创造信任奠定基础。而区块链丰富的应用场景，基本上都基于区块链能够解决信息不对称问题，实现多个主体之间的协作信任与一致行动。</li></ul><h2 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h2><ol><li><strong><em>公有区块链</em></strong>（Public Block Chains)：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上<strong>有且仅有一条</strong>该币种对应的区块链。</li><li><strong><em>行业区块链</em></strong>（Consortium Block Chains)：由某个群体<strong>内部指定</strong>多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易，但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。</li><li><strong><em>私有区块链</em></strong>（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。</li></ol><h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ol><li>去中心化。区块链技术不依赖额外的第三方管理机构或硬件设施，没有中心管制，除了自成一体的区块链本身，通过分布式核算和存储，各个节点实现了信息自我验证、传递和管理。去中心化是区块链最突出最本质的特征。</li><li>开放性。区块链技术基础是<strong>开源的</strong>，除了交易各方的私有信息被加密外，区块链的数据对所有人开放，任何人都可以通过公开的接口查询区块链数据和开发相关应用，因此整个系统信息高度透明。</li><li>独立性。基于协商一致的规范和协议(类似比特币采用的哈希算法等各种数学算法)，整个区块链系统不依赖其他第三方，所有节点能够在系统内自动安全地验证、交换数据，不需要任何人为的干预。</li><li>安全性。只要不能掌控全部数据节点的51%，就无法肆意操控修改网络数据，这使区块链本身变得相对安全，避免了主观人为的数据变更。</li><li>匿名性。除非有法律规范要求，单从技术上来讲，各区块节点的身份信息不需要公开或验证，信息传递可以<strong>匿名进行</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对近年来很火的区块链的简单了解&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链的架构模型以及核心技术</title>
    <link href="http://daqwt.top/714656305/"/>
    <id>http://daqwt.top/714656305/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><a id="more"></a><h2 id="一-架构模型"><a href="#一-架构模型" class="headerlink" title="一.架构模型"></a>一.架构模型</h2><p>一般说来，区块链系统由数据层、网络层、共识层、激励层、合约层，应用层组成。</p><ol><li><strong>数据层：</strong> 封装了底层数据区块以及相关的数据加密和时间戳等基础数据和基本算法。</li><li><strong>网络层：</strong> 则包括分布式组网机制、数据传播机制和数据验证机制等。</li><li><strong>共识层：</strong> 主要封装网络节点的各类共识算法。</li><li><strong>激励层：</strong> 将经济因素集成到区块链技术体系中来，主要包括经济激励的发行机制和分配机制等。</li><li><strong>合约层：</strong> 主要封装各类脚本、算法和智能合约，是区块链可编程特性的基础。</li><li><strong>应用层：</strong> 则封装了区块链的各种应用场景和案例。</li></ol><p><strong>区块链技术最具代表性的创新点：</strong></p><ol><li>基于时间戳的链式区块结构、分布式节点的共识机制。</li><li>基于共识算力的经济激励和灵活可编程的智能合约。</li></ol><h2 id="二-核心技术"><a href="#二-核心技术" class="headerlink" title="二.核心技术"></a>二.核心技术</h2><p> 1.<strong>分布式账本：</strong>分布式账本指的是交易记账由分布在不同地方的多个节点共同完成，而且每一个节点记录的是完整的账目，因此它们都可以参与监督交易合法性，同时也可以共同为其作证 。跟传统的分布式存储有所不同，区块链的分布式存储的独特性主要体现在两个方面：一是区块链每个节点都按照块链式结构存储完整的数据，传统分布式存储一般是将数据按照一定的规则分成多份进行存储。二是区块链每个节点存储都是独立的、地位等同的，依靠共识机制保证存储的一致性，而传统分布式存储一般是通过中心节点往其他备份节点同步数据。没有任何一个节点可以单独记录账本数据，从而避免了单一记账人被控制或者被贿赂而记假账的可能性。也由记账节点足够多，理论上讲除非所有的节点被破坏，否则账目就不会丢失，从而保证了账目数据的安全性。</p><p>2.<strong>非对称加密：</strong>存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的，只有在数据拥有者授权的情况下才能访问到，从而保证了数据的安全和个人的隐私。<br>3.<strong>共识机制</strong>就是所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡 。<br>区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。“人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。<br>4.<strong>智能合约：</strong>基于这些可信的不可篡改的数据，可以自动化的执行一些预先定义好的规则和条款。以保险为例，如果说每个人的信息（包括医疗信息和风险发生的信息）都是真实可信的，那就很容易的在一些标准化的保险产品中，去进行自动化的理赔。在保险公司的日常业务中，虽然交易不像银行和证券行业那样频繁，但是对可信数据的依赖是有增无减。因此，笔者认为利用区块链技术，从数据管理的角度切入，能够有效地帮助保险公司提高风险管理能力。具体来讲主要分投保人风险管理和保险公司的风险监督。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术的应用领域</title>
    <link href="http://daqwt.top/undefined/"/>
    <id>http://daqwt.top/undefined/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-03-27T05:25:24.977Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><a id="more"></a><h2 id="金融领域"><a href="#金融领域" class="headerlink" title="金融领域"></a>金融领域</h2><p>区块链在<strong>国际汇兑</strong>、<strong>信用证</strong>、<strong>股权登记</strong>和<strong>证券交易所</strong>等金融领域有着潜在的巨大应用价值。将区块链技术应用在金融行业中，能够省去第三方中介环节，实现<strong>点对点</strong>的直接对接，从而在大大降低成本的同时，快速完成交易支付。<br>比如Visa推出基于区块链技术的 Visa B2B Connect，它能为机构提供一种费用更低、更快速和安全的跨境支付方式来处理全球范围的企业对企业的交易。要知道传统的跨境支付需要等3-5天，并为此支付1-3%的交易费用。Visa 还联合 Coinbase 推出了首张比特币借记卡，<strong>花旗银行</strong>则在区块链上测试运行加密货币“<strong>花旗币</strong>”。</p><h2 id="物联网和物流领域"><a href="#物联网和物流领域" class="headerlink" title="物联网和物流领域"></a>物联网和物流领域</h2><p>区块链在物联网和物流领域也可以天然结合。通过区块链可以降低物流成本，追溯物品的生产和运送过程，并且提高供应链管理的效率。该领域被认为是区块链一个很有前景的应用方向。<br>区块链通过结点连接的散状网络分层结构，能够在整个网络中实现信息的全面传递，并能够检验信息的准确程度。这种特性一 定程度上提高了物联网交易的便利性和智能化。<strong>区块链</strong>+<strong>大数据</strong>的解决方案就利用了大数据的自动筛选过滤模式，在区块链中建立信用资源，可双重提高交易的安全性，并提高物联网交易便利程度。为智能物流模式应用节约时间成本。区块链结点具有十分自由的进出能力，可独立的参与或离开区块链体系，不对整个区块链体系有任何干扰。区块链 +大数据解决方案就利用了大数据的整合能力，促使物联网基础用户拓展更具有方向性，便于在智能物流的分散用户之间实现用户拓展。</p><h2 id="公共服务领域"><a href="#公共服务领域" class="headerlink" title="公共服务领域"></a>公共服务领域</h2><p>区块链在公共管理、能源、交通等领域都与民众的生产生活息息相关，但是这些领域的中心化特质也带来了一些问题，可以用区块链来改造。区块链提供的去中心化的完全分布式DNS服务通过网络中各个节点之间的点对点数据传输服务就能实现域名的查询和解析，可用于确保某个重要的基础设施的操作系统和固件没有被篡改，可以监控软件的状态和完整性，发现不良的篡改，并确保使用了物联网技术的系统所传输的数据没用经过篡改。</p><h2 id="数字版权领域"><a href="#数字版权领域" class="headerlink" title="数字版权领域"></a>数字版权领域</h2><p>通过区块链技术，可以对作品进行鉴权，证明文字、视频、音频等作品的存在，保证权属的真实、唯一性。作品在区块链上被确权后，后续交易都会进行实时记录，实现数字版权全生命周期管理，也可作为司法取证中的技术性保障。例如，美国纽约一家创业公司Mine Labs开发了一个基于区块链的元数据协议，这个名为Mediachain的系统利用IPFS文件系统，实现数字作品版权保护，主要是面向数字图片的版权保护应用。</p><h2 id="保险领域"><a href="#保险领域" class="headerlink" title="保险领域"></a>保险领域</h2><p>在保险理赔方面，保险机构负责资金归集、投资、理赔，往往管理和运营成本较高。通过智能合约的应用，既无需投保人申请，也无需保险公司批准，只要触发理赔条件，实现保单自动理赔。一个典型的应用案例就是LenderBot, 是 2016 年由区块链企业 Stratumn、德勤与支付服务商 Lemonway 合作推出，它允许人们通过 Facebook Messenger 的聊天功能，注册定制化的微保险产品， 为个人之间交换的高价值物品进行投保，而区块链在贷款合同中代替了第三方角色 。</p><h2 id="公益领域"><a href="#公益领域" class="headerlink" title="公益领域"></a>公益领域</h2><p>区块链上存储的数据，高可靠且不可篡改，天然适合用在社会公益场景。公益流程中的相关信息，如捐赠项目、募集明细、资金流向、受助人反馈等，均可以存放于区块链上，并且有条件地进行透明公开公示，方便社会监督。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>数字货币的种类</title>
    <link href="http://daqwt.top/undefined/"/>
    <id>http://daqwt.top/undefined/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-03-27T05:26:08.141Z</updated>
    
    <content type="html"><![CDATA[<p>当前的数字货币大致有以下几种。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200204160645330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>BTC：</strong> 比特币</li><li><strong>ETH：</strong> 以太币</li><li><strong>USDT：</strong> 泰达币（与同数量的美元是等值的）</li><li><strong>EOS：</strong> 为商用分布式应用设计的一款区块链操作系统。EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0 。</li><li><strong>XRP：</strong> 瑞波币。它是基于Ripple协议的虚拟货币，主要功能有二：1.防止恶意攻击；2.桥梁货币。</li><li><strong>LTC：</strong> 莱特币。<img src="https://img-blog.csdnimg.cn/20200204161448813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>HT：</strong> 火币<br><img src="https://img-blog.csdnimg.cn/20200204161631662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>HUSD：</strong> 稳定币<img src="https://img-blog.csdnimg.cn/20200204162140418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>BCH：</strong><img src="https://img-blog.csdnimg.cn/20200204162243770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前的数字货币大致有以下几种。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>比特币的两种交易方式</title>
    <link href="http://daqwt.top/2670976354/"/>
    <id>http://daqwt.top/2670976354/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>比特币的交易有很多种，本文了解一下</p><a id="more"></a><h2 id="比特币交易的几种种方式："><a href="#比特币交易的几种种方式：" class="headerlink" title="比特币交易的几种种方式："></a>比特币交易的几种种方式：</h2><p><img src="https://img-blog.csdnimg.cn/20200204170527575.png" alt="在这里插入图片描述"></p><ol><li><strong>场外交易：</strong> 也称为<strong>法币交易</strong>，法币就是<strong>法定货币</strong>，人民币就是我们国家的法定货币，顾名思义，法币交易就是由法币（人民币）直接与比特币（数字货币）进行交易的行为（购买/出售),可以简单理解为网购。</li><li><strong>场内交易：</strong> 也称之为<strong>币币交易</strong>，就是用一种币交易兑换另一种币。</li><li><strong>杠杆交易：</strong> 利用小额的资金来进行数倍于原始金额的投资。以期望获取相对投资标的物波动的数倍收益率，抑或亏损。由于保证金（该笔小额资金）的增减不以标的资产的波动比例来运动，<strong>风险很高</strong>。不推荐。</li><li><strong>合约交易：</strong> 合约交易是指交易双方，在交易所通过买卖合约，并根据约定在未来某一特定时间和地点，以特定价格买卖规定数量商品的行为。合约交易是在现货远期合约交易基础上发展起来的，在交易所内买卖标准化合约的一种新型交易方式。</li></ol><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ol><li>法币交易很耗时间，即使交易双方操作熟练，但是还是不排除人为因素造成交易时间拖长，不利于双方观察局势，很有可能在分分钟内错过行情。</li><li>币币交易可以在极短时间内成交（按下买入键的瞬间与对手成交）且支持购买的币种更多。</li></ol><p>，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比特币的交易有很多种，本文了解一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>火币网--币币交易图解</title>
    <link href="http://daqwt.top/undefined/"/>
    <id>http://daqwt.top/undefined/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-03-27T05:24:42.134Z</updated>
    
    <content type="html"><![CDATA[<p>如何在火币网上执行币币交易</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200205111557755.png" alt="在这里插入图片描述"></p><ul><li><p>BTC/USDT：BTC对USDT的交易对，相当于平均1个BTC当前需要9211.76个USDT来购买，后面的64574.43CNY是说9211.76个USDT约等于64574.43人民币。</p></li><li><p>涨幅+0.01%是今天此时此刻比特币的价格相对于昨天的这个时候价格涨了0.01%，如果是红色的-0.01%就代表跌了0.01%。</p></li><li><p>高9320.00 低9100.00是<strong>过去24小时</strong>最高9320.00USDT最低9100.00USDT。</p></li><li><p>24H量：是过去24小时火币网交易了28878个比特币。这只是在火币网交易的数量。<br><img src="https://img-blog.csdnimg.cn/2020020511252911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>上面一排时间是，选择显示这个时间段的数据，比如我选择的是1min，那么k线图中每一个红色或者绿色的柱就代表这一分钟内的走势。</p></li><li><p>时间下面的一排：11：24这个时间点的开盘价，最高价，最低价，收盘价，成交量。</p></li><li><p>MA均线：<strong>（MA）理论是股市最常见的一种技术分析方法，它对股市操作具有神奇的指导作用。</strong></p></li><li><p>绿色柱状：柱底代表开盘价，柱顶代表收盘价，红色则相反。</p></li><li><p>柱上下的细线：上影线，下影线，分别代表在这一分钟内的最高价和最低价。</p></li><li><p>图中标有今日最高，和今日最低。严谨理解为：从今日凌晨到目前为止的最高价与最低价。</p><h2 id="均线分析方法："><a href="#均线分析方法：" class="headerlink" title="均线分析方法："></a>均线分析方法：</h2></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在火币网上执行币币交易&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>比特币的价格是怎么算出来的</title>
    <link href="http://daqwt.top/2526071924/"/>
    <id>http://daqwt.top/2526071924/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><a id="more"></a><h2 id="首先了解一下拍卖"><a href="#首先了解一下拍卖" class="headerlink" title="首先了解一下拍卖"></a>首先了解一下拍卖</h2><ul><li><strong>英式拍卖：</strong> 如果拍卖方（卖方）要卖一个商品，那么买方则通过集体竞价的方式进行拍卖，价高者得，最后和卖方成交的一定只有一个买家，而这个买家一定是出价最高的那位。</li><li><strong>荷兰式拍卖：</strong> 假如有一个买家想要买一个商品，但是卖方有很多，那么卖方递减报出新的价位，最终和买方成交的一定是卖价最低的那位。</li></ul><h2 id="实际定价方式"><a href="#实际定价方式" class="headerlink" title="实际定价方式"></a>实际定价方式</h2><p>在交易所看到的一排排红色的数字和一排排绿色的数字其实就是许多的买方和许多的卖方不断报出的<strong>买进价</strong>和<strong>卖出价</strong>，价格随供求变化而不断变动。买者和卖者彼此竞争，<strong>双向拍卖</strong>，买者对想要买进的出价，通过竞争以最低价买入;卖者也互相竞争，试图以最高价格出售，然而最新成交价一定是买卖双方达成一致的那个价格。买卖双方不断成交，最新一笔的成交价就是我们看到的不断变化的价格，这就是为什么价格在一直变化的原因。报价后面的数量，即代表当前的买方或者卖方想要购买或者卖出的币的数量。买卖一旦成交，则不得反悔。在未成交以前，也可以撤单，撤单程序与买卖委托的过程基本相同。</p><h2 id="限价，市价，止盈止损"><a href="#限价，市价，止盈止损" class="headerlink" title="限价，市价，止盈止损"></a>限价，市价，止盈止损</h2><ul><li>限价：是<strong>自己设定</strong>价格进行挂单，需价格波动到设定价格并有对手愿意交易才可以成交。</li><li>市价：市价是以<strong>当前最新</strong>成交价挂单，一般马上成交。</li><li>止盈止损：止盈止损即是<strong>带有预期</strong>的未来买入或者卖出行为，比如当价格跌破某一价位时进行止损（你预期跌破此价格可能还会继续跌），或者当价格突破某一价位时进行买入（你预期价格一旦突破该价位时将会继续上涨）。</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果你是买方，想要<strong>尽快</strong>购入比特币，当然是设置买入价格与当前最低卖出价格一致，这样双方就可以达成交易了，想要尽快卖出比特币，那就设置卖出价格与当前最高买入价格一致。但是市场上的人并不是都急切的想要卖出或者买入，会带有预期的进行买入卖出报价。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>股票基本术语</title>
    <link href="http://daqwt.top/undefined/"/>
    <id>http://daqwt.top/undefined/</id>
    <published>2020-02-11T02:19:20.000Z</published>
    <updated>2020-03-27T05:24:35.641Z</updated>
    
    <content type="html"><![CDATA[<p>股票基本术语了解。</p><a id="more"></a><h1 id="A-B-H-蓝筹股-amp-债券-amp-基金"><a href="#A-B-H-蓝筹股-amp-债券-amp-基金" class="headerlink" title="A/B/H/蓝筹股&amp;债券&amp;基金"></a>A/B/H/蓝筹股&amp;债券&amp;基金</h1><ul><li><strong>A股：</strong> 人民币普通股票，由我国境内的公司发行，供境内机构、组织、或个人(不含台、港、澳投资者)以人民币认购和交易的普通股票。</li><li><strong>B股：</strong> 人民币特种股票，以人民币标明面值，<strong>以外币认购和买卖</strong>，在境内(上海、深圳)证券交易所上市交易的。B股公司的注册地和上市地都在境内。</li><li><strong>H股：</strong> 港股：即注册地在内地、上市地在香港的<strong>外资股。</strong> 在香港上市外资股就叫做H股，纽约和新加坡上市的股票分别叫做N股和S股。</li><li><strong>蓝筹股：</strong> 多指长期稳定增长的、大型的、传统工业股及金融股。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码（蓝，红，白）、其中蓝色筹码最为值钱。</li><li><strong>债券：</strong> 政府、企业、银行等债务人为筹集资金,按照法定程序发行并向债权人承诺于指定日期还本付息的有价证券。</li><li><strong>开放式基金：</strong>（Open-end Funds）又称共同基金,是指基金发起人在设立基金时，基金单位或者股份总规模不固定，可视投资者的需求，随时向投资者出售基金单位或者股份，并可以应投资者的要求赎回发行在外的基金单位或者股份的一种基金运作方式。投资者既可以通过基金销售机构买基金使得基金资产和规模由此相应的增加，也可以将所持有的基金份额卖给基金并收回现金使得基金资产和规模相应的减少。</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><p><strong>原始股：</strong> 是公司在上市之前发行的股票。在中国股市初期，在股票一级市场上以发行价向社会公开发行的企业股票。</p></li><li><p><strong>概念股：</strong> 是指具有某种特别内涵的股票，与业绩股相对而言的。业绩股需要有良好的业绩支撑。而概念股是依靠某一种题材比如资产重组概念，三通概念等支撑价格。而这一内涵通常会被当作一种选股和炒作题材，成为股市的热点。概念股是股市术语，作为一种选股的方式。相较于绩优股必须有良好的营运业绩所支撑，概念股只是以依靠相同话题，将同类型的股票列入选股标的的一种组合。由于概念股的广告效应，因此不具有任何获利的保证。</p></li><li><p><strong>权重股：</strong>（weighted stock）就是总股本巨大的上市公司股票，它的股票总数占股票市场股票总数的比重很大，权重就很大，权重股的涨跌对股票指数的影响很大。</p></li><li><p><strong>借壳上市：</strong> 是指一家私人公司（Private Company）通过把资产注入一家市值较低的已上市公司（壳，Shell），得到该公司一定程度的控股权，利用其上市公司地位，使母公司的资产得以上市。通常该壳公司会被改名。</p></li><li><p><strong>交易时间：</strong> 大多数股票的交易时间是四小时，分两个时段：周一至周五上午9：30-11：30和下午13：00至15：00</p></li><li><p><strong>交易费用：</strong> 股票的交易费用通常包括印花税，佣金，过户费，其他费用等。</p></li><li><p><strong>总市值:</strong> 是指在某特定时间内总股本数乘以当时股价得出的股票总价值。</p></li><li><p><strong>流通市值:</strong> 在某特定时间内当时可交易的流通股股数乘以当时股价得出的流通股票总价值。</p></li><li><p><strong>总股本：</strong> 包括新股发行前的股份和新发行的股份的数量的总和。</p></li><li><p><strong>市盈率：</strong> 由股价除以年度每股盈余(EPS)得出(以公司市值除以年度股东应占溢利亦可得出相同结果)。用来<strong>评估股价水平是否合理</strong>的指标之一。</p></li><li><p><strong>市净率：</strong> 每股股价与每股净资产的比率。市净率可用于<strong>投资分析</strong>，一般来说市净率较低的股票，投资价值较高，相反，则投资价值较低。</p></li><li><p><strong>基准日：</strong> 就是因股票分红或配股，而进行股价调整的那天。相应的，在这天，红利和红股会配到投资者帐号里。而在基准日前，还有股权登记日。在股权登记日前买入该股票的投资者，享有分红或配股的权利。红利和红股会在基准日打到帐号里。</p></li><li><p><strong>大盘：</strong> 指沪市的“上证综合指数”和深市的“深证成份股指数”的股票。大盘指数是运用统计学中的指数方法编制而成的，反映股市<strong>总体价格</strong>或<strong>某类股价</strong>变动和走势的指标。</p></li><li><p><strong>个股：</strong> 是一种无偿还期限的有价证券，按股票持有者可分为国家股、法人股、个人股三种。个人股（individual stock）投资资金来自个人，可以自由上市流通。</p></li><li><p><strong>涨跌幅</strong>=(现价-上一个交易日收盘价）/上一个交易日收盘价*100%</p></li><li><p><strong>委差</strong> = 委买手数－委卖手数。</p></li><li><p><strong>委比</strong> = (委买手数-委卖手数)/(委买手数+委卖手数)×100%</p></li><li><p><strong>换手率：</strong> 也称“周转率”，指在一定时间内市场中股票转手买卖的频率，是反映股票流通性强弱的指标之一。成交量/股票总流通量×100%</p></li><li><p><strong>成交额：</strong> 某只股票在一定时间内成交的股票总金额。</p></li><li><p><strong>平均成交量：</strong> 每笔交易的平均成交量，成交量/成交笔数。</p></li><li><p><strong>成交量：</strong> 包括某只股票 当天的成交股数、成交金额、换手率；狭义的也是最常用的是仅指成交股数/手数(1手=100股)；通常人们说的大盘成交量指的是成交金额。</p></li><li><p><strong>仓位：</strong> 是指投资者买入股票所耗资金占资金总量的比例。当一个投资者的所有资金都已买入股票时就称为<strong>满仓</strong>，若不持有任何股票就称为<strong>空仓</strong>。</p></li></ul><h1 id="股票操作术语"><a href="#股票操作术语" class="headerlink" title="股票操作术语"></a>股票操作术语</h1><h2 id="内盘-amp-外盘"><a href="#内盘-amp-外盘" class="headerlink" title="内盘&amp;外盘"></a>内盘&amp;外盘</h2><ul><li>内盘（S）：以买入价成交的交易，成交数量统计后加入内盘。</li><li>外盘（B）：以卖出价成交的交易。成交数量统计后加入外盘。</li><li>内盘，外盘这两个数据大体可以<strong>用来判断买卖力量的强弱</strong>。若外盘数量大于内盘，则表现买方力量较强，若内盘数量大于外盘则说明卖方力量较强。</li></ul><h2 id="洗盘-amp-盯盘"><a href="#洗盘-amp-盯盘" class="headerlink" title="洗盘&amp;盯盘"></a>洗盘&amp;盯盘</h2><ul><li>洗盘：投机者先把股价大幅度杀低，使大批小额股票投资者(<strong>散户</strong>)产生恐慌而抛售股票，然后再把股价抬高，以便乘机渔利。</li><li>盯盘：俗称看盘，是股票投资者主要的日常工作。股票市场每时每刻都在变化，股票投资者尤其是短期投资者要掌握股票市场的动向，就要观察分析股市行情的变化，即要学会盯盘。</li></ul><h2 id="做多-amp-做空"><a href="#做多-amp-做空" class="headerlink" title="做多&amp;做空"></a>做多&amp;做空</h2><ul><li><strong>做多：</strong> 指的是多仓，也可以叫利多，买入某种货币，看涨。</li><li><strong>做空：</strong> 指的是卖仓，也可以叫利空，卖出某种货币，看跌。</li></ul><h2 id="多头-amp-空头"><a href="#多头-amp-空头" class="headerlink" title="多头&amp;空头"></a>多头&amp;空头</h2><ul><li><strong>多头：</strong> 指投资者对股市看好，预计股价将会看涨，于是趁低价时买进股票，待股票上涨至某一价位时再卖出，以获取差额收益。</li><li><strong>空头：</strong> 空头是投资者和股票商认为现时股价虽然较高，但对股市前景看坏，预计股价将会下跌，于是把借来的股票或者是原有持仓及时卖出（<strong>补空</strong>），待股价跌至某一价位时再买进，以获取差额收益。</li></ul><h2 id="涨停-amp-跌停"><a href="#涨停-amp-跌停" class="headerlink" title="涨停&amp;跌停"></a>涨停&amp;跌停</h2><ul><li>涨跌停板：是证券管理部门为了<strong>防止过度的投机</strong>而采取的一种措施，是指一只个股每天的最大涨跌幅度不能超过前一交易日的百分比。普通的股票最大涨跌幅为前一交易日的10%。<strong>新股上市首日不设涨跌幅限制</strong>。</li></ul><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p> 熔断机制（Circuit Breaker），也叫自动停盘机制，是指当股指波幅达到某设定条件（熔断点）时，交易所为控制风险采取的暂停交易措施，<strong>不同于涨跌停板</strong>；例如，新股上市首日的规定：</p><ul><li>深交所：新股首日盘中成交价较开盘价首次上涨或下跌达到或超过10%即暂停交易，新股首日换手率超50%触发暂停交易。</li><li>上交所：新股首日盘中成交价较开盘价首次上涨或下跌达到10%暂停交易30分钟。达到20%，停牌到14时55分，首日换手率超80%触发暂停交易。</li></ul><h2 id="回档-amp-反弹"><a href="#回档-amp-反弹" class="headerlink" title="回档&amp;反弹"></a>回档&amp;反弹</h2><ul><li>回档：股价呈不断上涨趋势，终因股价上涨速度过快而反转回跌到某一价位，这一调整现象称为回档。一般来说，股票的回档幅度要比上涨幅度小，通常是反转回跌到前一次上涨幅度的三分之一左右时又恢复原来上涨趋势。</li><li>反弹：股价呈不断下跌趋势，终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。一般来说，股票的反弹幅度要比下跌幅度小，通常是反弹到前一次下跌幅度的三分之一左右时，又恢复原来的下跌趋势。</li></ul><h2 id="跳空-amp-补空"><a href="#跳空-amp-补空" class="headerlink" title="跳空&amp;补空"></a>跳空&amp;补空</h2><ul><li>跳空：指受强烈利多或利空消息刺激，股价开始大幅度跳动。跳空通常在股价大变动的开始或结束前出现。</li><li>补空：是空头买回以前卖出的股票的行为。</li></ul><h2 id="阻力线-amp-支撑线"><a href="#阻力线-amp-支撑线" class="headerlink" title="阻力线&amp;支撑线"></a>阻力线&amp;支撑线</h2><ul><li>阻力线：股市受利多信息的影响，股价上涨至某一价格时，做多头的认为有利可图，但实际却有大量卖出，使股价至此停止上升，甚至出现回跌。股市上一般将这种遇到阻力时的价位称为关卡，股价上升时的关卡称为阻力线。<strong>（大量卖出抑制了价格继续攀升）</strong></li><li>支撑线：股市受利空信息的影响，股价跌至某一价位时，做空头的认为有利可图，大量买进股票，使股价不再下跌，甚至出现回升趋势。股价下跌时的关卡称为支撑线。<strong>（大量买入支撑起股价，由跌转升）</strong></li></ul><h2 id="金叉-amp-死叉"><a href="#金叉-amp-死叉" class="headerlink" title="金叉&amp;死叉"></a>金叉&amp;死叉</h2><ul><li>黄金交叉：指短期移动平均线向上穿过中期移动平均线或短期、中期移动平均线同时向上穿过长期移动平均线的走势图形，表示股价将继续上升。</li><li>死亡交叉(死叉)：指下降中的短期移动平均线由上而下穿过下降的长期移动平均线，这个时候支撑线被向下跌破，表示股价将继续下落。<br><img src="https://img-blog.csdnimg.cn/20200206150617607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ul><li>在股票名称前冠以“ST”的股票表示该上市公司最近两年连续亏损，或亏损一年，但净资产跌破面值、公司经营过程中出现重大违法行为等情况之一，交易所对该公司股票交易进行特别处理。股票交易日涨跌幅限制5%。</li><li><strong>F10：</strong> 股票非行情类的基本面资料统称为股票F10。在各种金融行情终端软件中，用户通过键盘上的F10快捷键，可迅速查看上市公司的非行情信息，诸如：公司概况、财务数据、公司公告、公司新闻、经营分析等等信息数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;股票基本术语了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链+比特币" scheme="http://daqwt.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    
      <category term="区块链，比特币" scheme="http://daqwt.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>客户端会话技术：Cookie</title>
    <link href="http://daqwt.top/887317365/"/>
    <id>http://daqwt.top/887317365/</id>
    <published>2020-02-09T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由客户端计算机暂时或永久保存的信息。</p><a id="more"></a><h2 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h2><ul><li><strong>概述：</strong> 一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据</li><li><strong>应用场景：</strong> 自动登录、浏览记录、购物车。</li><li><strong>为什么要有这个Cookie：</strong>  http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 <strong>[自动登录]</strong>，其实从公司层面讲，就是为了更好的收集用户习惯 <strong>[大数据]</strong>。</li></ul><h2 id="如何使用Cookie"><a href="#如何使用Cookie" class="headerlink" title="如何使用Cookie"></a>如何使用Cookie</h2><h3 id="发送Cookie给客户端"><a href="#发送Cookie给客户端" class="headerlink" title="发送Cookie给客户端"></a>发送Cookie给客户端</h3><ol><li>在响应的时候，添加cookie</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(<span class="string">"aa"</span>, <span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">//给响应，添加一个cookie</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><ol start="2"><li>客户端收到的信息里面，响应头中多了一个字段 Set-Cookie</li></ol><p><img src="https://img-blog.csdnimg.cn/20200228143218378.png" alt="在这里插入图片描述"></p><h3 id="获取客户端带过来的Cookie"><a href="#获取客户端带过来的Cookie" class="headerlink" title="获取客户端带过来的Cookie"></a>获取客户端带过来的Cookie</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取客户端带过来的cookie</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != null)&#123;</span><br><span class="line"><span class="keyword">for</span> (Cookie c : cookies) &#123;</span><br><span class="line">String cookieName = c.getName();</span><br><span class="line">String cookieValue = c.getValue();</span><br><span class="line">System.out.println(cookieName + <span class="string">" = "</span>+ cookieValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。</span><br><span class="line">//expiry： 有效 以秒计算。</span><br><span class="line">//正值： 表示 在这个数字过后，cookie将会失效。</span><br><span class="line">//负值： 关闭浏览器，那么cookie就失效， 默认值是 -1</span><br><span class="line">cookie.setMaxAge(60 * 60 * 24 * 7);</span><br><span class="line"></span><br><span class="line">//赋值新的值</span><br><span class="line">cookie.setValue(newValue);</span><br><span class="line"></span><br><span class="line">//用于指定只有请求了指定的域名，才会带上该cookie</span><br><span class="line">cookie.setDomain(<span class="string">".itheima.com"</span>);</span><br><span class="line"></span><br><span class="line">//只有访问该域名下的cookieDemo的这个路径地址才会带cookie</span><br><span class="line">cookie.setPath(<span class="string">"/CookieDemo"</span>);</span><br></pre></td></tr></table></figure><h2 id="典型案例："><a href="#典型案例：" class="headerlink" title="典型案例："></a>典型案例：</h2><h3 id="显示最近访问的时间"><a href="#显示最近访问的时间" class="headerlink" title="显示最近访问的时间"></a>显示最近访问的时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1. 判断账号是否正确</span><br><span class="line">2. 如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。</span><br><span class="line">3. 如果找到的对象为空，表明是第一次登录。那么要添加cookie</span><br><span class="line">4. 如果找到的对象不为空， 表明不是第一次登录。 </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"admin"</span>.equals(userName) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">//获取cookie last-name --- &gt;</span><br><span class="line">Cookie [] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">//从数组里面找出我们想要的cookie</span><br><span class="line">Cookie cookie = CookieUtil.findCookie(cookies, <span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">//是第一次登录，没有cookie</span><br><span class="line"><span class="keyword">if</span>(cookie == null)&#123;</span><br><span class="line"></span><br><span class="line">Cookie c = new Cookie(<span class="string">"last"</span>, System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line">c.setMaxAge(60*60); //一个小时</span><br><span class="line">response.addCookie(c);</span><br><span class="line"></span><br><span class="line">response.getWriter().write(<span class="string">"欢迎您, "</span>+userName);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">//1. 去以前的cookie第二次登录，有cookie</span><br><span class="line">long lastVisitTime = Long.parseLong(cookie.getValue());</span><br><span class="line"></span><br><span class="line">//2. 输出到界面，</span><br><span class="line">response.getWriter().write(<span class="string">"欢迎您, "</span>+userName +<span class="string">",上次来访时间是："</span>+new Date(lastVisitTime));</span><br><span class="line"></span><br><span class="line">//3. 重置登录的时间</span><br><span class="line">cookie.setValue(System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">response.getWriter().write(<span class="string">"登陆失败 "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示商品浏览记录"><a href="#显示商品浏览记录" class="headerlink" title="显示商品浏览记录"></a>显示商品浏览记录</h3><p><img src="https://img-blog.csdnimg.cn/20200228173445822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>jsp</strong><br>Java Server Pager —&gt; 最终会翻译成一个类， 就是一个Servlet</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jsp中写java代码：</span><br><span class="line">&lt;%</span><br><span class="line">只能写java代码</span><br><span class="line">%&gt;</span><br><span class="line">定义全局变量:</span><br><span class="line">&lt;%! int a = 99; %&gt;</span><br><span class="line"></span><br><span class="line">定义局部变量:</span><br><span class="line">&lt;% int b = 999; %&gt;</span><br><span class="line"></span><br><span class="line">在jsp页面上，显示 a 和 b的值:</span><br><span class="line">&lt;%=a %&gt; </span><br><span class="line">&lt;%=b %&gt;</span><br></pre></td></tr></table></figure><p><strong>删除浏览记录</strong><br><img src="https://img-blog.csdnimg.cn/2020022818005011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>清除浏览记录</strong></p><ul><li>其实就是清除Cookie， 删除cookie是没有什么delete方法的。只有设置maxAge 为0 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(<span class="string">"history"</span>,<span class="string">""</span>);</span><br><span class="line">cookie.setMaxAge(0); //设置立即删除</span><br><span class="line">cookie.setPath(<span class="string">"/CookieDemo02"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.服务器给客户端发送过来的一小份数据，并且存放在客户端上。</p><p>2.获取cookie， 添加cookie</p><pre><code>request.getCookie();response.addCookie();</code></pre><p>3.Cookie分类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">会话Cookie</span><br><span class="line">默认情况下，关闭了浏览器，那么cookie就会消失。</span><br><span class="line"></span><br><span class="line">持久Cookie</span><br><span class="line">在一定时间内，都有效，并且会保存在客户端上。 </span><br><span class="line">cookie.setMaxAge(0); //设置立即删除</span><br><span class="line">cookie.setMaxAge(100); //100 秒</span><br></pre></td></tr></table></figure><p>4.Cookie的安全问题。<br>由于Cookie会保存在客户端上，所以有安全隐患问题。  还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 —&gt; <strong>Session .</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由客户端计算机暂时或永久保存的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="Cookie" scheme="http://daqwt.top/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>服务器端会话技术：Session</title>
    <link href="http://daqwt.top/3004142873/"/>
    <id>http://daqwt.top/3004142873/</id>
    <published>2020-02-09T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。他是用来解决Cookie带来的安全问题。</p><a id="more"></a><h2 id="一、Session概述"><a href="#一、Session概述" class="headerlink" title="一、Session概述"></a>一、Session概述</h2><ul><li>会话 ， Session是基于Cookie的一种会话机制。 </li><li>Cookie是服务器返回一小份数据给客户端。并且存放在客户端上。 </li><li>Session是，数据存放在服务器端。</li></ul><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//得到会话ID</span><br><span class="line">String id = session.getId();</span><br><span class="line"></span><br><span class="line">//存值</span><br><span class="line">session.setAttribute(name, value);</span><br><span class="line"></span><br><span class="line">//取值</span><br><span class="line">session.getAttribute(name);</span><br><span class="line"></span><br><span class="line">//移除值</span><br><span class="line">session.removeAttribute(name);</span><br></pre></td></tr></table></figure><h2 id="三、Session的创建与销毁。"><a href="#三、Session的创建与销毁。" class="headerlink" title="三、Session的创建与销毁。"></a>三、Session的创建与销毁。</h2><ul><li>创建<br>如果有在servlet里面调用了 request.getSession()</li><li>销毁<br>session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。</li></ul><ol><li>关闭服务器</li><li>session会话时间过期。 有效期过了，默认有效期： 30分钟。</li></ol><h2 id="四、移除Session中的元素"><a href="#四、移除Session中的元素" class="headerlink" title="四、移除Session中的元素"></a>四、移除Session中的元素</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//强制干掉会话，里面存放的任何数据就都没有了。</span><br><span class="line">session.invalidate();</span><br><span class="line"></span><br><span class="line">//从session中移除某一个数据</span><br><span class="line">session.removeAttribute(<span class="string">"cart"</span>);</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>Session： 也是基于cookie的一种会话技术，  数据存放存放在服务器端。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。 </span><br><span class="line">setAttribute 存数据</span><br><span class="line">getAttribute 取数据</span><br><span class="line">removeAttribute  移除数据</span><br><span class="line">getSessionId();  获取会话id</span><br><span class="line">invalidate() 强制让会话失效。</span><br></pre></td></tr></table></figure><ul><li>创建和销毁<br>  调用<strong>request.getSesion</strong>创建<br>   服务器关闭 ， 会话超时（30分）</li></ul><ul><li>setAttribute 存放的值， 在浏览器关闭后，依然不会丢失！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。他是用来解决Cookie带来的安全问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="Session" scheme="http://daqwt.top/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>Http协议&amp;C/S通讯抓包</title>
    <link href="http://daqwt.top/678909362/"/>
    <id>http://daqwt.top/678909362/</id>
    <published>2020-02-08T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.991Z</updated>
    
    <content type="html"><![CDATA[<p>http协议：针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 规定了客户端在访问服务器端的时候,服务器端返回数据的时候，要带上什么东西。</p><a id="more"></a><h1 id="一、Http协议"><a href="#一、Http协议" class="headerlink" title="一、Http协议"></a>一、Http协议</h1><ul><li>什么是协议？<br>双方在交互、通讯的时候， 遵守的一种规范、规则。</li><li>http协议概述<br>针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 </li><li>版本<br> 1.0：请求数据，服务器返回后， 将会断开连接。<br> 1.1：请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。</li></ul><h1 id="二、演示客户端-如何-与服务器端通讯。"><a href="#二、演示客户端-如何-与服务器端通讯。" class="headerlink" title="二、演示客户端 如何 与服务器端通讯。"></a>二、演示客户端 如何 与服务器端通讯。</h1><p>问题： 在地址栏中键入网络地址 回车  或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据？</p><ul><li><p>安装抓包工具 HttpWatch (IE插件)</p></li><li><p>打开tomcat. 输入localhost:8080 打开首页</p></li><li><p>在首页上找到Example—&gt;选择 Servlet Examples—&gt; Request Parameter</p></li><li><p>接着点击Request  Parameters 的 Execute超链接，会出现请求参数示例</p></li><li><p>执行tomcat的例子，然后查看浏览器和 tomcat服务器的对接细节</p></li></ul><h1 id="三、Http请求数据解释"><a href="#三、Http请求数据解释" class="headerlink" title="三、Http请求数据解释"></a>三、Http请求数据解释</h1><ul><li><strong>请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体</strong></li><li>请求行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 </span><br><span class="line"></span><br><span class="line">POST ： 请求方式 ，以post去提交数据</span><br><span class="line"></span><br><span class="line">/examples/servlets/servlet/RequestParamExample</span><br><span class="line">请求的地址路径 ， 就是要访问哪个地方。</span><br><span class="line"></span><br><span class="line">HTTP/1.1 协议版本</span><br></pre></td></tr></table></figure><ul><li>请求头：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*</span><br><span class="line">Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 31</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">Accept: 客户端向服务器端表示，我能支持什么类型的数据。 </span><br><span class="line">Referer ： 真正请求的地址路径，全路径</span><br><span class="line">Accept-Language: 支持语言格式</span><br><span class="line">User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 </span><br><span class="line">Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据</span><br><span class="line">Accept-Encoding： gzip, deflate ： 压缩算法 。 </span><br><span class="line">Host ： 主机地址</span><br><span class="line">Content-Length： 数据长度</span><br><span class="line">Connection : Keep-Alive 保持连接</span><br><span class="line">Cache-Control ： 对缓存的操作</span><br></pre></td></tr></table></figure><ul><li>请求体：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浏览器真正发送给服务器的数据 </span><br><span class="line"></span><br><span class="line">发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp;</span><br><span class="line"></span><br><span class="line">firstname=zhang&amp;lastname=sansan</span><br></pre></td></tr></table></figure><h1 id="四、Http响应数据解析"><a href="#四、Http响应数据解析" class="headerlink" title="四、Http响应数据解析"></a>四、Http响应数据解析</h1><ul><li><strong>请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html;charset=ISO-8859-1</span><br><span class="line">Content-Length: 673</span><br><span class="line">Date: Fri, 17 Feb 2017 02:53:02 GMT</span><br><span class="line"></span><br><span class="line">...这里还有很多数据...</span><br></pre></td></tr></table></figure><ul><li>响应行：第一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">协议版本  </span><br><span class="line">状态码 </span><br><span class="line">咱们这次交互到底是什么样结果的一个code. </span><br><span class="line">200 : 成功，正常处理，得到数据。</span><br><span class="line">403  : <span class="keyword">for</span> bidden  拒绝</span><br><span class="line">404 ： Not Found</span><br><span class="line">500 ： 服务器异常</span><br><span class="line">OK</span><br><span class="line">对应前面的状态码</span><br></pre></td></tr></table></figure><ul><li>响应头</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server:  服务器是哪一种类型。  Tomcat</span><br><span class="line">Content-Type ： 服务器返回给客户端你的内容类型</span><br><span class="line">Content-Length ： 返回的数据长度</span><br><span class="line">Date ： 通讯的日期，响应的时间</span><br></pre></td></tr></table></figure><h1 id="五、Get-和-Post请求区别"><a href="#五、Get-和-Post请求区别" class="headerlink" title="五、Get 和  Post请求区别"></a>五、Get 和  Post请求区别</h1><ul><li>post</li></ul><ol><li>数据是以流的方式写过去，不会在地址栏上面显示。  现在一般提交数据到服务器使用的都是POST。</li><li>以流的方式写数据，所以数据没有大小限制。</li></ol><ul><li>get</li></ul><ol><li>会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET。</li><li>能够带的数据有限， 1kb大小。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;http协议：针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 规定了客户端在访问服务器端的时候,服务器端返回数据的时候，要带上什么东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="Http协议" scheme="http://daqwt.top/tags/Http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Servlet学习笔记</title>
    <link href="http://daqwt.top/441652674/"/>
    <id>http://daqwt.top/441652674/</id>
    <published>2020-02-08T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>java Web离不开Servlet，它其实就是一个java程序，运行在我们的web服务器上，用于<strong>接收和响应</strong> 客户端的http请求。 </p><a id="more"></a><h2 id="一、Web资源介绍"><a href="#一、Web资源介绍" class="headerlink" title="一、Web资源介绍"></a>一、Web资源介绍</h2><ul><li><strong>在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。</strong></li><li>有两种分类：</li><li>静态资源：html 、 js、 css</li><li>动态资源：servlet/jsp</li></ul><h2 id="二、Servlet介绍"><a href="#二、Servlet介绍" class="headerlink" title="二、Servlet介绍"></a>二、Servlet介绍</h2><ul><li><strong>servlet是什么?</strong><ol><li>其实就是一个java程序，运行在我们的web服务器上，用于<strong>接收和响应</strong> 客户端的http请求。 </li><li>更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet</li></ol></li></ul><h2 id="三、Selvlet简单使用Web工程"><a href="#三、Selvlet简单使用Web工程" class="headerlink" title="三、Selvlet简单使用Web工程"></a>三、Selvlet简单使用Web工程</h2><ol><li><p>得写一个Web工程 ， 要有一个服务器。</p></li><li><p>测试运行Web工程：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">得写一个Web工程 ， 要有一个服务器。</span><br><span class="line">测试运行Web工程</span><br><span class="line">1. 新建一个类， 实现Servlet接口`public class HelloServlet implements Servlet&#123;&#125;`</span><br><span class="line"></span><br><span class="line">2. 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。</span><br><span class="line">在webContent/WEB-INF/web.xml里面写上以下内容：</span><br><span class="line"></span><br><span class="line">  &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.itheima.servlet.HelloServlet --&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- 注册servlet的映射。  servletName : 找到上面注册的具体servlet，  url-pattern: 在地址栏上的path 一定要以/打头 --&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/a&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">3. 在地址栏上输入 http://localhost:8080/项目名称/a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200226115856385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、Servlet执行过程"><a href="#四、Servlet执行过程" class="headerlink" title="四、Servlet执行过程"></a>四、Servlet执行过程</h2><p><img src="https://img-blog.csdnimg.cn/20200226120652999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="五、Servlet的通用写法"><a href="#五、Servlet的通用写法" class="headerlink" title="五、Servlet的通用写法"></a>五、Servlet的通用写法</h2><ul><li>实现Servlet接口，但接口里的方法很多，有些用不到。</li></ul><ol><li>Servlet (接口)        </li><li>GenericServlet    </li><li>HttpServlet （用于处理http的请求）</li></ol><ul><li>定义一个类，继承HttpServlet ,复写doGet 和 doPost</li></ul><p><img src="https://img-blog.csdnimg.cn/20200226124900942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="六、Servlet的生命周期方法"><a href="#六、Servlet的生命周期方法" class="headerlink" title="六、Servlet的生命周期方法"></a>六、Servlet的生命周期方法</h2><ul><li>生命周期： 从创建到销毁的一段时间</li><li>生命周期方法： 从创建到销毁，所调用的那些方法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. init方法</span><br><span class="line">在创建该servlet的实例时，就执行该方法。</span><br><span class="line">一个servlet只会初始化一次， init方法只会执行一次</span><br><span class="line">默认情况下是 ： 初次访问该servlet，才会创建实例。 </span><br><span class="line"></span><br><span class="line">2.service方法</span><br><span class="line">只要客户端来了一个请求，那么就执行这个方法了。</span><br><span class="line">该方法可以被执行很多次。 一次请求，对应一次service方法的调用</span><br><span class="line"></span><br><span class="line">3.destroy方法</span><br><span class="line">servlet销毁的时候，就会执行该方法</span><br><span class="line">1. 该项目从tomcat的里面移除。</span><br><span class="line">  2. 正常关闭tomcat就会执行 shutdown.bat</span><br><span class="line"></span><br><span class="line">4. doGet 和 doPost不算生命周期方法。</span><br><span class="line">所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。</span><br><span class="line">``` </span><br><span class="line"><span class="comment">## 七、让Servlet创建实例的时机提前。</span></span><br><span class="line">1. 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 </span><br><span class="line"></span><br><span class="line">2. 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 为了提升用户的体验，需要让这个初始化的时机提前一点。 </span><br><span class="line"></span><br><span class="line">3. 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt;</span><br><span class="line">&lt;load-on-startup&gt;2&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure><h2 id="八、ServletConfig"><a href="#八、ServletConfig" class="headerlink" title="八、ServletConfig"></a>八、ServletConfig</h2><ul><li><strong>Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 得到servlet配置对象 专门用于在配置servlet的信息</span></span><br><span class="line">ServletConfig config = getServletConfig();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到的是配置servlet里面servlet-name 的文本内容</span></span><br><span class="line">String servletName = config.getServletName();</span><br><span class="line">System.out.println(<span class="string">"servletName="</span>+servletName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 可以获取具体的某一个参数。 </span></span><br><span class="line">String address = config.getInitParameter(<span class="string">"address"</span>);</span><br><span class="line">System.out.println(<span class="string">"address="</span>+address);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取所有的参数名称</span></span><br><span class="line">Enumeration&lt;String&gt; names = config.getInitParameterNames();</span><br><span class="line"><span class="comment">//遍历取出所有的参数名称</span></span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">String key = (String) names.nextElement();</span><br><span class="line">String value = config.getInitParameter(key);</span><br><span class="line">System.out.println(<span class="string">"key==="</span>+key + <span class="string">"   value="</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数在哪里配置？在web.xml中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;aa&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;com.daq.servlet.HelloServletConfig&lt;/servlet-class&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 可以添加初始化参数 --&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;adress&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;bejing&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;HelloServlet02&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/HelloServlet02&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="九、为什么需要有ServletConfig？"><a href="#九、为什么需要有ServletConfig？" class="headerlink" title="九、为什么需要有ServletConfig？"></a>九、为什么需要有ServletConfig？</h2><ol><li><p>未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。做成了jar包，它的代码放置在了自己的servlet类里面。 </p></li><li><p>刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params</p></li><li><p>在开发当中比较少用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java Web离不开Servlet，它其实就是一个java程序，运行在我们的web服务器上，用于&lt;strong&gt;接收和响应&lt;/strong&gt; 客户端的http请求。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="Servlet" scheme="http://daqwt.top/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>XML学习</title>
    <link href="http://daqwt.top/4122240603/"/>
    <id>http://daqwt.top/4122240603/</id>
    <published>2020-02-08T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XML:  extendsible  markup  labguage  可扩展的标记语言</strong></p><a id="more"></a><h2 id="一、XML的作用？"><a href="#一、XML的作用？" class="headerlink" title="一、XML的作用？"></a>一、XML的作用？</h2><ol><li>可以用来保存数据（数据多的时候用数据库，少量时候用XML）</li><li>可以用来做配置文件</li><li>数据传输载体</li></ol><h2 id="二、XML文档结构-倒状树形结构"><a href="#二、XML文档结构-倒状树形结构" class="headerlink" title="二、XML文档结构_倒状树形结构"></a>二、XML文档结构_倒状树形结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;stus&gt;</span><br><span class="line">&lt;stu&gt;</span><br><span class="line">&lt;name&gt;daiaoqi&lt;/name&gt;</span><br><span class="line">&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">&lt;desc&gt;我要学编程&lt;/desc&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;stu&gt;</span><br><span class="line">&lt;name&gt;wt&lt;/name&gt;</span><br><span class="line">&lt;age&gt;20&lt;/age&gt;</span><br><span class="line">&lt;desc&gt;我要找工作&lt;/desc&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure><h2 id="三、文档定义-amp-声明"><a href="#三、文档定义-amp-声明" class="headerlink" title="三、文档定义&amp;声明"></a>三、文档定义&amp;声明</h2><ul><li>定义：其实就是一个文件，文件的后缀为 <strong>.xml</strong></li><li>声明：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"gbk"</span> standalone=<span class="string">"no"</span> ?&gt;</span><br><span class="line">version : 解析这个xml的时候，使用什么版本的解析器解析</span><br><span class="line">encoding : 解析xml中的文字的时候，使用什么编码来翻译</span><br><span class="line">standalone  : no：该文档会依赖关联其他文档，yes：这是一个独立的文档</span><br></pre></td></tr></table></figure><ul><li>encoding：默认文件保存的时候，使用的是GBK的编码保存。<br>要想让我们的xml能够正常的显示中文，有以下解决办法：<ol><li>让encoding也是GBK 或者 gb2312 。</li><li>如果encoding是 utf-8 ， 那么保存文件的时候也必须使用utf-8。</li><li>保存的时候见到的ANSI 对应的其实是我们的本地编码 GBK。</li><li>为了通用，建议使用UTF-8编码保存，以及encoding 都是 utf-8。</li></ol></li></ul><h2 id="四、元素定义"><a href="#四、元素定义" class="headerlink" title="四、元素定义"></a>四、元素定义</h2><p>1.其实就是里面的标签， &lt;&gt; 括起来的都叫元素 。 成对出现。  如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;stu&gt; &lt;/stu&gt;</span><br></pre></td></tr></table></figure><p>2.文档声明下来的第一个元素叫做根元素 (根标签)<br>3.标签里面可以嵌套标签<br>4.空标签：既是开始也是结束， 一般配合属性来用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;age/&gt;</span><br><span class="line">&lt;stu&gt;</span><br><span class="line">&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">&lt;age/&gt;</span><br><span class="line">&lt;/stu&gt;</span><br></pre></td></tr></table></figure><p>5.标签可以自定义。<br>XML 元素必须遵循以下命名规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.名称可以含字母、数字以及其他的字符 </span><br><span class="line">2.名称不能以数字或者标点符号开始 </span><br><span class="line">3.名称不能以字符 “xml”（或者 XML、Xml）开始 </span><br><span class="line">4.名称不能包含空格 </span><br><span class="line">5.命名尽量简单，做到见名知义</span><br></pre></td></tr></table></figure><h2 id="五、元素定义"><a href="#五、元素定义" class="headerlink" title="五、元素定义"></a>五、元素定义</h2><ul><li>简单元素：元素里面包含了普通的文字</li><li>复杂元素：元素里面还可以嵌套其他的元素</li></ul><h2 id="六、属性定义"><a href="#六、属性定义" class="headerlink" title="六、属性定义"></a>六、属性定义</h2><ul><li>定义在元素里面， &lt;元素名称  属性名称=”属性的值”&gt;&lt;/元素名称&gt;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;stus&gt;</span><br><span class="line">&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;stu id=<span class="string">"10087"</span>&gt;</span><br><span class="line">&lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">&lt;age&gt;28&lt;/age&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure><h2 id="七、xml注释"><a href="#七、xml注释" class="headerlink" title="七、xml注释"></a>七、xml注释</h2><p>与html的注释一样。 xml的注释，不允许放置在文档的第一行。 必须在文档声明的下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- --&gt; </span><br><span class="line">如： </span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">//这里有两个学生</span><br><span class="line">//一个学生，名字叫张三， 年龄18岁， 学号：10086</span><br><span class="line">//另外一个学生叫李四  。。。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="八、CDATA区"><a href="#八、CDATA区" class="headerlink" title="八、CDATA区"></a>八、CDATA区</h2><ul><li>所有 XML 文档中的文本均会被解析器解析，只有 CDATA 区段（CDATA section）中的文本会被解析器忽略。<br>在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。”&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始，”&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。<br>在html中，某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。</li><li>一般在数据传输的时候会出现，比如说服务器给客户端传数据。</li><li>严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;   &amp;lt;</span><br><span class="line">&amp;   &amp;amp;</span><br></pre></td></tr></table></figure><ul><li>CDATA区写法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CDATA区 开始于 <span class="string">"&lt;![CDATA["</span></span><br><span class="line">        结束于 <span class="string">"]]&gt;"</span></span><br><span class="line">    如：</span><br><span class="line">&lt;des&gt;&lt;![CDATA[&lt;a href=<span class="string">"http://www.baidu.com"</span>&gt;我要学编程&lt;/a&gt;]]&gt;&lt;/des&gt;</span><br></pre></td></tr></table></figure><h2 id="九、XML解析"><a href="#九、XML解析" class="headerlink" title="九、XML解析"></a>九、XML解析</h2><ul><li>其实就是获取元素里面的字符数据或者属性数据。</li><li>XML解析方式(<strong>面试常问</strong>)有很多种，常用的有两种（DOM和SAX）。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200224114632758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>针对以上两种解析方式，给出的解决方案有哪些？</li></ul><ol><li>jaxp  sun公司自带的， 比较繁琐</li><li>jdom        </li><li>dom4j  （常用）使用比较广泛<br>补充：jdom和dom4j的故事：刚开始都是一伙人做的，后来产生了分歧，另外一批人就做了dom4j，把jdom挤下去了。</li></ol><h2 id="十、Dom4j-基本用法"><a href="#十、Dom4j-基本用法" class="headerlink" title="十、Dom4j 基本用法"></a>十、Dom4j 基本用法</h2><p><img src="https://img-blog.csdnimg.cn/20200224140840458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.element(<span class="string">"stu"</span>) : 返回该元素下的第一个stu元素</span><br><span class="line">element.elements(); 返回该元素下的所有子元素。</span><br></pre></td></tr></table></figure><ol><li>创建SaxReader对象</li><li>指定解析的xml</li><li>获取根元素。</li><li>根据根元素获取子元素或者下面的子孙元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">javapackage com.daq.test;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1.创建sax读取对象</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();<span class="comment">//jdbc--classloader</span></span><br><span class="line"><span class="comment">//2.指定解析的xml源</span></span><br><span class="line">Document document=reader.read(<span class="keyword">new</span> File(<span class="string">"src/xml/stus.xml"</span>));</span><br><span class="line"><span class="comment">//3.得到元素</span></span><br><span class="line"><span class="comment">//得到根元素</span></span><br><span class="line">Element rootElement=document.getRootElement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取根元素下面的子元素age</span></span><br><span class="line"><span class="comment">//rootElement.element("age");</span></span><br><span class="line"><span class="comment">//System.out.println(rootElement.element("stu").element("age").getStringValue());</span></span><br><span class="line"></span><br><span class="line">List&lt;Element&gt; elements=rootElement.elements();</span><br><span class="line"><span class="comment">//遍历所有的stu元素</span></span><br><span class="line"><span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line"><span class="comment">//获取stu下面的name元素</span></span><br><span class="line">String name=element.element(<span class="string">"name"</span>).getText();</span><br><span class="line">String age=element.element(<span class="string">"age"</span>).getText();</span><br><span class="line">String adress=element.element(<span class="string">"adress"</span>).getText();</span><br><span class="line">System.out.println(<span class="string">"name="</span>+name+<span class="string">"age="</span>+age+<span class="string">"adress="</span>+adress);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、Dom4j-的-Xpath使用"><a href="#十一、Dom4j-的-Xpath使用" class="headerlink" title="十一、Dom4j 的 Xpath使用"></a>十一、Dom4j 的 Xpath使用</h2><ul><li>dom4j里面支持Xpath的写法。 xpath其实是<strong>xml的路径语言</strong>，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。<ol><li>添加jar包依赖 ：jaxen-1.1-beta-6.jar</li><li>在查找指定节点的时候，根据XPath语法规则来查找</li><li>后续的代码与以前的解析代码一样。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。 </span></span><br><span class="line">Element nameElement = (Element) rootElement.selectSingleNode(<span class="string">"//name"</span>);</span><br><span class="line">System.out.println(nameElement.getText());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文档里面的所有name元素 </span></span><br><span class="line">List&lt;Element&gt; list = rootElement.selectNodes(<span class="string">"//name"</span>);</span><br><span class="line"><span class="keyword">for</span> (Element element : list) &#123;</span><br><span class="line">System.out.println(element.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、XML-约束（了解即可）"><a href="#十二、XML-约束（了解即可）" class="headerlink" title="十二、XML 约束（了解即可）"></a>十二、XML 约束（了解即可）</h2><p>如下的文档， 属性的ID值是一样的。 这在生活中是不可能出现的。 并且第二个学生的姓名有好几个。 一般也很少。那么怎么规定ID的值唯一， 或者是元素只能出现一次，不能出现多次？ 甚至是规定里面只能出现具体的元素名字。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;stus&gt;</span><br><span class="line">&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">&lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">&lt;age&gt;18&lt;/age&gt;</span><br><span class="line">&lt;address&gt;深圳&lt;/address&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;stu id=<span class="string">"10086"</span>&gt;</span><br><span class="line">&lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">&lt;name&gt;李五&lt;/name&gt;</span><br><span class="line">&lt;name&gt;李六&lt;/name&gt;</span><br><span class="line">&lt;age&gt;28&lt;/age&gt;</span><br><span class="line">&lt;address&gt;北京&lt;/address&gt;</span><br><span class="line">&lt;/stu&gt;</span><br><span class="line">&lt;/stus&gt;</span><br></pre></td></tr></table></figure><p><strong>约束：</strong></p><ul><li>DTD：语法自成一派， 早前就出现的。 可读性比较差。 </li><li>Schema：其实就是一个xml ， 使用xml的语法规则， xml解析器解析起来比较方便 ， 是为了替代DTD 。但是Schema 约束文本内容比DTD的内容还要多。 所以目前也没有真正意义上的替代DTD</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;XML:  extendsible  markup  labguage  可扩展的标记语言&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="XML" scheme="http://daqwt.top/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat发布项目的三种方式</title>
    <link href="http://daqwt.top/2665853047/"/>
    <id>http://daqwt.top/2665853047/</id>
    <published>2020-02-07T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Tomcat发布项目到服务器上的三种方式</p><a id="more"></a><h2 id="一、拷贝这个文件到webapps-ROOT底下，-在浏览器里面访问。"><a href="#一、拷贝这个文件到webapps-ROOT底下，-在浏览器里面访问。" class="headerlink" title="一、拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问。"></a>一、拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/stu.xml</span><br></pre></td></tr></table></figure><ul><li>在webaps下面新建一个文件夹xml  , 然后拷贝文件放置到这个文件夹中</li><li><a href="http://localhost:8080/xml/stu.xml">http://localhost:8080/xml/stu.xml</a></li><li><a href="http://localhost:8080">http://localhost:8080</a> ： 对应的是到webapps/root</li><li><a href="http://localhost:8080/xml/">http://localhost:8080/xml/</a> : 对应是 webapps/xml</li><li>使用IP地址访问：http://本机ip:8080/xml/stu.xml</li></ul><h2 id="二、配置虚拟路径"><a href="#二、配置虚拟路径" class="headerlink" title="二、配置虚拟路径"></a>二、配置虚拟路径</h2><p> 使用localhost：8080 打开tomcat首页， 找到Tomcat 8.5 Documentation,进入Reference，点击configuration ，找到左边的context，点击进入，复制此页面路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/docs/config/context.html</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200225123552708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在conf/server.xml 找到host元素节点。加入以下内容。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200225124622947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在浏览器地址栏上输入： <a href="http://localhost:8080/daq/person.xml">http://localhost:8080/daq/person.xml</a></li></ul><h2 id="配置虚拟路径2"><a href="#配置虚拟路径2" class="headerlink" title="配置虚拟路径2"></a>配置虚拟路径2</h2><ol><li><p>在<code>tomcat/conf/catalina/localhost/</code> 文件夹下新建一个xml文件，名字可以自己定义。 <code>person.xml</code></p></li><li><p>在这个文件里面写入以下内容</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span>?&gt;</span><br><span class="line">&lt;Context docBase=<span class="string">"F：\XML2"</span>&gt;&lt;/Context&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>在浏览器上面访问:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/person/xml的名字即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Tomcat发布项目到服务器上的三种方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="web" scheme="http://daqwt.top/tags/web/"/>
    
      <category term="Tomcat" scheme="http://daqwt.top/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>认识web服务器&amp;Eclipse配置部署Tomcat</title>
    <link href="http://daqwt.top/629938038/"/>
    <id>http://daqwt.top/629938038/</id>
    <published>2020-02-07T05:01:53.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、IIS。</p><a id="more"></a><h2 id="一、程序架构"><a href="#一、程序架构" class="headerlink" title="一、程序架构"></a>一、程序架构</h2><ul><li>C /  S (client / server)<br>如：QQ  微信   LOL<br>优点：有一部分代码写在客户端，用户体验比较好。<br>缺点：占用资源大，比较吃硬盘，服务器更新，客户端也要随之更新。</li><li>B / S (browser / server)<br>如：网页QQ，  网页游戏。<br>优点：客户端只要浏览器就可以了，占用资源小，不用更新。<br>缺点：用户体验不佳。</li></ul><h2 id="二、web服务器"><a href="#二、web服务器" class="headerlink" title="二、web服务器"></a>二、web服务器</h2><ul><li><strong>服务器：其实服务器就是一台电脑。 配置比一般的要好。</strong></li><li>Web服务器软件 ：客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。 </li></ul><ul><li>处理客户端的请求， 返回资源 | 信息</li></ul><ul><li>Web应用  需要服务器支撑。 index.html</li></ul><ul><li>常用web服务器：<br> Tomcat  —–apache 免费<br> WebLogic —–BEA  收费<br> Websphere —–IBM 收费<br> IIS   —–微软<h2 id="三、安装tomcat"><a href="#三、安装tomcat" class="headerlink" title="三、安装tomcat"></a>三、安装tomcat</h2></li><li>直接解压 ，然后找到bin/startup.bat</li><li>安装启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： <a href="http://localhost:8080">http://localhost:8080</a> , 如果有看到内容 就表明成功了。在黑窗口开着的同时输入网址。</li><li>出现控制台乱码问题，右键控制台，查看是GBK，还是UTF-8。然后在安装目录中找到conf–logging.properties文件，修改里面的编码方式，保持一致即可。</li><li>如果双击了startup.bat,  看到一闪而过的情形，一般都是 JDK的环境变量没有配置。<h2 id="四、Tomcat目录介绍"><a href="#四、Tomcat目录介绍" class="headerlink" title="四、Tomcat目录介绍"></a>四、Tomcat目录介绍</h2></li></ul><p><img src="https://img-blog.csdnimg.cn/20200225115238417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>bin： 包含了一些jar ,  bat文件 。  startup.bat。</p></li><li><p>conf：tomcat的配置   server.xml ，  web.xml。</p></li><li><p>lib：tomcat运行所需的jar文件。</p></li><li><p>logs：运行的日志文件。</p></li><li><p>temp：临时文件。</p></li><li><p>webapps：发布到tomcat服务器上的项目，就存放在这个目录。</p></li><li><p>work：jsp翻译成class文件存放地。</p></li></ul><h2 id="五、Eclipse配置Tomcat"><a href="#五、Eclipse配置Tomcat" class="headerlink" title="五、Eclipse配置Tomcat"></a>五、Eclipse配置Tomcat</h2><ol><li>Java EE 的视图下，在server里面，右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。</li><li>配置完毕后， 在server 里面， 右键刚才的服务器，然后open  ， 找到上面的Server Location , 选择中间的 Use Tomcat installation…</li><li>创建web工程， 在WebContent下新建html文件， 右击工程， run as server<br><img src="https://img-blog.csdnimg.cn/20200225140218529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>至此成功！！！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、IIS。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Web" scheme="http://daqwt.top/categories/Java-Web/"/>
    
    
      <category term="web" scheme="http://daqwt.top/tags/web/"/>
    
      <category term="Tomcat" scheme="http://daqwt.top/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>DBUtils学习笔记</title>
    <link href="http://daqwt.top/2524199830/"/>
    <id>http://daqwt.top/2524199830/</id>
    <published>2020-02-06T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。并且简化了增删改查的操作。</p><a id="more"></a><h1 id="使用开源的DBUtils"><a href="#使用开源的DBUtils" class="headerlink" title="使用开源的DBUtils"></a>使用开源的DBUtils</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。</li><li>简化了增删改查的操作。</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li>增删改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.导入jar包  commons-dbutils-1.4.jar</span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">// dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(dataSource);</span><br><span class="line">// 增加</span><br><span class="line">queryRunner.update(<span class="string">"insert into category values (null , ? , ? )"</span>, <span class="string">"a"</span>, 1000);</span><br><span class="line">// 删除</span><br><span class="line">queryRunner.update(<span class="string">"delete from account where id = ?"</span>, 5);</span><br><span class="line">// 更新</span><br><span class="line">queryRunner.update(<span class="string">"update account set money = ? where id = ?"</span>, 10000000, 6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.直接new接口的匿名实现类</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">Account  account =  queryRunner.query(<span class="string">"select * from account where id = ?"</span>, new ResultSetHandler&lt;Account&gt;()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Account handle(ResultSet rs) throws SQLException &#123;</span><br><span class="line">Account account  =  new Account();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">int money = rs.getInt(<span class="string">"money"</span>);</span><br><span class="line"></span><br><span class="line">account.setName(name);</span><br><span class="line">account.setMoney(money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> account;</span><br><span class="line">&#125; </span><br><span class="line"> &#125;, 6);</span><br><span class="line">System.out.println(account.toString());</span><br><span class="line"></span><br><span class="line">2. 直接使用框架已经写好的实现类。（最常用）</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">//查询单个对象</span><br><span class="line">Account account = queryRunner.query(<span class="string">"select * from account where id = ?"</span>, </span><br><span class="line">new BeanHandler&lt;Account&gt;(Account.class), 8);</span><br><span class="line">System.out.println(category.toString());</span><br><span class="line"></span><br><span class="line">* 查询多个对象</span><br><span class="line">List&lt;Category&gt; list = queryRunner.query(<span class="string">"select * from category"</span>, new BeanListHandler&lt;Category&gt;(Category.class));</span><br><span class="line"><span class="keyword">for</span> (Category category : list) &#123;</span><br><span class="line">System.out.println(category.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ResultSetHandler-常用的实现类"><a href="#ResultSetHandler-常用的实现类" class="headerlink" title="ResultSetHandler 常用的实现类"></a>ResultSetHandler 常用的实现类</h1><ul><li>以下两个是使用频率最高的</li></ul><ol><li><p>BeanHandler          查询到的<strong>单个</strong>数据封装成一个对象</p></li><li><p>BeanListHandler    查询到的<strong>多个</strong>数据封装 成一个List&lt;对象&gt;</p></li><li><p>ArrayHandler,  查询到的单个数据封装成一个数组。</p></li><li><p>ArrayListHandler,  查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 </p></li><li><p>MapHandler,  查询到的单个数据封装成一个map</p></li><li><p>MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 </p></li><li><p>ColumnListHandler</p></li><li><p>KeyedHandler</p></li><li><p>ScalarHandler</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。并且简化了增删改查的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql,DBUtils" scheme="http://daqwt.top/tags/MySql-DBUtils/"/>
    
  </entry>
  
  <entry>
    <title>事务-学习笔记</title>
    <link href="http://daqwt.top/1680230579/"/>
    <id>http://daqwt.top/1680230579/</id>
    <published>2020-02-05T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。</p><a id="more"></a><h1 id="一、事务（Transaction）概述"><a href="#一、事务（Transaction）概述" class="headerlink" title="一、事务（Transaction）概述"></a>一、事务（Transaction）概述</h1><ul><li>其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(<strong>回滚</strong>)。</li><li><strong>为什么要有事务?</strong><br>为了确保逻辑的成功。 如： 银行转账。 </li></ul><h1 id="二、演示事务"><a href="#二、演示事务" class="headerlink" title="二、演示事务"></a>二、演示事务</h1><ul><li>命令行方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开启事务：</span><br><span class="line">start transaction;</span><br><span class="line">提交：</span><br><span class="line">commit; 提交事务， 数据将会写到磁盘上的数据库</span><br><span class="line">回滚：</span><br><span class="line">rollback ;  数据回滚，回到最初的状态。</span><br></pre></td></tr></table></figure><ul><li>代码里面的事务，主要是针对连接来的。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-通过conn.setAutoCommit（<span class="literal">false</span> ）来关闭自动提交的设置。</span><br><span class="line">-提交事务  conn.commit();</span><br><span class="line">-回滚事务 conn.rollback();</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testTransaction</span></span>()&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">try &#123;</span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"></span><br><span class="line">//连接，事务默认就是自动提交的。 关闭自动提交。</span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"update account set money = money - ? where id = ?"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//扣钱， 扣ID为1 的100块钱</span><br><span class="line">ps.setInt(1, 100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">int a = 10 /0 ;//有了异常，下面代码就不会执行了</span><br><span class="line"></span><br><span class="line">//加钱， 给ID为2 加100块钱</span><br><span class="line">ps.setInt(1, -100);</span><br><span class="line">ps.setInt(2, 2);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">//成功： 提交事务。</span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//失败： 回滚事务</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、事务特性ACID（面试）"><a href="#三、事务特性ACID（面试）" class="headerlink" title="三、事务特性ACID（面试）"></a>三、事务特性ACID（面试）</h1><ul><li>原子性（Atom）<br>指的是 事务中包含的逻辑，不可分割。 </li><li>一致性（Consistent）<br>指的是 事务执行前后，数据完整性。</li><li>隔离性（Isolate）<br>指的是 事务在执行期间不应该受到其他事务的影响。</li><li>持久性（Durable）<br>指的是 事务执行成功，那么数据应该持久保存到磁盘上。</li></ul><h1 id="四、安全问题-amp-隔离级别（面试）"><a href="#四、安全问题-amp-隔离级别（面试）" class="headerlink" title="四、安全问题&amp;隔离级别（面试）"></a>四、安全问题&amp;隔离级别（面试）</h1><ul><li><strong>不考虑隔离级别设置</strong>，那么会出现以下问题。</li></ul><h2 id="读-问题"><a href="#读-问题" class="headerlink" title="读  问题"></a>读  问题</h2><ul><li>脏读<br>一个事务读到另外一个事务还未提交的数据。</li><li>不可重复读<br>一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。</li><li>幻读<br>一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一致。</li></ul><h2 id="写-问题"><a href="#写-问题" class="headerlink" title="写  问题"></a>写  问题</h2><ol><li><p>丢失更新：<br>B事务如果提交，会造成A事务的操作无效。<br>B事务回滚，也会造成A事务更新失效。</p></li><li><p>解决方法：悲观锁，乐观锁</p></li></ol><ul><li><strong>悲观锁</strong><br>指事务在一开始就认为丢失更新一定会发生， 这是一件很悲观的事情。 具体操作步骤如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.所以事务在执行操作前，先查询一次数据， 查询语句如下：</span><br><span class="line">select * from student  <span class="keyword">for</span> update  ;           </span><br><span class="line">后面的<span class="keyword">for</span> update 其实是数据库锁机制 、 一种排他锁。</span><br><span class="line"></span><br><span class="line">2.哪个事务先执行这个语句， 哪个事务就持有了这把锁， 可以查询出来数据， 后面的事务想再执行这条语句，不会有任何数据显示，就只能等着。 </span><br><span class="line"></span><br><span class="line">3.一直等到前面的那个事务提交数据后， 后面的事务数据才会出来，那么才可以往下接着操作。</span><br><span class="line"> </span><br><span class="line">4.补充：就像排队上厕所一样，只有里面的人出来了，才能进去。 这其实就是 java 中的同步的概念。</span><br></pre></td></tr></table></figure><ul><li><strong>乐观锁</strong><br>乐观锁是指，从来不会觉得丢失更新会发生。要求程序员在数据库中添加字段，然后在后续更新的时候，对该字段进行判定比对， 如果一致才允许更新。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">1.数据库表中，额外添加了一个version字段， 用于记录版本， 默认从0 开始， 只要有针对表中数据进行修改的，那么version就+1.</span><br><span class="line"></span><br><span class="line">2.开启A事务， 然后开启B事务 。</span><br><span class="line"></span><br><span class="line">3.A 先执行数据库表操作。 因为以前都没有人修改过。 所以是允许A事务修改数据库的，但是修改完毕，就把version的值变成  1 了 。</span><br><span class="line"></span><br><span class="line">4.B事务， 这时候如果想执行修改，那么是不允许修改的。 因为B事务以前是没有查询过数据库内容的，所以它认为数据库版本还是0 。 但是数据库的版本经过A修改，已经是1了。</span><br><span class="line">所以这时候不允许修改， 要求其重新查询 。</span><br><span class="line"></span><br><span class="line">5.B重新查询后， 将会得到version 为 1的数据，这份数据就是之前A 事务修改的数据了， B 在进行修改，也是在A的基础上修改的。 所以就不会有丢失更新的情况出现了。</span><br><span class="line"></span><br><span class="line">补充：乐观锁的机制 ，其实是通过比对版本或者比对字段的方式来实现的，与版本控制软件【SVN , GIT】机制是一样的。</span><br></pre></td></tr></table></figure><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 按效率划分，从高到低</span><br><span class="line">读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</span><br><span class="line"></span><br><span class="line">- 按拦截程度 ，从高到底</span><br><span class="line">可串行化 &gt; 可重复读  &gt; 读已提交  &gt;  读未提交</span><br></pre></td></tr></table></figure><ul><li>Read Uncommited【读未提交】<br>指的是 ： 一个事务可以读取到另一个事务还未提交的数据。 这就会引发 “脏读” 读取到的是数据库<strong>内存</strong>中的数据，而并非真正磁盘上的数据。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子： </span><br><span class="line">1.开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">设置当前窗口的事务隔离级别为：读未提交  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> uncommitted;</span><br><span class="line">2.另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交</span><br><span class="line">3.在A窗口重新执行查询， 会看到B窗口没有提交的数据。</span><br></pre></td></tr></table></figure><ul><li>Read Commited 【读已提交】<br>与前面的读未提交刚好相反，这个隔离级别是 ，只能读取到其他事务已经提交的数据，那些没有提交的数据是读不出来的。屏蔽了脏读的情况，但是这会造成一个问题是： 前后读取到的结果不一样。 发生了不可重复!!!, 所谓的不可重复读，就是不能执行多次读取，否则出现结果不一样。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line"> 设置当前窗口的事务隔离级别为：读已提交  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> committed;</span><br><span class="line">2. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">3. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">4. 在B窗口执行提交。</span><br><span class="line">5. 在A窗口中执行查看， 这时候才会看到B窗口已经修改的结果。</span><br><span class="line">6. 但是这会造成一个问题是： 在A窗口中， 第一次查看数据和第二次查看数据，结果不一样。</span><br></pre></td></tr></table></figure><ul><li>Repeatable Read 【重复读】<br>MySql 默认的隔离级别就是这个。该隔离级别， 可以让事务在自己的会话中重复读取数据，并且不会出现结果不一样的状况，即使其他事务已经提交了，也依然还是显示以前的数据。（读到的不是最新更新的数据，确保本事务不受其他事务影响）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2. 设置当前窗口的事务隔离级别为：重复读  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level repeatable <span class="built_in">read</span>;</span><br><span class="line">3. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">5. 在B窗口执行提交。</span><br><span class="line">6. 在A窗口中执行查看， 这时候查询结果，和以前的查询结果一致。不会发生改变。</span><br></pre></td></tr></table></figure><ul><li>Serializable 【可串行化（序列化）】<br>该事务级别是最高级的事务级别了，如果有一个连接设置隔离级别为可串行化，那么谁先打开事务，谁就有了先执行的权利，谁后打开事务，就只能等着，等前面的那个事务，提交或者回滚后才会执行。这种隔离级别比前面几种都要强大一点，也就是前面几种的问题【脏读、不可重复读、幻读】都能够解决。但是都使用该隔离级别也会有些问题。 比如造成并发的性能问题。 其他的事务必须得等当前正在操作表的事务先提交，才能接着往下，否则只能一直在等着。所以比较少用，容易造成性能上的问题，效率比较低。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1.开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2.设置当前窗口的事务隔离级别为：serializable 命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> serializable;</span><br><span class="line">3.另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4.在A窗口重新执行查询， 会卡主，没有任何信息显示。 </span><br><span class="line">5.在B窗口执行提交。</span><br><span class="line">6.在A窗口中执行查看， 这时候才会显示结果。</span><br></pre></td></tr></table></figure><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>1.在代码里面使用事务 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">conn.commit();</span><br><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure><p>2.事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。<br>3.事务是会自动提交的。<br>4.安全隐患：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读</span><br><span class="line">脏读：一个事务读到了另一个事务未提交的数据。</span><br><span class="line">不可重复读：一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致。</span><br><span class="line">幻读：一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。</span><br><span class="line">写</span><br><span class="line">丢失更新。</span><br></pre></td></tr></table></figure><p>5.隔离级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读未提交</span><br><span class="line">&gt; 引发问题： 脏读 </span><br><span class="line">读已提交</span><br><span class="line">&gt; 解决： 脏读 ， 引发： 不可重复读</span><br><span class="line">可重复读</span><br><span class="line">&gt; 解决： 脏读 、 不可重复读 ， 未解决： 幻读</span><br><span class="line">可串行化</span><br><span class="line">&gt; 解决： 脏读、 不可重复读 、 幻读。  导致：性能下降</span><br></pre></td></tr></table></figure><p>6.补充：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySql 默认的隔离级别是 可重复读</span><br><span class="line">Oracle 默认的隔离级别是  读已提交</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://daqwt.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池</title>
    <link href="http://daqwt.top/1664209794/"/>
    <id>http://daqwt.top/1664209794/</id>
    <published>2020-02-04T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:59.009Z</updated>
    
    <content type="html"><![CDATA[<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><a id="more"></a><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li><strong>数据库的连接对象创建工作，比较消耗性能。</strong> </li><li>一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。  后面需要连接的话，直接从池子里面去。不要去自己创建连接了。  使用完毕， 要记得归还连接。确保连接对象能循环利用。</li></ul><ul><li>连接池指：创建一个池子（容器） ， 专门用来管理连接对象。<br><img src="https://img-blog.csdnimg.cn/20200301155401842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><ul><li>创建和管理连接，对数据的操作没有影响。</li><li>更快响应速度，连接池里的连接在一开始就已经创建好了，后面如果需要直接拿就可以了，无需创建。</li><li>资源的重复利用、避免重复创建对象，连接对象使用完毕后，再归还到池子中进行统一管理即可。</li></ul><h2 id="三、自定义数据库连接池"><a href="#三、自定义数据库连接池" class="headerlink" title="三、自定义数据库连接池"></a>三、自定义数据库连接池</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这是一个数据库连接池</span><br><span class="line"> * 一开始先往池子里面放十个连接</span><br><span class="line"> */</span><br><span class="line">public class MyDataSource implements DataSource &#123;</span><br><span class="line">//创建一个集合用来存放连接对象</span><br><span class="line">List&lt;Connection&gt; list=new ArrayList&lt;Connection&gt;();</span><br><span class="line">//用一个构造方法，刚开始就给这个池子里放入10个连接对象</span><br><span class="line">public <span class="function"><span class="title">MyDataSource</span></span>() &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">Connection conn = JDBCUtil.getconn();</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该连接池对外公布的获取连接的方法</span><br><span class="line">@Override</span><br><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">//来拿连接的时候，先看看，池子里面有没有，没有了就再添加，扩容</span><br><span class="line"><span class="keyword">if</span>(list.size()==0) &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">Connection conn = JDBCUtil.getconn();</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Connection conn=list.remove(0);</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用完之后返回连接对象</span><br><span class="line">public void addBack(Connection conn) &#123;</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用连接池</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestPool &#123;</span><br><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testPool</span></span>() &#123;</span><br><span class="line">Connection conn=null;</span><br><span class="line">PreparedStatement ps=null;</span><br><span class="line">MyDataSource dataSource=new MyDataSource();</span><br><span class="line">try &#123;</span><br><span class="line">conn=dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql=<span class="string">"insert into category values(null,'lisi',daq)"</span>;</span><br><span class="line">ps=conn.prepareStatement(sql);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ps.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//归还连接对象</span><br><span class="line">dataSource.addBack(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><ul><li>对象没有做成单例。<br>在哪里使用，都需要new MyDataSource().  这就会造成有多个对象的情况出现， 那就不只一个池子了。</li><li>需要额外记住 addBack方法。<br>由于sun公司定义的数据库连接池里面并没有这个addBack方法，所以要用这个连接池的时候，需要记住这个方法是用来回收连接对象的。</li><li>无法面向接口编程。<br>由于连接池直接定义成了一个类，并且里面还额外添加了一个addBack方法，这就造成了无法面向接口编程。</li></ul><p><strong>解决思路：</strong><br>由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且不能面向接口编程。</p><ol><li>修改接口中的close方法。  原来的Connection对象的close方法，是真的关闭连接。 </li><li>修改此close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。如何扩展某一个方法?</li></ol><p>原有的方法逻辑，不是我们想要的。 想修改方法的逻辑，怎么办？</p><ol><li>直接改源码  无法实现。</li><li>继承， 必须得知道这个接口的具体实现是谁。 </li><li>使用装饰者模式。 </li><li>动态代理</li></ol><h3 id="解决方式：装饰者模式"><a href="#解决方式：装饰者模式" class="headerlink" title="解决方式：装饰者模式"></a>解决方式：装饰者模式</h3><p>两个不同的人，去实现同一个接口，先把我的方法执行了，再执行你的。</p><h2 id="四、开源连接池"><a href="#四、开源连接池" class="headerlink" title="四、开源连接池"></a>四、开源连接池</h2><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><ul><li>DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.导入jar包  commons-dbcp.jar和commons-pool.jar</span><br><span class="line">2.不使用配置文件方式（不常用）</span><br><span class="line">// 1.构建数据源对象</span><br><span class="line">BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line"></span><br><span class="line">dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">//Url格式-主协议：子协议：//本地//数据库</span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://localhost/users"</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"daq"</span>);</span><br><span class="line">// 2.得到连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">...</span><br><span class="line">3.使用配置文件方式。(常用)</span><br><span class="line">1. 在 src 下定义配置文件 dbcp.properties. 内容如下： </span><br><span class="line">//连接设置</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/jdbc</span><br><span class="line">username=root</span><br><span class="line">password=daq</span><br><span class="line">...</span><br><span class="line">2. 使用代码读取配置文件，即可获取连接池</span><br><span class="line">BasicDataSourceFactory factory=new BasicDataSourceFactory();</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(<span class="string">"src/dbcp.properties"</span>));</span><br><span class="line">DataSource dataSource =factory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="C3P0（重点）"><a href="#C3P0（重点）" class="headerlink" title="C3P0（重点）"></a>C3P0（重点）</h3><ul><li>C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. 拷贝jar 文件   c3p0-0.9.1.2.jar</span><br><span class="line">2. 不使用配置文件方式（开发的时候不会用）</span><br><span class="line">//默认会找 xml 中的 default-config 分支。 </span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">//2. 设置连接数据的信息</span><br><span class="line">dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost/users"</span>);</span><br><span class="line">dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"daq"</span>);</span><br><span class="line">//3. 获取连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">3. 使用配置文件方式。（开发常用）</span><br><span class="line">c3p0的配置文件 支持 properties , 也支持 xml 方式。 不过开发中，一般使用xml方式来配置</span><br><span class="line"></span><br><span class="line">1.  src下， 创建xml文件，名为：c3p0-config.xml 　注意此处，名字需要固定了。</span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">  &lt;default-config&gt;</span><br><span class="line">    &lt;property name=<span class="string">"driverClass"</span>&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"jdbcUrl"</span>&gt;jdbc:mysql://localhost/user&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"user"</span>&gt;root&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"password"</span>&gt;daq&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 可选配置 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"initialPoolSize"</span>&gt;10&lt;/property&gt;   //初始容量</span><br><span class="line">&lt;property name=<span class="string">"maxIdleTime"</span>&gt;30&lt;/property&gt; //</span><br><span class="line">&lt;property name=<span class="string">"maxPoolSize"</span>&gt;100&lt;/property&gt; //最大容量</span><br><span class="line">&lt;property name=<span class="string">"minPoolSize"</span>&gt;10&lt;/property&gt; //最小容量</span><br><span class="line">&lt;property name=<span class="string">"maxStatement"</span>&gt;200&lt;/property&gt; //</span><br><span class="line">  &lt;/default-config&gt;</span><br><span class="line">&lt;/c3p0-config&gt;</span><br><span class="line"></span><br><span class="line">//1. 代码中获取连接dataSource对象</span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line">//2. 获取连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = <span class="string">"insert into user values(null,?,?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1,<span class="string">"daq"</span>);</span><br><span class="line">ps.setInt(2,23);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql,连接池" scheme="http://daqwt.top/tags/MySql-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDBC基础知识</title>
    <link href="http://daqwt.top/3453823259/"/>
    <id>http://daqwt.top/3453823259/</id>
    <published>2020-02-03T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.975Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC概述，作用，类型，以及使用时如何选择。</p><a id="more"></a><h2 id="一、JDBC是什么？"><a href="#一、JDBC是什么？" class="headerlink" title="一、JDBC是什么？"></a>一、JDBC是什么？</h2><ul><li>百度百科解释：JDBC(java database connectivity)驱动程序是对JDBC规范完整的实现，它的存在在Java程序与数据库系统之间建立了一条通信的渠道。它是 一 种可用于执行 SQL 语句的 Java API(<strong>Application Programming Interface， 应用程序设计接口</strong>)。</li><li>简单理解：java 数据库连接。有了它，就能够在java代码中操作任何数据库。由于数据库种类繁多，并且java程序使用广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问。</li><li>刚开始每个数据库（Oracle，Mysql，SqlServer）的访问规则都不同，后来SUN公司想一统天下，出台了一套规范，各个数据库要按照这个规范去写底层代码，与此同时，Java程序也直接去找JDBC。</li></ul><h2 id="二、作用是什么？"><a href="#二、作用是什么？" class="headerlink" title="二、作用是什么？"></a>二、作用是什么？</h2><ul><li>JDBC 为数据库应用开发人员、数据库前台开发人员提供了一种标准的应用程序设计接口， 使开发人员可以用纯 Java 语言编写完整的数据库应用程序。</li><li>JDBC 通过调用其接口提供的方法， 提供了 Java 应用程序与各种数据库服务器之间的连接服务，。</li><li>它支持 ANSI SQL- 92 标准， 实现了从 Java 程序内调用标准的 SQL 命令对数据库进行查询、插入、删除和更新等操作， 并确保数据事务的正常进行。</li></ul><h2 id="三、JDBC驱动程序"><a href="#三、JDBC驱动程序" class="headerlink" title="三、JDBC驱动程序"></a>三、JDBC驱动程序</h2><p>根据访问数据库的技术不同， JDBC 驱动程序相应地分为四种类型。不同类型的驱动程序有着不一样的特性和使用方法。</p><p> 1.<strong>JDBC-ODBC桥驱动程序(JDBC-ODBC Bridge Driver)</strong></p><ul><li><input disabled="" type="checkbox"> 此类驱动程序由JDBC-ODBC桥和一个ODBC驱动程序组成。</li><li><input disabled="" type="checkbox"> 工作原理：通过一段本地<strong>C代码</strong>将JDBC调用转化成ODBC调用。这一类型必须在本地计算机上先安装好ODBC驱动程序，然后通过JDBC-ODBCBridge的转换，将Java程序中使用的JDBC API访问指令转化成ODBC API指令，进而通过ODBC驱动程序调用本地数据库驱动代码完成对数据库的访问。</li></ul><p> 2.<strong>部分Java的本地JDBC API驱动程序</strong></p><ul><li><input disabled="" type="checkbox"> JDBC API驱动程序(Anative API partly Java technology-enabled Driver)</li><li><input disabled="" type="checkbox"> 工作原理：此类驱动程序也必须在本地计算机上先安装好特定的驱动程序(类似ODBC)，然后通过PartialJavaJDBCDriver的转换，把Java程序中使用的JDBC API转换成NativeAPI，进而存取数据库。</li></ul><p>3.<strong>纯Java的数据库中间件驱动程序</strong></p><ul><li><input disabled="" type="checkbox"> 纯Java的数据库中间件驱动程序(Pure Java Driver for Database Middleware)使用这类驱动程序时，不需要在本地计算机上安装任何附加软件，但是必须在安装数据库管理系统的服务器端加装中间件(Middleware)，这个中间件负责所有存取数据库时必要的转换。</li><li><input disabled="" type="checkbox"> 工作原理：驱动程序将JDBC访问转换成与数据库无关的标准网络协议(通常是HTTP或HTTPS)送出，然后再由中间件服务器将其转换成数据库专用的访问指令，完成对数据库的操作。中间件服务器能支持对多种数据库的访问。</li></ul><p>4.<strong>纯Java的JDBC驱动程序</strong></p><ul><li><input disabled="" type="checkbox"> 纯Java的JDBC驱动程序(Direct-to-DatabasePureJavaDriver)这类驱动程序是直接面向数据库的纯Java驱动程序，即所谓的”瘦”驱动程序。</li><li><input disabled="" type="checkbox"> 工作原理：使用这类驱动程序时无需安装任何附加的软件(无论是本地计算机或是数据库服务器端)，所有存取数据库的操作都直接由JDBC驱动程序来完成，此类驱动程序能将JDBC调用转换成DBMS专用的网络协议，能够自动识别网络协议下的特殊数据库并能直接创建数据连接。</li></ul><h2 id="四、JDBC驱动程序的选择"><a href="#四、JDBC驱动程序的选择" class="headerlink" title="四、JDBC驱动程序的选择"></a>四、JDBC驱动程序的选择</h2><p>在企业内部信息系统中，选择合适的JDBC驱动程序，使之符合数据库程序设计的要求，是提高系统性能必须考虑的一个方面。不同的应用有不同的需要，所以要根据应用选择合适的驱动程序。</p><ul><li><input disabled="" type="checkbox"> <strong>JDBC-ODBC桥驱动程序(JDBC-ODBC Bridge Driver)</strong></li><li>优点：节省投资，利用了已有的ODBC驱动程序。</li><li>缺点：中间有多次调用，性能受到影响，执行效率比较低，不适合对大数据量存取的应用。有损Java数据库程序的兼容性，不具备跨平台性，不适合基于Internet/Intranet的应用。</li><li>应用：桥接驱动程序用于已经在ODBC技术上投资的情形，例如已经投资了Windows应用服务器。</li></ul><ul><li><input disabled="" type="checkbox"> <strong>部分Java的本地JDBC API驱动程序</strong></li><li>优点：具有开放性，其利用多层结构，上层用Java实现，支持多数据库，下层为本地代码(包括一些二进制代码和一个轻量的Java库)，加快了执行速度，提高了数据库访问效率。</li><li>缺点：没有使用纯Java的API，如果在本地代码中存在缺陷，将可能使Java虚拟机完全垮掉。</li><li>应用：受到限制</li></ul><ul><li><input disabled="" type="checkbox"> <strong>纯Java的数据库中间件驱动程序</strong></li><li>优点：由纯Java语言开发而成的，并且中间件也仅需要在服务器上安装，不再需要客户端的本机代码，这类驱动程序的体积最小，效率较高，具有最大的灵活性。此类驱动采用标准的网络协议，可以被防火墙支持，是开发Applet程序理想的选择(其实这些驱动是为Applet特别编写的)，是Internet应用理想的解决方案。开发者还可以利用单一的驱动程序连接到多种数据库。</li><li>缺点：需要在服务器端安装中间件，这适当影响了驱动程序的效率。</li><li>应用：基于Web的应用系统的开发。</li></ul><ul><li><input disabled="" type="checkbox"> <strong>纯Java的JDBC驱动程序</strong></li><li>最佳的JDBC驱动程序类型。</li><li>优点：无需安装任何附加软件，不会增加任何额外开销，效率最高，拥有最佳的兼容性。</li><li>缺点：可能不被防火墙支持，在Internet中会存在潜在安全隐患，成为这类驱动最大的缺陷。</li><li>应用：在企业级应用软件中，是应优先考虑的。因此，一个Servlet程序，要适应不同的操作系统，最好使用此类驱动;这种驱动也非常适合Applet程序，事实证明它能安全通过TCP/IP协议连接到数据库。</li></ul><p> <img src="https://img-blog.csdnimg.cn/20200220152318929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/202002201540355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDBC概述，作用，类型，以及使用时如何选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="JDBC,MySql" scheme="http://daqwt.top/tags/JDBC-MySql/"/>
    
  </entry>
  
  <entry>
    <title>JDBC学习</title>
    <link href="http://daqwt.top/473128650/"/>
    <id>http://daqwt.top/473128650/</id>
    <published>2020-02-03T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.975Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用JDBC连接到数据库</p><a id="more"></a><h2 id="一、添加JDBC驱动包"><a href="#一、添加JDBC驱动包" class="headerlink" title="一、添加JDBC驱动包"></a>一、添加JDBC驱动包</h2><p><img src="https://img-blog.csdnimg.cn/2020022310204253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200223102114577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020022310240148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二、使用JDBC简单步骤"><a href="#二、使用JDBC简单步骤" class="headerlink" title="二、使用JDBC简单步骤"></a>二、使用JDBC简单步骤</h2><ul><li>1、注册驱动`</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br></pre></td></tr></table></figure><ul><li>2、建立连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn=(Connection) DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/数据库名"</span>, <span class="string">"root"</span>, <span class="string">"daq"</span>);</span><br></pre></td></tr></table></figure><ul><li>3、创建statement—-跟数据库打交道，一定需要这个对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st = conn.createStatement();</span><br></pre></td></tr></table></figure><ul><li>4、执行sql 查询，得到结果集ResultSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from t_stu"</span>;</span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>5、遍历查询每一条记录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"><span class="keyword">int</span> id=rs.getInt(<span class="string">"cid"</span>);</span><br><span class="line">String name =rs.getString(<span class="string">"cname"</span>);</span><br><span class="line">String desc =rs.getString(<span class="string">"cdesc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"cid"</span>+id +<span class="string">"cname"</span>+name +<span class="string">"cdesc"</span>+desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6、关闭，释放资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">新建一个包放置适房资源的工具类，在JDBC释放资源时调用即可</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(ResultSet rs,Statement st,Connection conn)</span></span>&#123;</span><br><span class="line">closeRs(rs);</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">rs=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSt</span><span class="params">(Statement st)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">st=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConn</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">conn=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、JDBC工具类（修改原有代码）"><a href="#三、JDBC工具类（修改原有代码）" class="headerlink" title="三、JDBC工具类（修改原有代码）"></a>三、JDBC工具类（修改原有代码）</h2><ul><li>查看源代码，有一段静态代码块（类加载的时候就会执行），所以等同于说注册了两次驱动，其实驱动只需要注册一次就够了。</li><li><strong>1、注册驱动（防止二次注册）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改成以下代码即可</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">引号里面是Driver的全路径</span><br></pre></td></tr></table></figure><ul><li><strong>2、在工具类中加方法getconn（）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String url=<span class="string">"jdbc:mysql://localhost/daq"</span>;</span><br><span class="line"><span class="keyword">static</span> String name=<span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> String password=<span class="string">"daq"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getconn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">// 2.建立连接</span></span><br><span class="line">conn = (Connection) DriverManager.getConnection(</span><br><span class="line">url, name, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用properties配置文件</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.创建properties</span><br><span class="line">在src下面新建一个**jdbc.properties** 文件</span><br><span class="line">写入：</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost/daq</span></span><br><span class="line">name=root</span><br><span class="line">password=daq</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.读取properties</span><br><span class="line">在JDBCUtil工具类中添加静态代码块，保证工具类一加载，就可以读取配置文件。</span><br><span class="line"><span class="keyword">static</span> String driverClass = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.创建一个属性配置对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line"><span class="comment">// 导入输入流</span></span><br><span class="line">properties.load(is);</span><br><span class="line"><span class="comment">// 读取属性</span></span><br><span class="line">driverClass =properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">url =properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">name =properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">password =properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、JDBC的CRUD"><a href="#四、JDBC的CRUD" class="headerlink" title="四、JDBC的CRUD"></a>四、JDBC的CRUD</h2><p><img src="https://img-blog.csdnimg.cn/20200223163750100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>insert（插入）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INSERT INTO t_stu <span class="title">VALUES</span> <span class="params">(NULL,<span class="string">'wangqiang2'</span>,<span class="number">28</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 1. 获取连接对象</span></span></span><br><span class="line"><span class="function">conn </span>= JDBCUtil.getconn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"insert into t_stu values(null , 'aobama' , 59)"</span>;</span><br><span class="line"><span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>delete（删除）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM t_stu WHERE id = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"delete from stu where name='XXX'"</span>;</span><br><span class="line"><span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>query（查询）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_stu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行sql语句，返回ResultSet</span></span><br><span class="line">String sql = <span class="string">"select * from stu"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(name + <span class="string">"   "</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>update（更新）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_stu SET age = <span class="number">38</span> WHERE id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"update t_stu set age = 26 where name ='qyq'"</span>;</span><br><span class="line"><span class="comment">//影响的行数， ，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">System.out.println(<span class="string">"更新成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>补充：单元测试junit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 定义一个类， TestXXX , 里面定义方法 testXXX.</span><br><span class="line"></span><br><span class="line">- 添加junit的支持。 </span><br><span class="line"></span><br><span class="line">  右键工程 --- add Library --- Junit --- Junit4</span><br><span class="line"></span><br><span class="line">- 在方法的上面加上注解 ， 其实就是一个标记。</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- 光标选中方法名字，然后右键执行单元测试。  或者是打开outline视图， 然后选择方法右键执行。</span><br></pre></td></tr></table></figure><h2 id="五、DAO模式"><a href="#五、DAO模式" class="headerlink" title="五、DAO模式"></a>五、DAO模式</h2><ul><li><strong>Data Access Object 数据访问对象</strong></li></ul><p> <img src="https://img-blog.csdnimg.cn/20200223175345761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>1、新建一个dao的接口， 里面声明数据库访问规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义操作数据库的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、新建一个dao的实现类，具体实现早前定义的规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">//2. 创建statement对象</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line">String sql = <span class="string">"select * from t_user"</span>;</span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">String userName = rs.getString(<span class="string">"username"</span>);</span><br><span class="line">String password = rs.getString(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(userName+<span class="string">"="</span>+password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">JDBCUtil.release(conn, st, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接使用实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">dao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、JDBC-Statement安全问题"><a href="#六、JDBC-Statement安全问题" class="headerlink" title="六、JDBC Statement安全问题"></a>六、JDBC Statement安全问题</h2><ul><li>Statement执行 ，其实是拼接sql语句的。  先拼接sql语句，然后在一起执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from t_user where username='"</span>+ username  +<span class="string">"' and password='"</span>+ password +<span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">dao.login(<span class="string">"admin"</span>, <span class="string">"100234khsdf88' or '1=1"</span>);</span><br><span class="line"></span><br><span class="line">SELECT * FROM t_user WHERE username=<span class="string">'admin'</span> AND PASSWORD=<span class="string">'100234khsdf88'</span> or <span class="string">'1=1'</span> </span><br><span class="line"></span><br><span class="line">前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 </span><br><span class="line">rs = st.executeQuery(sql);</span><br></pre></td></tr></table></figure><h2 id="七、PreparStatement-CRUD"><a href="#七、PreparStatement-CRUD" class="headerlink" title="七、PreparStatement  CRUD"></a>七、PreparStatement  CRUD</h2><ul><li>该对象就是替换前面的statement对象。</li><li>相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"insert into t_user values(null , ? , ?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。</span></span><br><span class="line">ps.setString(<span class="number">1</span>, userName);</span><br><span class="line">ps.setString(<span class="number">2</span>, password);</span><br></pre></td></tr></table></figure><ul><li>PreparStatement的添加，删除，更新，</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用JDBC连接到数据库&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="JDBC,MySql" scheme="http://daqwt.top/tags/JDBC-MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql多表操作</title>
    <link href="http://daqwt.top/1663071716/"/>
    <id>http://daqwt.top/1663071716/</id>
    <published>2020-02-02T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问：</strong> 分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系？</p><a id="more"></a><h1 id="创建多表及多表的关系"><a href="#创建多表及多表的关系" class="headerlink" title="创建多表及多表的关系"></a>创建多表及多表的关系</h1><p> <strong>问：</strong> 分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">  cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  cname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  cdesc <span class="built_in">varchar</span>(<span class="number">31</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品,黑马生产'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂倾情打造'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼,茅台,二锅头'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'娃哈哈,蒙牛酸酸乳'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'馋嘴零食'</span>,<span class="string">'瓜子花生,八宝粥,辣条'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">category</span>;</span><br><span class="line"><span class="keyword">select</span> cname,cdesc <span class="keyword">from</span> <span class="keyword">category</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--所有商品</span></span><br><span class="line">1.商品ID</span><br><span class="line">2.商品名称</span><br><span class="line">3.商品的价格</span><br><span class="line">4.生产日期</span><br><span class="line">5.商品分类ID</span><br><span class="line"></span><br><span class="line">商品和商品分类 : 所属关系</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  price <span class="keyword">double</span>,</span><br><span class="line">  pdate <span class="built_in">timestamp</span>,</span><br><span class="line">  cno <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小米mix4'</span>,<span class="number">998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'锤子'</span>,<span class="number">2888</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'阿迪王'</span>,<span class="number">99</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'老村长'</span>,<span class="number">88</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'劲酒'</span>,<span class="number">35</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小熊饼干'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'卫龙辣条'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'旺旺大饼'</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>多表之间的关系如何来维护</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">外键约束: foreign key</span><br><span class="line">-给product中的cno 添加一个外键约束</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> product <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span>(cno)  <span class="keyword">references</span>  <span class="keyword">category</span>(cid);</span><br><span class="line">-从分类表中,删除分类为5信息</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">category</span> <span class="keyword">where</span> cid =<span class="number">5</span>;  //删除失败,</span><br><span class="line">首先得去product表, 删除所有分类ID5  商品</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> product <span class="keyword">where</span> cno=<span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>建数据库原则:  <strong>通常情况下,一个项目/应用建一个数据库</strong></li><li>多表之间的建表原则</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 一对多 : 商品和分类</span><br><span class="line">    建表原则: 在多的一方添加一个外键,指向一的一方的主键</span><br><span class="line"></span><br><span class="line">2.多对多: 老师和学生, 学生和课程</span><br><span class="line">    建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表。</span><br><span class="line"></span><br><span class="line">3.一对一: 班级和班长, 公民和身份证, 国家和国旗</span><br><span class="line">    建表原则:  </span><br><span class="line">      - 将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表</span><br><span class="line">      - 直接将两张表合并成一张表</span><br><span class="line">      - 将两张表的主键建立起连接,让两张表里面主键相等</span><br><span class="line"></span><br><span class="line">4.实际用途: 用的不是很多.    (拆表操作  )</span><br><span class="line">如：相亲网站: </span><br><span class="line">        - 个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,  特长,学历, 职业, 择偶目标,要求)</span><br><span class="line">        - 拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿,</span><br></pre></td></tr></table></figure><h1 id="网上商城表案例分析：用户购物流程"><a href="#网上商城表案例分析：用户购物流程" class="headerlink" title="网上商城表案例分析：用户购物流程"></a>网上商城表案例分析：用户购物流程</h1><p><img src="https://img-blog.csdnimg.cn/20200221150553826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>商品分类表(分类ID,分类名称,分类描述</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">   cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">     cname <span class="built_in">varchar</span>(<span class="number">15</span>),</span><br><span class="line">     cdesc <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品,黑马生产'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂倾情打造'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼,茅台,二锅头'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'娃哈哈,蒙牛酸酸乳'</span>);</span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'馋嘴零食'</span>,<span class="string">'瓜子花生,八宝粥,辣条'</span>);</span><br></pre></td></tr></table></figure><ul><li>商品表 (商品ID, 商品名称,商品价格,外键cno)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">    pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">      pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">      price <span class="keyword">double</span>,</span><br><span class="line">      cno <span class="built_in">int</span>,</span><br><span class="line">      <span class="keyword">foreign</span> <span class="keyword">key</span>(cno) <span class="keyword">references</span> <span class="keyword">category</span>(cid)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小米mix4'</span>,<span class="number">998</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'锤子'</span>,<span class="number">2888</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'阿迪王'</span>,<span class="number">99</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'老村长'</span>,<span class="number">88</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'劲酒'</span>,<span class="number">35</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'小熊饼干'</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'卫龙辣条'</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'旺旺大饼'</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>用户表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">  uid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    username <span class="built_in">varchar</span>(<span class="number">31</span>),</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">31</span>),</span><br><span class="line">    phone  <span class="built_in">varchar</span>(<span class="number">11</span>)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="string">'123'</span>,<span class="string">'13811118888'</span>);</span><br></pre></td></tr></table></figure><ul><li>订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders(</span><br><span class="line">    <span class="keyword">oid</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">      <span class="keyword">sum</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">        otime <span class="built_in">timestamp</span>,</span><br><span class="line">      address <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      uno <span class="built_in">int</span>,</span><br><span class="line">      <span class="keyword">foreign</span> <span class="keyword">key</span>(uno) <span class="keyword">references</span> <span class="keyword">user</span>(uid)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> orders <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">200</span>,<span class="literal">null</span>,<span class="string">'学校'</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> orders <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">250</span>,<span class="literal">null</span>,<span class="string">'家里'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>订单项: 中间表(订单ID,商品ID,商品数量,订单项总价)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orderitem(</span><br><span class="line"> ono <span class="built_in">int</span>,</span><br><span class="line">   pno <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span>(ono) <span class="keyword">references</span> orders(<span class="keyword">oid</span>),</span><br><span class="line">   <span class="keyword">foreign</span> <span class="keyword">key</span>(pno) <span class="keyword">references</span> product(pid),</span><br><span class="line">   ocount <span class="built_in">int</span>,</span><br><span class="line">   subsum <span class="keyword">double</span></span><br><span class="line"> );</span><br><span class="line"> <span class="comment">--给1号订单添加商品 200块钱的商品</span></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">8</span>,<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">--给2号订单添加商品 250块钱的商品 ()</span></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">35</span>);</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> orderitem <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">99</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>内连接查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-隐式内连接</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product p,<span class="keyword">category</span> c <span class="keyword">where</span> p.cno=c.cid;</span><br><span class="line">-显式内连接</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product p <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">category</span> c <span class="keyword">on</span> p.cno=c.cid;</span><br><span class="line">-区别：</span><br><span class="line">隐式内连接：在查询出结果的基础上去做where 条件过滤</span><br><span class="line">显式内连接：带着条件去查询结果，执行效率高。</span><br></pre></td></tr></table></figure><ul><li><strong>连接查询</strong><br>左外连接：会将左表中的所有数据都查询出来，如果右表中没有对应的数据，用NULL代替。<br>右外连接：会将右表中的所有数据查询出来如果左表没有对应数据的话<img src="https://img-blog.csdnimg.cn/20200221170140826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>分页查询</strong><br>每页数据数据3，起始索引从0 ，第1页: 0，第2页: 3。<br>起始索引:  index 代表显示第几页 页数从1开始，每页显示3条数据</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startIndex  = (index-1)*3</span><br></pre></td></tr></table></figure><ul><li>第一个参数是索引<br>第二个参数显示的个数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">limit</span> <span class="number">3</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>子查询</strong></p><p>sql的嵌套：查询语句里面嵌套查询语句</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问：&lt;/strong&gt; 分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://daqwt.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql基础操作</title>
    <link href="http://daqwt.top/81592902/"/>
    <id>http://daqwt.top/81592902/</id>
    <published>2020-02-01T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了数据库，和一些基本操作。</p><a id="more"></a><h1 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h1><ul><li>数据库就是一个文件系统，只不过我们需要通过SQL命令来操作这个文件系统。</li><li>数据库（DataBase）是按照数据结构来组织，存储和管理数据的建立在计算机存储设备上的仓库。</li><li>作用：存储数据，数据的仓库，带有访问权限，限制不同的人可以有不同的操作。</li><li>java EE操作的都是后台数据，取到后台数据进行封装，然后交给前端去展现。</li></ul><h1 id="有哪些数据库"><a href="#有哪些数据库" class="headerlink" title="有哪些数据库"></a>有哪些数据库</h1><ul><li>mysql：开源免费，适用于中小企业的免费数据库。</li><li>oracle：甲骨文公司，收费软件，适用于大型网站。</li><li>db2：IBM公司，做解决方案，软件和硬件，服务器架构，银行系统。</li><li>sqlserver：windows里，政府网站。asp.net  大学教学，图形化做得好。</li></ul><h1 id="Mysql的sql语句有哪些？"><a href="#Mysql的sql语句有哪些？" class="headerlink" title="Mysql的sql语句有哪些？"></a>Mysql的sql语句有哪些？</h1><ul><li>SQL(Structure Query Language)结构化查询语言</li><li>DDL数据定义语言：定义数据库，数据表他们的结构，create（创建），drop（删除），alert（修改）</li><li>DML数据操纵语言：主要用来操作数据，insert（插入），update（修改），delete（删除）</li><li>DCL数据控制语言：定义访问权限，取消访问权限，安全设置，grant</li><li>DQL数据查询语言：select（查询） from子句 where子句</li></ul><h1 id="数据库的CRUD操作-增删改查"><a href="#数据库的CRUD操作-增删改查" class="headerlink" title="数据库的CRUD操作(增删改查)"></a>数据库的CRUD操作(增删改查)</h1><ul><li>登录数据库服务器</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -pdaq</span><br></pre></td></tr></table></figure><ul><li>创建数据库：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;//指定字符集</span><br></pre></td></tr></table></figure><ul><li>查看所有数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020022018024091.png" alt="在这里插入图片描述"></p><ul><li>查看指定数据库：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure><ul><li>修改数据库的字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库的名字<span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure><ul><li>删除数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库的名字;</span><br></pre></td></tr></table></figure><ul><li>切换数据库（选中数据库）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库的名字;</span><br></pre></td></tr></table></figure><ul><li>查看当前正在使用的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure><h1 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h1><ul><li>创建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名（列名 列的类型(长度) 约束，列名<span class="number">2</span> 列的类型(长度) 约束）;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">列的类型：</span><br><span class="line">java     sql</span><br><span class="line">int      int</span><br><span class="line">char     char（固定长度）</span><br><span class="line">String   varchar（可变长度）长度代表字符的个数</span><br><span class="line">         </span><br><span class="line">         text：主要用来存放文本</span><br><span class="line">         blob：存放的是二进制</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列的约束：</span><br><span class="line">主键约束：primary key</span><br><span class="line">唯一约束：unique</span><br><span class="line">非空约束：not null</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"><span class="keyword">sid</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">sname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">sex <span class="built_in">int</span>,</span><br><span class="line">age <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure><ul><li>查看所有表：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><ul><li>查看表的定义：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>查看表结构：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure><ul><li>修改表：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 添加列（add）：</span><br><span class="line">alter table 表名 add 列名 列的类型 列的约束;</span><br><span class="line">alter table student add greade int not null;</span><br><span class="line"></span><br><span class="line">- 修改列（modify）：</span><br><span class="line">alter table 表名 modify sex varchar（2）;</span><br><span class="line"></span><br><span class="line">- 修改列名（change）：</span><br><span class="line">alter table 表名 change sex gender varchar（2）;</span><br><span class="line"></span><br><span class="line">- 删除列（drop）</span><br><span class="line">alter table 表名 drop greade;</span><br></pre></td></tr></table></figure><ul><li>修改表名（rename）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> student <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><ul><li>修改表的字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="built_in">character</span> <span class="keyword">set</span> 字符集;</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><h1 id="Sql完成对表中数据的CRUD操作"><a href="#Sql完成对表中数据的CRUD操作" class="headerlink" title="Sql完成对表中数据的CRUD操作"></a>Sql完成对表中数据的CRUD操作</h1><ul><li>插入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，列名<span class="number">3</span>）<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>);</span><br><span class="line">如：<span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">sid</span>,sname,sex,age)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">简单写法：插入的是全列名的数据，表名后面的列名可以省略</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名<span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>);</span><br><span class="line">如:<span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">如果插入的是部分数据，列名不能省略</span><br><span class="line">如：<span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">sid</span>,sname,sex)<span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">批量插入：效率比单条插入效率高。但不能出错</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>,<span class="number">1</span>，<span class="number">23</span>),</span><br><span class="line">     (<span class="number">2</span>,<span class="string">'lisi'</span>,<span class="number">0</span>，<span class="number">22</span>),</span><br><span class="line">     (<span class="number">3</span>,<span class="string">'wangwu'</span>,<span class="number">1</span>，<span class="number">24</span>);</span><br></pre></td></tr></table></figure><ul><li>查看表中数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><ul><li>表中插入数据中文乱码问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.暂停Mysql服务</span><br><span class="line">2.在Mysql安装路径中找到my.ini配置文件</span><br><span class="line">3.将57行的编码改成GBK。</span><br><span class="line">4.保存，退出，启动mysql服务</span><br></pre></td></tr></table></figure><ul><li>删除记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名[<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student;  如果没有指定条件，会将表中数据一条一条全部删除掉。</span><br></pre></td></tr></table></figure><ul><li>面试问题：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请说一下delete 删除数据和truncate删除数据有什么差别？</span><br><span class="line">答：delete：属于DML数据操纵语言，一条一条删除表中的数据。</span><br><span class="line">truncate：属于DDL数据定义语言，先删除表，在重建表。 </span><br><span class="line"></span><br><span class="line">关于那条执行效率高：具体要看表中的数据量。</span><br><span class="line">如果数据比较少，delete比较高效。</span><br><span class="line">如果数据比较多，truncate比较高效。</span><br></pre></td></tr></table></figure><ul><li>更新表记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列名=列的值，列名<span class="number">2</span>=列的值<span class="number">2</span> [<span class="keyword">where</span> 条件]</span><br><span class="line"></span><br><span class="line">需求：将<span class="keyword">sid</span>为<span class="number">5</span>的名字改成李四</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> sname=<span class="string">'李四'</span> <span class="keyword">where</span> <span class="keyword">sid</span>=<span class="number">5</span>;</span><br><span class="line">//如果参数是字符串或者日期，要加上单引号</span><br></pre></td></tr></table></figure><h1 id="select查询的简单查询"><a href="#select查询的简单查询" class="headerlink" title="select查询的简单查询"></a>select查询的简单查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] [ * ] [列名，列名<span class="number">2</span>] <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br><span class="line"><span class="keyword">distinct</span>：去除重复的数据</span><br><span class="line"></span><br><span class="line"><span class="comment">--简单商品：手机数码，鞋靴箱包</span></span><br><span class="line"><span class="number">1.</span>分类的<span class="keyword">ID</span></span><br><span class="line"><span class="number">2.</span>分类名称</span><br><span class="line"><span class="number">3.</span>分类描述</span><br><span class="line"></span><br><span class="line">//创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">category</span>(</span><br><span class="line">cid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">cname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">cdesc <span class="built_in">varchar</span>(<span class="number">31</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'手机数码'</span>,<span class="string">'电子产品'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'鞋靴箱包'</span>,<span class="string">'江南皮鞋厂'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'香烟酒水'</span>,<span class="string">'黄鹤楼'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'酸奶饼干'</span>,<span class="string">'安慕希'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">category</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'家用电器'</span>,<span class="string">'美的空调'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--所有商品</span></span><br><span class="line">1.商品ID</span><br><span class="line">2.商品名称</span><br><span class="line">3.商品价格</span><br><span class="line">4，生产日期</span><br><span class="line">5，商品分类ID</span><br><span class="line"></span><br><span class="line">//创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">price <span class="keyword">double</span>,</span><br><span class="line">pdate <span class="built_in">timestamp</span>,</span><br><span class="line">cno <span class="built_in">int</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'xiaomi'</span>,<span class="number">998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'chuizi'</span>,<span class="number">2998</span>,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'nike'</span>,<span class="number">888</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'laocunzhang'</span>,<span class="number">88</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'jingjiu'</span>,<span class="number">32</span>,<span class="literal">null</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'xiaoxiong'</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'weilong'</span>,<span class="number">0.5</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'wangwang'</span>,<span class="number">0.5</span>,<span class="literal">null</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>简单查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.查询所有的商品：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">2.查询商品名称和商品价格</span><br><span class="line"><span class="keyword">select</span> pname,price <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">3.别名查询，as 的关键字 ，as关键字可以省略</span><br><span class="line">-表别名：<span class="keyword">select</span> p.pname,p.price,<span class="keyword">from</span> product p;(主要用在多表查询)</span><br><span class="line"><span class="keyword">select</span> p.pname,p.price </span><br><span class="line"><span class="keyword">from</span> product <span class="keyword">as</span> p;</span><br><span class="line">-列别名：<span class="keyword">select</span> pname <span class="keyword">as</span> 商品名称,price <span class="keyword">as</span> 商品价格 <span class="keyword">from</span> product;</span><br><span class="line"><span class="keyword">select</span> pname <span class="keyword">as</span> 商品名称,price <span class="keyword">as</span> 商品价格 <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">4.去掉重复的值</span><br><span class="line">-查询商品所有的价格</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">5.select运算查询</span><br><span class="line"><span class="keyword">select</span> *,price*<span class="number">1.5</span> <span class="keyword">as</span> 折后价 <span class="keyword">from</span> product; </span><br><span class="line"></span><br><span class="line">6.条件查询[where关键字]</span><br><span class="line">指定条件，确定要操作的记录</span><br><span class="line">-查询商品价格大于60元的所有商品信息</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price&gt;<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">7.where 后的条件写法</span><br><span class="line">-关系运算符：&gt;  &gt;=  &lt;  &lt;=   =  !=  &lt;&gt;</span><br><span class="line">&lt;&gt; : 不等于   ：标准SQL语法</span><br><span class="line">!= : 不等于   ：非标准SQL语法</span><br><span class="line">-查询商品价格不等于88的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;&gt; <span class="number">88</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price != <span class="number">88</span>;</span><br><span class="line">-查询商品价格在10到100之间的商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price&lt;<span class="number">100</span> <span class="keyword">and</span> price &gt;<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line">-逻辑运算：and   or   not</span><br><span class="line">-查询出商品价格 小于100 或者大于900</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> price &lt;<span class="number">100</span> <span class="keyword">or</span> price &gt;<span class="number">900</span>;</span><br></pre></td></tr></table></figure><ul><li>复杂查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.like :模糊查询</span><br><span class="line">_ ：代表的是一个字符</span><br><span class="line">% ：代表的是多个字符</span><br><span class="line">in：在某个范围内获得值</span><br><span class="line">-查询出名字中带有饼的所有商品  ‘%饼%’</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'%饼%'</span>;</span><br><span class="line">-查询第二名字是熊的所有商品  '_熊%'</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'_熊%'</span>;</span><br><span class="line">-查询出商品分类ID在1，4，5里面的所有商品</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> cno <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">2.排序查询: order by  关键字</span><br><span class="line">asc:   ascend  升序（默认的排序方式）</span><br><span class="line">desc： descend 降序</span><br><span class="line">-查询所有商品，按照降序排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line">-查询名称有“小”的商品，按照升序排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">'%小%'</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line">3.聚合函数：</span><br><span class="line">-获得所有商品价格总和：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> product;</span><br><span class="line">-获得所有商品价格平均值：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(price) <span class="keyword">from</span> product;</span><br><span class="line">-获得所有商品的个数：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> product;</span><br><span class="line"></span><br><span class="line">4.分组：group by</span><br><span class="line">-根据cno字段分组，分组后统计商品的个数</span><br><span class="line"><span class="keyword">select</span> cno,<span class="keyword">count</span>(*) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno; </span><br><span class="line">-根据cno字段分组，分组后统计商品的平均价格，并且商品平均价格 &gt;60</span><br><span class="line"><span class="keyword">select</span> cno,<span class="keyword">avg</span>(price) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> cno <span class="keyword">having</span> <span class="keyword">avg</span>(price) &gt;<span class="number">60</span>;</span><br><span class="line">-having 关键字，他可以接聚合函数的，  出现在分组之后</span><br><span class="line">-where 关键字，他不可以接聚合函数，出现在分组之前</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编写顺序：</span><br><span class="line">S..F..W..G..H..O</span><br><span class="line">select..from..where..group by..having..drder <span class="keyword">by</span></span><br><span class="line">执行顺序：</span><br><span class="line">F..W..G..H..S..O</span><br><span class="line">from..where..group by..having..select..drder <span class="keyword">by</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了数据库，和一些基本操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://daqwt.top/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql安装与卸载</title>
    <link href="http://daqwt.top/3168578773/"/>
    <id>http://daqwt.top/3168578773/</id>
    <published>2020-02-01T12:05:03.000Z</published>
    <updated>2020-04-17T03:13:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>MySql的卸载与安装</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>运行安装程序，在启动配置教程之前，一路下一步，没有下一步的话就直接<code>finish</code></li><li>第一次<code>finish</code>之后启动服务器配置教程</li><li>第一个注意：<code>include mysql bin directory to windows path</code></li><li>第二个注意：端口号不要修改，字符集选择UTF-8</li></ul><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><ul><li>打开控制面板，删除软件</li><li>删除mysql安装目录的所有文件</li><li>删除mysql数据存放文件，C盘下面的<code>Programe data</code>里，它是隐藏文件，要点击查看隐藏文件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySql的卸载与安装&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://daqwt.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://daqwt.top/tags/MySql/"/>
    
  </entry>
  
</feed>
