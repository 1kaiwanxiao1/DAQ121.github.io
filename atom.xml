<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代澳旗&#39;s Blog</title>
  
  <subtitle>Welcome to my World！！！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-05T12:07:58.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>代澳旗</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事务-学习笔记</title>
    <link href="http://yoursite.com/2020/03/05/%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/05/%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-03-05T12:05:03.000Z</published>
    <updated>2020-03-05T12:07:58.756Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、事务（Transaction）概述"><a href="#一、事务（Transaction）概述" class="headerlink" title="一、事务（Transaction）概述"></a>一、事务（Transaction）概述</h1><ul><li>其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(<strong>回滚</strong>)。</li><li><strong>为什么要有事务?</strong><br>为了确保逻辑的成功。 如： 银行转账。 <h1 id="二、演示事务"><a href="#二、演示事务" class="headerlink" title="二、演示事务"></a>二、演示事务</h1><ul><li>命令行方式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开启事务：</span><br><span class="line">start transaction;</span><br><span class="line">提交：</span><br><span class="line">commit; 提交事务， 数据将会写到磁盘上的数据库</span><br><span class="line">回滚：</span><br><span class="line">rollback ;  数据回滚，回到最初的状态。</span><br></pre></td></tr></table></figure></li></ul></li><li>代码里面的事务，主要是针对连接来的。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 通过conn.setAutoCommit（<span class="literal">false</span> ）来关闭自动提交的设置。</span><br><span class="line">- 提交事务  conn.commit();</span><br><span class="line">- 回滚事务 conn.rollback();</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void <span class="function"><span class="title">testTransaction</span></span>()&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">try &#123;</span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"></span><br><span class="line">//连接，事务默认就是自动提交的。 关闭自动提交。</span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"update account set money = money - ? where id = ?"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//扣钱， 扣ID为1 的100块钱</span><br><span class="line">ps.setInt(1, 100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">int a = 10 /0 ;//有了异常，下面代码就不会执行了</span><br><span class="line"></span><br><span class="line">//加钱， 给ID为2 加100块钱</span><br><span class="line">ps.setInt(1, -100);</span><br><span class="line">ps.setInt(2, 2);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">//成功： 提交事务。</span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//失败： 回滚事务</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、事务特性ACID（面试）"><a href="#三、事务特性ACID（面试）" class="headerlink" title="三、事务特性ACID（面试）"></a>三、事务特性ACID（面试）</h1></li><li>原子性（Atom）<br>指的是 事务中包含的逻辑，不可分割。 </li><li>一致性（Consistent）<br>指的是 事务执行前后，数据完整性。</li><li>隔离性（Isolate）<br>指的是 事务在执行期间不应该受到其他事务的影响。</li><li>持久性（Durable）<br>指的是 事务执行成功，那么数据应该持久保存到磁盘上。<h1 id="四、安全问题-amp-隔离级别（面试）"><a href="#四、安全问题-amp-隔离级别（面试）" class="headerlink" title="四、安全问题&amp;隔离级别（面试）"></a>四、安全问题&amp;隔离级别（面试）</h1></li><li><strong>不考虑隔离级别设置</strong>，那么会出现以下问题。</li></ul><h2 id="读-问题"><a href="#读-问题" class="headerlink" title="读  问题"></a>读  问题</h2><ul><li>脏读<br>一个事务读到另外一个事务还未提交的数据。</li><li>不可重复读<br>一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。<ul><li>幻读<br>一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一致。</li></ul></li></ul><h2 id="写-问题"><a href="#写-问题" class="headerlink" title="写  问题"></a>写  问题</h2><ul><li>丢失更新：<br>B事务如果提交，会造成A事务的操作无效。<br>B事务回滚，也会造成A事务更新失效。</li><li>解决方法：悲观锁，乐观锁</li></ul><ol><li>悲观锁<br>指事务在一开始就认为丢失更新一定会发生， 这是一件很悲观的事情。 具体操作步骤如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. 所以事务在执行操作前，先查询一次数据， 查询语句如下：</span><br><span class="line">select * from student  <span class="keyword">for</span> update  ;           </span><br><span class="line">后面的<span class="keyword">for</span> update 其实是数据库锁机制 、 一种排他锁。</span><br><span class="line">4. 哪个事务先执行这个语句， 哪个事务就持有了这把锁， 可以查询出来数据， 后面的事务想再执行这条语句，不会有任何数据显示，就只能等着。 </span><br><span class="line">5. 一直等到前面的那个事务提交数据后， 后面的事务数据才会出来，那么才可以往下接着操作。 </span><br><span class="line">补充：就像排队上厕所一样，只有里面的人出来了，才能进去。 这其实就是 java 中的同步的概念。</span><br></pre></td></tr></table></figure></li><li>乐观锁<br> 乐观锁是指，从来不会觉得丢失更新会发生。要求程序员在数据库中添加字段，然后在后续更新的时候，对该字段进行判定比对， 如果一致才允许更新。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">1. 数据库表中，额外添加了一个version字段， 用于记录版本， 默认从0 开始， 只要有针对表中数据进行修改的，那么version就+1.</span><br><span class="line">2. 开启A事务， 然后开启B事务 。 </span><br><span class="line">3. A 先执行数据库表操作。 因为以前都没有人修改过。 所以是允许A事务修改数据库的，但是修改完毕，就把version的值变成  1 了 。</span><br><span class="line">4. B事务， 这时候如果想执行修改，那么是不允许修改的。 因为B事务以前是没有查询过数据库内容的，所以它认为数据库版本还是0 。 但是数据库的版本经过A修改，已经是1了。</span><br><span class="line">所以这时候不允许修改， 要求其重新查询 。</span><br><span class="line">5. B重新查询后， 将会得到version 为 1的数据，这份数据就是之前A 事务修改的数据了， B 在进行修改，也是在A的基础上修改的。 所以就不会有丢失更新的情况出现了。</span><br><span class="line"></span><br><span class="line">补充：乐观锁的机制 ，其实是通过比对版本或者比对字段的方式来实现的，与版本控制软件【SVN , GIT】机制是一样的。</span><br></pre></td></tr></table></figure></li></ol><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 按效率划分，从高到低</span><br><span class="line">读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</span><br><span class="line"></span><br><span class="line">- 按拦截程度 ，从高到底</span><br><span class="line">可串行化 &gt; 可重复读  &gt; 读已提交  &gt;  读未提交</span><br></pre></td></tr></table></figure><ul><li>Read Uncommited【读未提交】<br>指的是 ： 一个事务可以读取到另一个事务还未提交的数据。 这就会引发 “脏读” 读取到的是数据库<strong>内存</strong>中的数据，而并非真正磁盘上的数据。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子： </span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">设置当前窗口的事务隔离级别为：读未提交  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> uncommitted;</span><br><span class="line">2. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交</span><br><span class="line">3. 在A窗口重新执行查询， 会看到B窗口没有提交的数据。</span><br></pre></td></tr></table></figure></li><li>Read Commited 【读已提交】<br>与前面的读未提交刚好相反，这个隔离级别是 ，只能读取到其他事务已经提交的数据，那些没有提交的数据是读不出来的。屏蔽了脏读的情况，但是这会造成一个问题是： 前后读取到的结果不一样。 发生了不可重复!!!, 所谓的不可重复读，就是不能执行多次读取，否则出现结果不一样。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line"> 设置当前窗口的事务隔离级别为：读已提交  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> committed;</span><br><span class="line">2. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">3. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">4. 在B窗口执行提交。</span><br><span class="line">5. 在A窗口中执行查看， 这时候才会看到B窗口已经修改的结果。</span><br><span class="line">6. 但是这会造成一个问题是： 在A窗口中， 第一次查看数据和第二次查看数据，结果不一样。</span><br></pre></td></tr></table></figure><ul><li>Repeatable Read 【重复读】<br>MySql 默认的隔离级别就是这个。该隔离级别， 可以让事务在自己的会话中重复读取数据，并且不会出现结果不一样的状况，即使其他事务已经提交了，也依然还是显示以前的数据。（读到的不是最新更新的数据，确保本事务不受其他事务影响）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2. 设置当前窗口的事务隔离级别为：重复读  命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level repeatable <span class="built_in">read</span>;</span><br><span class="line">3. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4. 在A窗口重新执行查询， 是不会看到B窗口刚才执行sql 语句的结果，因为它还没有提交。</span><br><span class="line">5. 在B窗口执行提交。</span><br><span class="line">6. 在A窗口中执行查看， 这时候查询结果，和以前的查询结果一致。不会发生改变。</span><br></pre></td></tr></table></figure><ul><li>Serializable 【可串行化（序列化）】<br>该事务级别是最高级的事务级别了，如果有一个连接设置隔离级别为可串行化，那么谁先打开事务，谁就有了先执行的权利，谁后打开事务，就只能等着，等前面的那个事务，提交或者回滚后才会执行。这种隔离级别比前面几种都要强大一点，也就是前面几种的问题【脏读、不可重复读、幻读】都能够解决。但是都使用该隔离级别也会有些问题。 比如造成并发的性能问题。 其他的事务必须得等当前正在操作表的事务先提交，才能接着往下，否则只能一直在等着。所以比较少用，容易造成性能上的问题，效率比较低。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">1. 开启一个命令行窗口A， 开始事务，然后查询表中记录。  </span><br><span class="line">2. 设置当前窗口的事务隔离级别为：serializable 命令如下：</span><br><span class="line"><span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> serializable;</span><br><span class="line">3. 另外在打开一个窗口B， 也开启事务， 然后执行 sql 语句， 但是不提交 </span><br><span class="line">4. 在A窗口重新执行查询， 会卡主，没有任何信息显示。 </span><br><span class="line">5. 在B窗口执行提交。</span><br><span class="line">6. 在A窗口中执行查看， 这时候才会显示结果。</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ol><li><p>在代码里面使用事务 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">conn.commit();</span><br><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure></li><li><p>事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。</p></li><li><p>事务是会自动提交的。 </p></li><li><p>安全隐患：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读</span><br><span class="line">脏读：一个事务读到了另一个事务未提交的数据。</span><br><span class="line">不可重复读：一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致。</span><br><span class="line">幻读：一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。</span><br><span class="line">写</span><br><span class="line">丢失更新。</span><br></pre></td></tr></table></figure></li><li><p>隔离级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读未提交</span><br><span class="line">&gt; 引发问题： 脏读 </span><br><span class="line">读已提交</span><br><span class="line">&gt; 解决： 脏读 ， 引发： 不可重复读</span><br><span class="line">可重复读</span><br><span class="line">&gt; 解决： 脏读 、 不可重复读 ， 未解决： 幻读</span><br><span class="line">可串行化</span><br><span class="line">&gt; 解决： 脏读、 不可重复读 、 幻读。  导致：性能下降</span><br></pre></td></tr></table></figure></li><li><p>补充：<br>```bash<br>mySql 默认的隔离级别是 可重复读<br>Oracle 默认的隔离级别是  读已提交</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、事务（Transaction）概述&quot;&gt;&lt;a href=&quot;#一、事务（Transaction）概述&quot; class=&quot;headerlink&quot; title=&quot;一、事务（Transaction）概述&quot;&gt;&lt;/a&gt;一、事务（Transactio
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>daq</title>
    <link href="http://yoursite.com/2020/03/05/daq/"/>
    <id>http://yoursite.com/2020/03/05/daq/</id>
    <published>2020-03-05T08:51:24.000Z</published>
    <updated>2020-03-05T08:51:40.243Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="现在好了吗？" scheme="http://yoursite.com/tags/%E7%8E%B0%E5%9C%A8%E5%A5%BD%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    
  </entry>
  
</feed>
