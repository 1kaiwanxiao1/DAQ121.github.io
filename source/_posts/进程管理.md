---
title: 操作系统---进程管理
toc: true
tags: OS
categories: 计算机操作系统
abbrlink: 853277148
date: 2020-03-19 22:46:46
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程，也就是任务，这里有必要说一下进程和线程的区别：进程是资源分配的最小单位，线程是程序执行的最小单位，通俗来讲，一个爹可以有很多儿子，但儿子之后一个爹，并且还遗传这个爹，爹能做大事，而儿子，做一些杂七杂八的给爹打下手，你细细品。这篇文章主要讲进程管理的策略。
<!--more-->

## 进程概念
- 进程：打开任务管理器，里面正在执行的任务，一个程序运行起来了，它就是一个进程。
- `jobs`是最早的进程原型，也就是单道批处理系统，cpu一次只运行一个程序，其他的程序要事先放在内存中，等待上一个程序执行完了，他再去执行。
- 后来出现了分时操作系统，大家轮着执行。使用cpu，称之为任务。


## 进程组成

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319160008644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70)

- 程序计数器（pc）和各种寄存器
- 数据段
- 代码段
- 栈
- 堆
- 栈内存，堆内存慢慢增长，到一定程度，会导致内存不足的情况。

## 进程状态


- 操作系统就是通过切换进程的状态，达到进程控制的目的。也实现了很多进程同时运行，周而复始。有条不紊

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319161707691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70)
- new（新建）
- ready（就绪态）：一个进程是完全可以运行的，万事俱备，只差cpu。
- running（运行态）：拥有cpu的进程，一个cpu上只能运行一个进程，什么时候它会把cpu交出去？
①中断interrupt：她本可以继续运行下去的，但是操作系统觉得它运行的太久了。或者是有更重要的要做，所以就把他给中断了，打回到就绪态。
②主动让出cpu：这个进程要去做一个io操作，或者是等待一个事件（等不到这个指令，他就不知道要做什么），这个时候就会让出cpu。进入就绪状态。
- waiting（等待态）：被唤醒（有响应了，知道自己该做什么了）之后进入就绪态。
- terminated（结束）

## 进程控制块PCB
- 进程控制块PCB（Process Control  Block）是一个结构体，通过它来控制进程。每个进程都有一个PCB。通过PCB能找到这个进程的位置，状态，信息。
- 进程1切换的时候，将这个进程的所有信息保存到PCB寄存器中，以保证下次在运行的时候，就是上次停止的状态。
- 如何挑选下一个进程来执行呢，这就涉及到内核的调度算法了。
- 所有的PCB结构体，在一起构成了一个队列。
- 进程是在不同的队列之间，来回迁移。例如：就绪队列，I/O等待队列。
- 用一个大数组来装所有的PCB结构体，用一个指针来指向PCB数组中的这个进程。
- 软件做不了的事，硬件可以做。


## 进程的创建
- 一开机就会发现有进程，这些都是系统级的进程 ，如shell，资源管理器，一些应用程序设置的开机自启动就是通过shell来启动的，相当于捆绑销售一样 。
- 打开应用程序，双击，这个命令给了资源管理器，或者命令行下，是把指令给了shell
- 父进程与子进程
- unix创建进程：fork（）生成一个子进程 
- top 命令，监视现在所有进程的状态，每隔一秒种刷新一次。
- windows创建进程：create process 
- msdn---微软的百科全书。 
- 杀死进程：kill

## 进程间通信
多进程模式模块化
- **消息传递（Mwssage passing）** ：A进程把消息从自己的内存空间复制一份到内核中，然后内核再把消息复制一份给进程B。用系统调用进行信息传递。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319194014153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70)
- **共享内存（Shared memory）：** 每个进程都有自己独立的地址空间，但是两个进程，甚至更多的进程通过协商（也是系统调用来协商）划分出来一块儿共享内存。在每个进程的地址空间都有。A在这块儿空间里一写数据，B马上就可以读取到。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200319194244682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg2MTM5OQ==,size_16,color_FFFFFF,t_70)
- 共享内存在协商的时候，要经过一系列的系统调用。而且还要约定好，过程很麻烦。如果进程之间共享内存，就要负责任，实现同步，不要同时写在同一个地方。
- **消息传递** 很方便。经常用到。分为两种：
①阻塞型：（更好用）
当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么你当前这个进程就会被挂起，被放到等待状态，被阻塞。
②非阻塞型：（考虑的比较多 ）
当你调了这个系统调用之后，如果你请求的结果不能立即得到。那么这个请求会在后台去操作，同时这个系统调用会返回，空闲时候会回到你的进程，这个系统调用的返回值会告诉你，这个操作没有完成，进程根据这个返回值来判断是否完成操作，并做其他操作。

## 多进程编程
- 父进程会把所有的信息复制一份给子进程，自此变成两个独立的进程，互相不影响。
- 以我们的角度来看，这样的子进程，父进程是不是太浪费内存了，但是，操作系统只是表面上让你看到它是把父进程复制给了子进程，但其实，他可以做到父进程和子进程之间完全相同的部分之间共享内存。所以大可不必担心这个问题。
- 多进程编程最重要的一个特性，也是我们首先要了解到的，独立性，直观上来看，他们两个进程之间互相不干扰。

## 线程
- 进程的特点是分离，而线程就是不分离。 互相协作的关系
- 线程有： 线程ID，PC寄存器，栈 。。。 
-  引入进程的目的就是让一个进程里面同时有多条执行路线，同时发挥作用。
- 多线程优点：
①快速的响应能力：有比较耗时的操作是，创建线程去做，主线程用来和用户 交互。
②资源共享：协作更方便，数据传递更方便
③经济实惠：线程更加节约资源。 

- 用户级线程：
①优点：效率高，可定制性好，。
②缺点：用户线程中任何一个线程，如果调用了阻塞性的系统调用，那么所有用户线程就全被阻塞。因为在操作系统看来，这么这个线程就是同一个线程，就会被阻塞掉。用户线程不能在多个处理器上并行运行。
- 内核级线程：操作系统提供的线程。
- 线程池：先创建多少个线程，要用的时候 就去拿，但是也有缺点。 

